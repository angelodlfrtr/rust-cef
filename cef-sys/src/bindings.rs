/* automatically generated by rust-bindgen 0.60.1 */

pub type __time_t = ::std::os::raw::c_long;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type int64 = ::std::os::raw::c_long;
pub type uint64 = ::std::os::raw::c_ulong;
pub type int32 = ::std::os::raw::c_int;
pub type uint32 = ::std::os::raw::c_uint;
pub type char16 = ::std::os::raw::c_ushort;
#[doc = ""]
#[doc = " CEF string type definitions. Whomever allocates |str| is responsible for"]
#[doc = " providing an appropriate |dtor| implementation that will free the string in"]
#[doc = " the same memory space. When reusing an existing string structure make sure"]
#[doc = " to call |dtor| for the old value before assigning new |str| and |dtor|"]
#[doc = " values. Static strings will have a NULL |dtor| value. Using the below"]
#[doc = " functions if you want this managed for you."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_string_wide_t {
    pub str_: *mut wchar_t,
    pub length: size_t,
    pub dtor: ::std::option::Option<unsafe extern "C" fn(str_: *mut wchar_t)>,
}
#[test]
fn bindgen_test_layout__cef_string_wide_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_string_wide_t>(),
        24usize,
        concat!("Size of: ", stringify!(_cef_string_wide_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_string_wide_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_string_wide_t))
    );
    fn test_field_str() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_string_wide_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_string_wide_t),
                "::",
                stringify!(str_)
            )
        );
    }
    test_field_str();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_string_wide_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_string_wide_t),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_dtor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_string_wide_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dtor) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_string_wide_t),
                "::",
                stringify!(dtor)
            )
        );
    }
    test_field_dtor();
}
#[doc = ""]
#[doc = " CEF string type definitions. Whomever allocates |str| is responsible for"]
#[doc = " providing an appropriate |dtor| implementation that will free the string in"]
#[doc = " the same memory space. When reusing an existing string structure make sure"]
#[doc = " to call |dtor| for the old value before assigning new |str| and |dtor|"]
#[doc = " values. Static strings will have a NULL |dtor| value. Using the below"]
#[doc = " functions if you want this managed for you."]
#[doc = ""]
pub type cef_string_wide_t = _cef_string_wide_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_string_utf8_t {
    pub str_: *mut ::std::os::raw::c_char,
    pub length: size_t,
    pub dtor: ::std::option::Option<unsafe extern "C" fn(str_: *mut ::std::os::raw::c_char)>,
}
#[test]
fn bindgen_test_layout__cef_string_utf8_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_string_utf8_t>(),
        24usize,
        concat!("Size of: ", stringify!(_cef_string_utf8_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_string_utf8_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_string_utf8_t))
    );
    fn test_field_str() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_string_utf8_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_string_utf8_t),
                "::",
                stringify!(str_)
            )
        );
    }
    test_field_str();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_string_utf8_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_string_utf8_t),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_dtor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_string_utf8_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dtor) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_string_utf8_t),
                "::",
                stringify!(dtor)
            )
        );
    }
    test_field_dtor();
}
pub type cef_string_utf8_t = _cef_string_utf8_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_string_utf16_t {
    pub str_: *mut char16,
    pub length: size_t,
    pub dtor: ::std::option::Option<unsafe extern "C" fn(str_: *mut char16)>,
}
#[test]
fn bindgen_test_layout__cef_string_utf16_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_string_utf16_t>(),
        24usize,
        concat!("Size of: ", stringify!(_cef_string_utf16_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_string_utf16_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_string_utf16_t))
    );
    fn test_field_str() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_string_utf16_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).str_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_string_utf16_t),
                "::",
                stringify!(str_)
            )
        );
    }
    test_field_str();
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_string_utf16_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_string_utf16_t),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_dtor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_string_utf16_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dtor) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_string_utf16_t),
                "::",
                stringify!(dtor)
            )
        );
    }
    test_field_dtor();
}
pub type cef_string_utf16_t = _cef_string_utf16_t;
extern "C" {
    #[doc = ""]
    #[doc = " These functions set string values. If |copy| is true (1) the value will be"]
    #[doc = " copied instead of referenced. It is up to the user to properly manage"]
    #[doc = " the lifespan of references."]
    #[doc = ""]
    pub fn cef_string_wide_set(
        src: *const wchar_t,
        src_len: size_t,
        output: *mut cef_string_wide_t,
        copy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf8_set(
        src: *const ::std::os::raw::c_char,
        src_len: size_t,
        output: *mut cef_string_utf8_t,
        copy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf16_set(
        src: *const char16,
        src_len: size_t,
        output: *mut cef_string_utf16_t,
        copy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions clear string values. The structure itself is not freed."]
    #[doc = ""]
    pub fn cef_string_wide_clear(str_: *mut cef_string_wide_t);
}
extern "C" {
    pub fn cef_string_utf8_clear(str_: *mut cef_string_utf8_t);
}
extern "C" {
    pub fn cef_string_utf16_clear(str_: *mut cef_string_utf16_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions compare two string values with the same results as strcmp()."]
    #[doc = ""]
    pub fn cef_string_wide_cmp(
        str1: *const cef_string_wide_t,
        str2: *const cef_string_wide_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf8_cmp(
        str1: *const cef_string_utf8_t,
        str2: *const cef_string_utf8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf16_cmp(
        str1: *const cef_string_utf16_t,
        str2: *const cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions convert between UTF-8, -16, and -32 strings. They are"]
    #[doc = " potentially slow so unnecessary conversions should be avoided. The best"]
    #[doc = " possible result will always be written to |output| with the boolean return"]
    #[doc = " value indicating whether the conversion is 100% valid."]
    #[doc = ""]
    pub fn cef_string_wide_to_utf8(
        src: *const wchar_t,
        src_len: size_t,
        output: *mut cef_string_utf8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf8_to_wide(
        src: *const ::std::os::raw::c_char,
        src_len: size_t,
        output: *mut cef_string_wide_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_wide_to_utf16(
        src: *const wchar_t,
        src_len: size_t,
        output: *mut cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf16_to_wide(
        src: *const char16,
        src_len: size_t,
        output: *mut cef_string_wide_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf8_to_utf16(
        src: *const ::std::os::raw::c_char,
        src_len: size_t,
        output: *mut cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf16_to_utf8(
        src: *const char16,
        src_len: size_t,
        output: *mut cef_string_utf8_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions convert an ASCII string, typically a hardcoded constant, to"]
    #[doc = " a Wide/UTF16 string. Use instead of the UTF8 conversion routines if you know"]
    #[doc = " the string is ASCII."]
    #[doc = ""]
    pub fn cef_string_ascii_to_wide(
        src: *const ::std::os::raw::c_char,
        src_len: size_t,
        output: *mut cef_string_wide_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_ascii_to_utf16(
        src: *const ::std::os::raw::c_char,
        src_len: size_t,
        output: *mut cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " It is sometimes necessary for the system to allocate string structures with"]
#[doc = " the expectation that the user will free them. The userfree types act as a"]
#[doc = " hint that the user is responsible for freeing the structure."]
#[doc = ""]
pub type cef_string_userfree_wide_t = *mut cef_string_wide_t;
pub type cef_string_userfree_utf8_t = *mut cef_string_utf8_t;
pub type cef_string_userfree_utf16_t = *mut cef_string_utf16_t;
extern "C" {
    #[doc = ""]
    #[doc = " These functions allocate a new string structure. They must be freed by"]
    #[doc = " calling the associated free function."]
    #[doc = ""]
    pub fn cef_string_userfree_wide_alloc() -> cef_string_userfree_wide_t;
}
extern "C" {
    pub fn cef_string_userfree_utf8_alloc() -> cef_string_userfree_utf8_t;
}
extern "C" {
    pub fn cef_string_userfree_utf16_alloc() -> cef_string_userfree_utf16_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions free the string structure allocated by the associated"]
    #[doc = " alloc function. Any string contents will first be cleared."]
    #[doc = ""]
    pub fn cef_string_userfree_wide_free(str_: cef_string_userfree_wide_t);
}
extern "C" {
    pub fn cef_string_userfree_utf8_free(str_: cef_string_userfree_utf8_t);
}
extern "C" {
    pub fn cef_string_userfree_utf16_free(str_: cef_string_userfree_utf16_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " These functions convert utf16 string case using the current ICU locale. This"]
    #[doc = " may change the length of the string in some cases."]
    #[doc = ""]
    pub fn cef_string_utf16_to_lower(
        src: *const char16,
        src_len: size_t,
        output: *mut cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_string_utf16_to_upper(
        src: *const char16,
        src_len: size_t,
        output: *mut cef_string_utf16_t,
    ) -> ::std::os::raw::c_int;
}
pub type cef_char_t = char16;
pub type cef_string_userfree_t = cef_string_userfree_utf16_t;
pub type cef_string_t = cef_string_utf16_t;
#[doc = ""]
#[doc = " CEF string maps are a set of key/value string pairs."]
#[doc = ""]
pub type cef_string_list_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = ""]
    #[doc = " Allocate a new string map."]
    #[doc = ""]
    pub fn cef_string_list_alloc() -> cef_string_list_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the number of elements in the string list."]
    #[doc = ""]
    pub fn cef_string_list_size(list: cef_string_list_t) -> size_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Retrieve the value at the specified zero-based string list index. Returns"]
    #[doc = " true (1) if the value was successfully retrieved."]
    #[doc = ""]
    pub fn cef_string_list_value(
        list: cef_string_list_t,
        index: size_t,
        value: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Append a new value at the end of the string list."]
    #[doc = ""]
    pub fn cef_string_list_append(list: cef_string_list_t, value: *const cef_string_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Clear the string list."]
    #[doc = ""]
    pub fn cef_string_list_clear(list: cef_string_list_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Free the string list."]
    #[doc = ""]
    pub fn cef_string_list_free(list: cef_string_list_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Creates a copy of an existing string list."]
    #[doc = ""]
    pub fn cef_string_list_copy(list: cef_string_list_t) -> cef_string_list_t;
}
#[doc = ""]
#[doc = " CEF string maps are a set of key/value string pairs."]
#[doc = ""]
pub type cef_string_map_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = ""]
    #[doc = " Allocate a new string map."]
    #[doc = ""]
    pub fn cef_string_map_alloc() -> cef_string_map_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the number of elements in the string map."]
    #[doc = ""]
    pub fn cef_string_map_size(map: cef_string_map_t) -> size_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the value assigned to the specified key."]
    #[doc = ""]
    pub fn cef_string_map_find(
        map: cef_string_map_t,
        key: *const cef_string_t,
        value: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the key at the specified zero-based string map index."]
    #[doc = ""]
    pub fn cef_string_map_key(
        map: cef_string_map_t,
        index: size_t,
        key: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the value at the specified zero-based string map index."]
    #[doc = ""]
    pub fn cef_string_map_value(
        map: cef_string_map_t,
        index: size_t,
        value: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Append a new key/value pair at the end of the string map."]
    #[doc = ""]
    pub fn cef_string_map_append(
        map: cef_string_map_t,
        key: *const cef_string_t,
        value: *const cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Clear the string map."]
    #[doc = ""]
    pub fn cef_string_map_clear(map: cef_string_map_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Free the string map."]
    #[doc = ""]
    pub fn cef_string_map_free(map: cef_string_map_t);
}
#[doc = ""]
#[doc = " CEF string multimaps are a set of key/value string pairs."]
#[doc = " More than one value can be assigned to a single key."]
#[doc = ""]
pub type cef_string_multimap_t = *mut ::std::os::raw::c_void;
extern "C" {
    #[doc = ""]
    #[doc = " Allocate a new string multimap."]
    #[doc = ""]
    pub fn cef_string_multimap_alloc() -> cef_string_multimap_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the number of elements in the string multimap."]
    #[doc = ""]
    pub fn cef_string_multimap_size(map: cef_string_multimap_t) -> size_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the number of values with the specified key."]
    #[doc = ""]
    pub fn cef_string_multimap_find_count(
        map: cef_string_multimap_t,
        key: *const cef_string_t,
    ) -> size_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the value_index-th value with the specified key."]
    #[doc = ""]
    pub fn cef_string_multimap_enumerate(
        map: cef_string_multimap_t,
        key: *const cef_string_t,
        value_index: size_t,
        value: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the key at the specified zero-based string multimap index."]
    #[doc = ""]
    pub fn cef_string_multimap_key(
        map: cef_string_multimap_t,
        index: size_t,
        key: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Return the value at the specified zero-based string multimap index."]
    #[doc = ""]
    pub fn cef_string_multimap_value(
        map: cef_string_multimap_t,
        index: size_t,
        value: *mut cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Append a new key/value pair at the end of the string multimap."]
    #[doc = ""]
    pub fn cef_string_multimap_append(
        map: cef_string_multimap_t,
        key: *const cef_string_t,
        value: *const cef_string_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Clear the string multimap."]
    #[doc = ""]
    pub fn cef_string_multimap_clear(map: cef_string_multimap_t);
}
extern "C" {
    #[doc = ""]
    #[doc = " Free the string multimap."]
    #[doc = ""]
    pub fn cef_string_multimap_free(map: cef_string_multimap_t);
}
pub type time_t = __time_t;
#[doc = ""]
#[doc = " Represents a wall clock time in UTC. Values are not guaranteed to be"]
#[doc = " monotonically non-decreasing and are subject to large amounts of skew."]
#[doc = " Time is stored internally as microseconds since the Windows epoch (1601)."]
#[doc = ""]
#[doc = " This is equivalent of Chromium `base::Time` (see base/time/time.h)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_basetime_t {
    pub val: int64,
}
#[test]
fn bindgen_test_layout__cef_basetime_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_basetime_t>(),
        8usize,
        concat!("Size of: ", stringify!(_cef_basetime_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_basetime_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_basetime_t))
    );
    fn test_field_val() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_basetime_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).val) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_basetime_t),
                "::",
                stringify!(val)
            )
        );
    }
    test_field_val();
}
#[doc = ""]
#[doc = " Represents a wall clock time in UTC. Values are not guaranteed to be"]
#[doc = " monotonically non-decreasing and are subject to large amounts of skew."]
#[doc = " Time is stored internally as microseconds since the Windows epoch (1601)."]
#[doc = ""]
#[doc = " This is equivalent of Chromium `base::Time` (see base/time/time.h)."]
#[doc = ""]
pub type cef_basetime_t = _cef_basetime_t;
#[doc = ""]
#[doc = " Time information. Values should always be in UTC."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_time_t {
    #[doc = ""]
    #[doc = " Four or five digit year \"2007\" (1601 to 30827 on Windows, 1970 to 2038 on"]
    #[doc = " 32-bit POSIX)"]
    #[doc = ""]
    pub year: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " 1-based month (values 1 = January, etc.)"]
    #[doc = ""]
    pub month: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " 0-based day of week (0 = Sunday, etc.)"]
    #[doc = ""]
    pub day_of_week: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " 1-based day of month (1-31)"]
    #[doc = ""]
    pub day_of_month: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Hour within the current day (0-23)"]
    #[doc = ""]
    pub hour: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Minute within the current hour (0-59)"]
    #[doc = ""]
    pub minute: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Second within the current minute (0-59 plus leap seconds which may take"]
    #[doc = " it up to 60)."]
    #[doc = ""]
    pub second: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Milliseconds within the current second (0-999)"]
    #[doc = ""]
    pub millisecond: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_time_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_time_t>(),
        32usize,
        concat!("Size of: ", stringify!(_cef_time_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_time_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_time_t))
    );
    fn test_field_year() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_time_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).year) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_time_t),
                "::",
                stringify!(year)
            )
        );
    }
    test_field_year();
    fn test_field_month() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_time_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_time_t),
                "::",
                stringify!(month)
            )
        );
    }
    test_field_month();
    fn test_field_day_of_week() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_time_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).day_of_week) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_time_t),
                "::",
                stringify!(day_of_week)
            )
        );
    }
    test_field_day_of_week();
    fn test_field_day_of_month() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_time_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).day_of_month) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_time_t),
                "::",
                stringify!(day_of_month)
            )
        );
    }
    test_field_day_of_month();
    fn test_field_hour() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_time_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hour) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_time_t),
                "::",
                stringify!(hour)
            )
        );
    }
    test_field_hour();
    fn test_field_minute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_time_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minute) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_time_t),
                "::",
                stringify!(minute)
            )
        );
    }
    test_field_minute();
    fn test_field_second() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_time_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).second) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_time_t),
                "::",
                stringify!(second)
            )
        );
    }
    test_field_second();
    fn test_field_millisecond() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_time_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).millisecond) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_time_t),
                "::",
                stringify!(millisecond)
            )
        );
    }
    test_field_millisecond();
}
#[doc = ""]
#[doc = " Time information. Values should always be in UTC."]
#[doc = ""]
pub type cef_time_t = _cef_time_t;
extern "C" {
    #[doc = ""]
    #[doc = " Converts cef_time_t to/from time_t. Returns true (1) on success and false"]
    #[doc = " (0) on failure."]
    #[doc = ""]
    pub fn cef_time_to_timet(
        cef_time: *const cef_time_t,
        time: *mut time_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_time_from_timet(time: time_t, cef_time: *mut cef_time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Converts cef_time_t to/from a double which is the number of seconds since"]
    #[doc = " epoch (Jan 1, 1970). Webkit uses this format to represent time. A value of 0"]
    #[doc = " means \"not initialized\". Returns true (1) on success and false (0) on"]
    #[doc = " failure."]
    #[doc = ""]
    pub fn cef_time_to_doublet(
        cef_time: *const cef_time_t,
        time: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn cef_time_from_doublet(time: f64, cef_time: *mut cef_time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Retrieve the current system time. Returns true (1) on success and false (0)"]
    #[doc = " on failure."]
    #[doc = ""]
    pub fn cef_time_now(cef_time: *mut cef_time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Retrieve the current system time."]
    #[doc = ""]
    pub fn cef_basetime_now() -> cef_basetime_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Retrieve the delta in milliseconds between two time values. Returns true (1)"]
    #[doc = " on success and false (0) on failure."]
    pub fn cef_time_delta(
        cef_time1: *const cef_time_t,
        cef_time2: *const cef_time_t,
        delta: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Converts cef_time_t to cef_basetime_t. Returns true (1) on success and"]
    #[doc = " false (0) on failure."]
    #[doc = ""]
    pub fn cef_time_to_basetime(
        from: *const cef_time_t,
        to: *mut cef_basetime_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Converts cef_basetime_t to cef_time_t. Returns true (1) on success and"]
    #[doc = " false (0) on failure."]
    #[doc = ""]
    pub fn cef_time_from_basetime(
        from: cef_basetime_t,
        to: *mut cef_time_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " Structure representing a point."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_point_t {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_point_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_point_t>(),
        8usize,
        concat!("Size of: ", stringify!(_cef_point_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_point_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_point_t))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_point_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_point_t),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_point_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_point_t),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
}
#[doc = ""]
#[doc = " Structure representing a point."]
#[doc = ""]
pub type cef_point_t = _cef_point_t;
#[doc = ""]
#[doc = " Structure representing a rectangle."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_rect_t {
    pub x: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_rect_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_rect_t>(),
        16usize,
        concat!("Size of: ", stringify!(_cef_rect_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_rect_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_rect_t))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_rect_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_rect_t),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_rect_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_rect_t),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_rect_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_rect_t),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_rect_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_rect_t),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
#[doc = ""]
#[doc = " Structure representing a rectangle."]
#[doc = ""]
pub type cef_rect_t = _cef_rect_t;
#[doc = ""]
#[doc = " Structure representing a size."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_size_t {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_size_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_size_t>(),
        8usize,
        concat!("Size of: ", stringify!(_cef_size_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_size_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_size_t))
    );
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_size_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_size_t),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_size_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_size_t),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
}
#[doc = ""]
#[doc = " Structure representing a size."]
#[doc = ""]
pub type cef_size_t = _cef_size_t;
#[doc = ""]
#[doc = " Structure representing insets."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_insets_t {
    pub top: ::std::os::raw::c_int,
    pub left: ::std::os::raw::c_int,
    pub bottom: ::std::os::raw::c_int,
    pub right: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_insets_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_insets_t>(),
        16usize,
        concat!("Size of: ", stringify!(_cef_insets_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_insets_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_insets_t))
    );
    fn test_field_top() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_insets_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).top) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_insets_t),
                "::",
                stringify!(top)
            )
        );
    }
    test_field_top();
    fn test_field_left() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_insets_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).left) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_insets_t),
                "::",
                stringify!(left)
            )
        );
    }
    test_field_left();
    fn test_field_bottom() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_insets_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bottom) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_insets_t),
                "::",
                stringify!(bottom)
            )
        );
    }
    test_field_bottom();
    fn test_field_right() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_insets_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).right) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_insets_t),
                "::",
                stringify!(right)
            )
        );
    }
    test_field_right();
}
#[doc = ""]
#[doc = " Structure representing insets."]
#[doc = ""]
pub type cef_insets_t = _cef_insets_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XEvent {
    _unused: [u8; 0],
}
pub type XEvent = _XEvent;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XDisplay {
    _unused: [u8; 0],
}
pub type XDisplay = _XDisplay;
extern "C" {
    pub fn cef_get_xdisplay() -> *mut XDisplay;
}
#[doc = ""]
#[doc = " Structure representing CefExecuteProcess arguments."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_main_args_t {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout__cef_main_args_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_main_args_t>(),
        16usize,
        concat!("Size of: ", stringify!(_cef_main_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_main_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_main_args_t))
    );
    fn test_field_argc() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_main_args_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).argc) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_main_args_t),
                "::",
                stringify!(argc)
            )
        );
    }
    test_field_argc();
    fn test_field_argv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_main_args_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).argv) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_main_args_t),
                "::",
                stringify!(argv)
            )
        );
    }
    test_field_argv();
}
#[doc = ""]
#[doc = " Structure representing CefExecuteProcess arguments."]
#[doc = ""]
pub type cef_main_args_t = _cef_main_args_t;
#[doc = ""]
#[doc = " Class representing window information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_window_info_t {
    #[doc = ""]
    #[doc = " The initial title of the window, to be set when the window is created."]
    #[doc = " Some layout managers (e.g., Compiz) can look at the window title"]
    #[doc = " in order to decide where to place the window when it is"]
    #[doc = " created. When this attribute is not empty, the window title will"]
    #[doc = " be set before the window is mapped to the dispay. Otherwise the"]
    #[doc = " title will be initially empty."]
    #[doc = ""]
    pub window_name: cef_string_t,
    #[doc = ""]
    #[doc = " Initial window bounds."]
    #[doc = ""]
    pub bounds: cef_rect_t,
    #[doc = ""]
    #[doc = " Pointer for the parent window."]
    #[doc = ""]
    pub parent_window: ::std::os::raw::c_ulong,
    #[doc = ""]
    #[doc = " Set to true (1) to create the browser using windowless (off-screen)"]
    #[doc = " rendering. No window will be created for the browser and all rendering"]
    #[doc = " will occur via the CefRenderHandler interface. The |parent_window| value"]
    #[doc = " will be used to identify monitor info and to act as the parent window for"]
    #[doc = " dialogs, context menus, etc. If |parent_window| is not provided then the"]
    #[doc = " main screen monitor will be used and some functionality that requires a"]
    #[doc = " parent window may not function correctly. In order to create windowless"]
    #[doc = " browsers the CefSettings.windowless_rendering_enabled value must be set to"]
    #[doc = " true. Transparent painting is enabled by default but can be disabled by"]
    #[doc = " setting CefBrowserSettings.background_color to an opaque value."]
    #[doc = ""]
    pub windowless_rendering_enabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to enable shared textures for windowless rendering. Only"]
    #[doc = " valid if windowless_rendering_enabled above is also set to true. Currently"]
    #[doc = " only supported on Windows (D3D11)."]
    #[doc = ""]
    pub shared_texture_enabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to enable the ability to issue BeginFrame requests from"]
    #[doc = " the client application by calling CefBrowserHost::SendExternalBeginFrame."]
    #[doc = ""]
    pub external_begin_frame_enabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Pointer for the new browser window. Only used with windowed rendering."]
    #[doc = ""]
    pub window: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout__cef_window_info_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_window_info_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_window_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_window_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_window_info_t))
    );
    fn test_field_window_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_window_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).window_name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_window_info_t),
                "::",
                stringify!(window_name)
            )
        );
    }
    test_field_window_name();
    fn test_field_bounds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_window_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bounds) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_window_info_t),
                "::",
                stringify!(bounds)
            )
        );
    }
    test_field_bounds();
    fn test_field_parent_window() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_window_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).parent_window) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_window_info_t),
                "::",
                stringify!(parent_window)
            )
        );
    }
    test_field_parent_window();
    fn test_field_windowless_rendering_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_window_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).windowless_rendering_enabled) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_window_info_t),
                "::",
                stringify!(windowless_rendering_enabled)
            )
        );
    }
    test_field_windowless_rendering_enabled();
    fn test_field_shared_texture_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_window_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).shared_texture_enabled) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_window_info_t),
                "::",
                stringify!(shared_texture_enabled)
            )
        );
    }
    test_field_shared_texture_enabled();
    fn test_field_external_begin_frame_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_window_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).external_begin_frame_enabled) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_window_info_t),
                "::",
                stringify!(external_begin_frame_enabled)
            )
        );
    }
    test_field_external_begin_frame_enabled();
    fn test_field_window() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_window_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).window) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_window_info_t),
                "::",
                stringify!(window)
            )
        );
    }
    test_field_window();
}
#[doc = ""]
#[doc = " Class representing window information."]
#[doc = ""]
pub type cef_window_info_t = _cef_window_info_t;
pub type cef_color_t = uint32;
impl cef_log_severity_t {
    pub const LOGSEVERITY_DEBUG: cef_log_severity_t = cef_log_severity_t::LOGSEVERITY_VERBOSE;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Log severity levels."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_log_severity_t {
    #[doc = ""]
    #[doc = " Default logging (currently INFO logging)."]
    #[doc = ""]
    LOGSEVERITY_DEFAULT = 0,
    #[doc = ""]
    #[doc = " Verbose logging."]
    #[doc = ""]
    LOGSEVERITY_VERBOSE = 1,
    #[doc = ""]
    #[doc = " INFO logging."]
    #[doc = ""]
    LOGSEVERITY_INFO = 2,
    #[doc = ""]
    #[doc = " WARNING logging."]
    #[doc = ""]
    LOGSEVERITY_WARNING = 3,
    #[doc = ""]
    #[doc = " ERROR logging."]
    #[doc = ""]
    LOGSEVERITY_ERROR = 4,
    #[doc = ""]
    #[doc = " FATAL logging."]
    #[doc = ""]
    LOGSEVERITY_FATAL = 5,
    #[doc = ""]
    #[doc = " Disable logging to file for all messages, and to stderr for messages with"]
    #[doc = " severity less than FATAL."]
    #[doc = ""]
    LOGSEVERITY_DISABLE = 99,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Represents the state of a setting."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_state_t {
    #[doc = ""]
    #[doc = " Use the default state for the setting."]
    #[doc = ""]
    STATE_DEFAULT = 0,
    #[doc = ""]
    #[doc = " Enable or allow the setting."]
    #[doc = ""]
    STATE_ENABLED = 1,
    #[doc = ""]
    #[doc = " Disable or disallow the setting."]
    #[doc = ""]
    STATE_DISABLED = 2,
}
#[doc = ""]
#[doc = " Initialization settings. Specify NULL or 0 to get the recommended default"]
#[doc = " values. Many of these and other settings can also configured using command-"]
#[doc = " line switches."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_settings_t {
    #[doc = ""]
    #[doc = " Size of this structure."]
    #[doc = ""]
    pub size: size_t,
    #[doc = ""]
    #[doc = " Set to true (1) to disable the sandbox for sub-processes. See"]
    #[doc = " cef_sandbox_win.h for requirements to enable the sandbox on Windows. Also"]
    #[doc = " configurable using the \"no-sandbox\" command-line switch."]
    #[doc = ""]
    pub no_sandbox: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The path to a separate executable that will be launched for sub-processes."]
    #[doc = " If this value is empty on Windows or Linux then the main process"]
    #[doc = " executable will be used. If this value is empty on macOS then a helper"]
    #[doc = " executable must exist at \"Contents/Frameworks/<app>"]
    #[doc = " Helper.app/Contents/MacOS/<app> Helper\" in the top-level app bundle. See"]
    #[doc = " the comments on CefExecuteProcess() for details. If this value is"]
    #[doc = " non-empty then it must be an absolute path. Also configurable using the"]
    #[doc = " \"browser-subprocess-path\" command-line switch."]
    #[doc = ""]
    pub browser_subprocess_path: cef_string_t,
    #[doc = ""]
    #[doc = " The path to the CEF framework directory on macOS. If this value is empty"]
    #[doc = " then the framework must exist at \"Contents/Frameworks/Chromium Embedded"]
    #[doc = " Framework.framework\" in the top-level app bundle. If this value is"]
    #[doc = " non-empty then it must be an absolute path. Also configurable using the"]
    #[doc = " \"framework-dir-path\" command-line switch."]
    #[doc = ""]
    pub framework_dir_path: cef_string_t,
    #[doc = ""]
    #[doc = " The path to the main bundle on macOS. If this value is empty then it"]
    #[doc = " defaults to the top-level app bundle. If this value is non-empty then it"]
    #[doc = " must be an absolute path. Also configurable using the \"main-bundle-path\""]
    #[doc = " command-line switch."]
    #[doc = ""]
    pub main_bundle_path: cef_string_t,
    #[doc = ""]
    #[doc = " Set to true (1) to enable use of the Chrome runtime in CEF. This feature"]
    #[doc = " is considered experimental and is not recommended for most users at this"]
    #[doc = " time. See issue #2969 for details."]
    #[doc = ""]
    pub chrome_runtime: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to have the browser process message loop run in a separate"]
    #[doc = " thread. If false (0) then the CefDoMessageLoopWork() function must be"]
    #[doc = " called from your application message loop. This option is only supported"]
    #[doc = " on Windows and Linux."]
    #[doc = ""]
    pub multi_threaded_message_loop: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to control browser process main (UI) thread message pump"]
    #[doc = " scheduling via the CefBrowserProcessHandler::OnScheduleMessagePumpWork()"]
    #[doc = " callback. This option is recommended for use in combination with the"]
    #[doc = " CefDoMessageLoopWork() function in cases where the CEF message loop must"]
    #[doc = " be integrated into an existing application message loop (see additional"]
    #[doc = " comments and warnings on CefDoMessageLoopWork). Enabling this option is"]
    #[doc = " not recommended for most users; leave this option disabled and use either"]
    #[doc = " the CefRunMessageLoop() function or multi_threaded_message_loop if"]
    #[doc = " possible."]
    #[doc = ""]
    pub external_message_pump: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to enable windowless (off-screen) rendering support. Do"]
    #[doc = " not enable this value if the application does not use windowless rendering"]
    #[doc = " as it may reduce rendering performance on some systems."]
    #[doc = ""]
    pub windowless_rendering_enabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to disable configuration of browser process features using"]
    #[doc = " standard CEF and Chromium command-line arguments. Configuration can still"]
    #[doc = " be specified using CEF data structures or via the"]
    #[doc = " CefApp::OnBeforeCommandLineProcessing() method."]
    #[doc = ""]
    pub command_line_args_disabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The location where data for the global browser cache will be stored on"]
    #[doc = " disk. If this value is non-empty then it must be an absolute path that is"]
    #[doc = " either equal to or a child directory of CefSettings.root_cache_path. If"]
    #[doc = " this value is empty then browsers will be created in \"incognito mode\""]
    #[doc = " where in-memory caches are used for storage and no data is persisted to"]
    #[doc = " disk. HTML5 databases such as localStorage will only persist across"]
    #[doc = " sessions if a cache path is specified. Can be overridden for individual"]
    #[doc = " CefRequestContext instances via the CefRequestContextSettings.cache_path"]
    #[doc = " value. When using the Chrome runtime the \"default\" profile will be used if"]
    #[doc = " |cache_path| and |root_cache_path| have the same value."]
    #[doc = ""]
    pub cache_path: cef_string_t,
    #[doc = ""]
    #[doc = " The root directory that all CefSettings.cache_path and"]
    #[doc = " CefRequestContextSettings.cache_path values must have in common. If this"]
    #[doc = " value is empty and CefSettings.cache_path is non-empty then it will"]
    #[doc = " default to the CefSettings.cache_path value. If this value is non-empty"]
    #[doc = " then it must be an absolute path. Failure to set this value correctly may"]
    #[doc = " result in the sandbox blocking read/write access to the cache_path"]
    #[doc = " directory."]
    #[doc = ""]
    pub root_cache_path: cef_string_t,
    #[doc = ""]
    #[doc = " The location where user data such as the Widevine CDM module and spell"]
    #[doc = " checking dictionary files will be stored on disk. If this value is empty"]
    #[doc = " then the default platform-specific user data directory will be used"]
    #[doc = " (\"~/.config/cef_user_data\" directory on Linux, \"~/Library/Application"]
    #[doc = " Support/CEF/User Data\" directory on MacOS, \"AppData\\Local\\CEF\\User Data\""]
    #[doc = " directory under the user profile directory on Windows). If this value is"]
    #[doc = " non-empty then it must be an absolute path. When using the Chrome runtime"]
    #[doc = " this value will be ignored in favor of the |root_cache_path| value."]
    #[doc = ""]
    pub user_data_path: cef_string_t,
    #[doc = ""]
    #[doc = " To persist session cookies (cookies without an expiry date or validity"]
    #[doc = " interval) by default when using the global cookie manager set this value"]
    #[doc = " to true (1). Session cookies are generally intended to be transient and"]
    #[doc = " most Web browsers do not persist them. A |cache_path| value must also be"]
    #[doc = " specified to enable this feature. Also configurable using the"]
    #[doc = " \"persist-session-cookies\" command-line switch. Can be overridden for"]
    #[doc = " individual CefRequestContext instances via the"]
    #[doc = " CefRequestContextSettings.persist_session_cookies value."]
    #[doc = ""]
    pub persist_session_cookies: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " To persist user preferences as a JSON file in the cache path directory set"]
    #[doc = " this value to true (1). A |cache_path| value must also be specified"]
    #[doc = " to enable this feature. Also configurable using the"]
    #[doc = " \"persist-user-preferences\" command-line switch. Can be overridden for"]
    #[doc = " individual CefRequestContext instances via the"]
    #[doc = " CefRequestContextSettings.persist_user_preferences value."]
    #[doc = ""]
    pub persist_user_preferences: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Value that will be returned as the User-Agent HTTP header. If empty the"]
    #[doc = " default User-Agent string will be used. Also configurable using the"]
    #[doc = " \"user-agent\" command-line switch."]
    #[doc = ""]
    pub user_agent: cef_string_t,
    #[doc = ""]
    #[doc = " Value that will be inserted as the product portion of the default"]
    #[doc = " User-Agent string. If empty the Chromium product version will be used. If"]
    #[doc = " |userAgent| is specified this value will be ignored. Also configurable"]
    #[doc = " using the \"user-agent-product\" command-line switch."]
    #[doc = ""]
    pub user_agent_product: cef_string_t,
    #[doc = ""]
    #[doc = " The locale string that will be passed to WebKit. If empty the default"]
    #[doc = " locale of \"en-US\" will be used. This value is ignored on Linux where"]
    #[doc = " locale is determined using environment variable parsing with the"]
    #[doc = " precedence order: LANGUAGE, LC_ALL, LC_MESSAGES and LANG. Also"]
    #[doc = " configurable using the \"lang\" command-line switch."]
    #[doc = ""]
    pub locale: cef_string_t,
    #[doc = ""]
    #[doc = " The directory and file name to use for the debug log. If empty a default"]
    #[doc = " log file name and location will be used. On Windows and Linux a"]
    #[doc = " \"debug.log\" file will be written in the main executable directory. On"]
    #[doc = " MacOS a \"~/Library/Logs/[app name]_debug.log\" file will be written where"]
    #[doc = " [app name] is the name of the main app executable. Also configurable using"]
    #[doc = " the \"log-file\" command-line switch."]
    #[doc = ""]
    pub log_file: cef_string_t,
    #[doc = ""]
    #[doc = " The log severity. Only messages of this severity level or higher will be"]
    #[doc = " logged. When set to DISABLE no messages will be written to the log file,"]
    #[doc = " but FATAL messages will still be output to stderr. Also configurable using"]
    #[doc = " the \"log-severity\" command-line switch with a value of \"verbose\", \"info\","]
    #[doc = " \"warning\", \"error\", \"fatal\" or \"disable\"."]
    #[doc = ""]
    pub log_severity: cef_log_severity_t,
    #[doc = ""]
    #[doc = " Custom flags that will be used when initializing the V8 JavaScript engine."]
    #[doc = " The consequences of using custom flags may not be well tested. Also"]
    #[doc = " configurable using the \"js-flags\" command-line switch."]
    #[doc = ""]
    pub javascript_flags: cef_string_t,
    #[doc = ""]
    #[doc = " The fully qualified path for the resources directory. If this value is"]
    #[doc = " empty the *.pak files must be located in the module directory on"]
    #[doc = " Windows/Linux or the app bundle Resources directory on MacOS. If this"]
    #[doc = " value is non-empty then it must be an absolute path. Also configurable"]
    #[doc = " using the \"resources-dir-path\" command-line switch."]
    #[doc = ""]
    pub resources_dir_path: cef_string_t,
    #[doc = ""]
    #[doc = " The fully qualified path for the locales directory. If this value is empty"]
    #[doc = " the locales directory must be located in the module directory. If this"]
    #[doc = " value is non-empty then it must be an absolute path. This value is ignored"]
    #[doc = " on MacOS where pack files are always loaded from the app bundle Resources"]
    #[doc = " directory. Also configurable using the \"locales-dir-path\" command-line"]
    #[doc = " switch."]
    #[doc = ""]
    pub locales_dir_path: cef_string_t,
    #[doc = ""]
    #[doc = " Set to true (1) to disable loading of pack files for resources and"]
    #[doc = " locales. A resource bundle handler must be provided for the browser and"]
    #[doc = " render processes via CefApp::GetResourceBundleHandler() if loading of pack"]
    #[doc = " files is disabled. Also configurable using the \"disable-pack-loading\""]
    #[doc = " command- line switch."]
    #[doc = ""]
    pub pack_loading_disabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to a value between 1024 and 65535 to enable remote debugging on the"]
    #[doc = " specified port. Also configurable using the \"remote-debugging-port\""]
    #[doc = " command-line switch. Remote debugging can be accessed by loading the"]
    #[doc = " chrome://inspect page in Google Chrome. Port numbers 9222 and 9229 are"]
    #[doc = " discoverable by default. Other port numbers may need to be configured via"]
    #[doc = " \"Discover network targets\" on the Devices tab."]
    #[doc = ""]
    pub remote_debugging_port: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The number of stack trace frames to capture for uncaught exceptions."]
    #[doc = " Specify a positive value to enable the"]
    #[doc = " CefRenderProcessHandler::OnUncaughtException() callback. Specify 0"]
    #[doc = " (default value) and OnUncaughtException() will not be called. Also"]
    #[doc = " configurable using the \"uncaught-exception-stack-size\" command-line"]
    #[doc = " switch."]
    #[doc = ""]
    pub uncaught_exception_stack_size: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Background color used for the browser before a document is loaded and when"]
    #[doc = " no document color is specified. The alpha component must be either fully"]
    #[doc = " opaque (0xFF) or fully transparent (0x00). If the alpha component is fully"]
    #[doc = " opaque then the RGB components will be used as the background color. If"]
    #[doc = " the alpha component is fully transparent for a windowed browser then the"]
    #[doc = " default value of opaque white be used. If the alpha component is fully"]
    #[doc = " transparent for a windowless (off-screen) browser then transparent"]
    #[doc = " painting will be enabled."]
    #[doc = ""]
    pub background_color: cef_color_t,
    #[doc = ""]
    #[doc = " Comma delimited ordered list of language codes without any whitespace that"]
    #[doc = " will be used in the \"Accept-Language\" HTTP header. May be overridden on a"]
    #[doc = " per-browser basis using the CefBrowserSettings.accept_language_list value."]
    #[doc = " If both values are empty then \"en-US,en\" will be used. Can be overridden"]
    #[doc = " for individual CefRequestContext instances via the"]
    #[doc = " CefRequestContextSettings.accept_language_list value."]
    #[doc = ""]
    pub accept_language_list: cef_string_t,
    #[doc = ""]
    #[doc = " Comma delimited list of schemes supported by the associated"]
    #[doc = " CefCookieManager. If |cookieable_schemes_exclude_defaults| is false (0)"]
    #[doc = " the default schemes (\"http\", \"https\", \"ws\" and \"wss\") will also be"]
    #[doc = " supported. Specifying a |cookieable_schemes_list| value and setting"]
    #[doc = " |cookieable_schemes_exclude_defaults| to true (1) will disable all loading"]
    #[doc = " and saving of cookies for this manager. Can be overridden"]
    #[doc = " for individual CefRequestContext instances via the"]
    #[doc = " CefRequestContextSettings.cookieable_schemes_list and"]
    #[doc = " CefRequestContextSettings.cookieable_schemes_exclude_defaults values."]
    #[doc = ""]
    pub cookieable_schemes_list: cef_string_t,
    pub cookieable_schemes_exclude_defaults: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_settings_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_settings_t>(),
        440usize,
        concat!("Size of: ", stringify!(_cef_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_settings_t))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_no_sandbox() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).no_sandbox) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(no_sandbox)
            )
        );
    }
    test_field_no_sandbox();
    fn test_field_browser_subprocess_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).browser_subprocess_path) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(browser_subprocess_path)
            )
        );
    }
    test_field_browser_subprocess_path();
    fn test_field_framework_dir_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).framework_dir_path) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(framework_dir_path)
            )
        );
    }
    test_field_framework_dir_path();
    fn test_field_main_bundle_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).main_bundle_path) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(main_bundle_path)
            )
        );
    }
    test_field_main_bundle_path();
    fn test_field_chrome_runtime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chrome_runtime) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(chrome_runtime)
            )
        );
    }
    test_field_chrome_runtime();
    fn test_field_multi_threaded_message_loop() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).multi_threaded_message_loop) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(multi_threaded_message_loop)
            )
        );
    }
    test_field_multi_threaded_message_loop();
    fn test_field_external_message_pump() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).external_message_pump) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(external_message_pump)
            )
        );
    }
    test_field_external_message_pump();
    fn test_field_windowless_rendering_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).windowless_rendering_enabled) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(windowless_rendering_enabled)
            )
        );
    }
    test_field_windowless_rendering_enabled();
    fn test_field_command_line_args_disabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).command_line_args_disabled) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(command_line_args_disabled)
            )
        );
    }
    test_field_command_line_args_disabled();
    fn test_field_cache_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache_path) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(cache_path)
            )
        );
    }
    test_field_cache_path();
    fn test_field_root_cache_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).root_cache_path) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(root_cache_path)
            )
        );
    }
    test_field_root_cache_path();
    fn test_field_user_data_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_data_path) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(user_data_path)
            )
        );
    }
    test_field_user_data_path();
    fn test_field_persist_session_cookies() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).persist_session_cookies) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(persist_session_cookies)
            )
        );
    }
    test_field_persist_session_cookies();
    fn test_field_persist_user_preferences() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).persist_user_preferences) as usize - ptr as usize
            },
            188usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(persist_user_preferences)
            )
        );
    }
    test_field_persist_user_preferences();
    fn test_field_user_agent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_agent) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(user_agent)
            )
        );
    }
    test_field_user_agent();
    fn test_field_user_agent_product() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).user_agent_product) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(user_agent_product)
            )
        );
    }
    test_field_user_agent_product();
    fn test_field_locale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).locale) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(locale)
            )
        );
    }
    test_field_locale();
    fn test_field_log_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log_file) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(log_file)
            )
        );
    }
    test_field_log_file();
    fn test_field_log_severity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).log_severity) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(log_severity)
            )
        );
    }
    test_field_log_severity();
    fn test_field_javascript_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).javascript_flags) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(javascript_flags)
            )
        );
    }
    test_field_javascript_flags();
    fn test_field_resources_dir_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resources_dir_path) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(resources_dir_path)
            )
        );
    }
    test_field_resources_dir_path();
    fn test_field_locales_dir_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).locales_dir_path) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(locales_dir_path)
            )
        );
    }
    test_field_locales_dir_path();
    fn test_field_pack_loading_disabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pack_loading_disabled) as usize - ptr as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(pack_loading_disabled)
            )
        );
    }
    test_field_pack_loading_disabled();
    fn test_field_remote_debugging_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remote_debugging_port) as usize - ptr as usize
            },
            372usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(remote_debugging_port)
            )
        );
    }
    test_field_remote_debugging_port();
    fn test_field_uncaught_exception_stack_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).uncaught_exception_stack_size) as usize - ptr as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(uncaught_exception_stack_size)
            )
        );
    }
    test_field_uncaught_exception_stack_size();
    fn test_field_background_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).background_color) as usize - ptr as usize
            },
            380usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(background_color)
            )
        );
    }
    test_field_background_color();
    fn test_field_accept_language_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accept_language_list) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(accept_language_list)
            )
        );
    }
    test_field_accept_language_list();
    fn test_field_cookieable_schemes_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cookieable_schemes_list) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(cookieable_schemes_list)
            )
        );
    }
    test_field_cookieable_schemes_list();
    fn test_field_cookieable_schemes_exclude_defaults() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cookieable_schemes_exclude_defaults) as usize
                    - ptr as usize
            },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_settings_t),
                "::",
                stringify!(cookieable_schemes_exclude_defaults)
            )
        );
    }
    test_field_cookieable_schemes_exclude_defaults();
}
#[doc = ""]
#[doc = " Initialization settings. Specify NULL or 0 to get the recommended default"]
#[doc = " values. Many of these and other settings can also configured using command-"]
#[doc = " line switches."]
#[doc = ""]
pub type cef_settings_t = _cef_settings_t;
#[doc = ""]
#[doc = " Request context initialization settings. Specify NULL or 0 to get the"]
#[doc = " recommended default values."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_context_settings_t {
    #[doc = ""]
    #[doc = " Size of this structure."]
    #[doc = ""]
    pub size: size_t,
    #[doc = ""]
    #[doc = " The location where cache data for this request context will be stored on"]
    #[doc = " disk. If this value is non-empty then it must be an absolute path that is"]
    #[doc = " either equal to or a child directory of CefSettings.root_cache_path. If"]
    #[doc = " this value is empty then browsers will be created in \"incognito mode\""]
    #[doc = " where in-memory caches are used for storage and no data is persisted to"]
    #[doc = " disk. HTML5 databases such as localStorage will only persist across"]
    #[doc = " sessions if a cache path is specified. To share the global browser cache"]
    #[doc = " and related configuration set this value to match the"]
    #[doc = " CefSettings.cache_path value."]
    #[doc = ""]
    pub cache_path: cef_string_t,
    #[doc = ""]
    #[doc = " To persist session cookies (cookies without an expiry date or validity"]
    #[doc = " interval) by default when using the global cookie manager set this value"]
    #[doc = " to true (1). Session cookies are generally intended to be transient and"]
    #[doc = " most Web browsers do not persist them. Can be set globally using the"]
    #[doc = " CefSettings.persist_session_cookies value. This value will be ignored if"]
    #[doc = " |cache_path| is empty or if it matches the CefSettings.cache_path value."]
    #[doc = ""]
    pub persist_session_cookies: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " To persist user preferences as a JSON file in the cache path directory set"]
    #[doc = " this value to true (1). Can be set globally using the"]
    #[doc = " CefSettings.persist_user_preferences value. This value will be ignored if"]
    #[doc = " |cache_path| is empty or if it matches the CefSettings.cache_path value."]
    #[doc = ""]
    pub persist_user_preferences: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Comma delimited ordered list of language codes without any whitespace that"]
    #[doc = " will be used in the \"Accept-Language\" HTTP header. Can be set globally"]
    #[doc = " using the CefSettings.accept_language_list value or overridden on a per-"]
    #[doc = " browser basis using the CefBrowserSettings.accept_language_list value. If"]
    #[doc = " all values are empty then \"en-US,en\" will be used. This value will be"]
    #[doc = " ignored if |cache_path| matches the CefSettings.cache_path value."]
    #[doc = ""]
    pub accept_language_list: cef_string_t,
    #[doc = ""]
    #[doc = " Comma delimited list of schemes supported by the associated"]
    #[doc = " CefCookieManager. If |cookieable_schemes_exclude_defaults| is false (0)"]
    #[doc = " the default schemes (\"http\", \"https\", \"ws\" and \"wss\") will also be"]
    #[doc = " supported. Specifying a |cookieable_schemes_list| value and setting"]
    #[doc = " |cookieable_schemes_exclude_defaults| to true (1) will disable all loading"]
    #[doc = " and saving of cookies for this manager. These values will be ignored if"]
    #[doc = " |cache_path| matches the CefSettings.cache_path value."]
    #[doc = ""]
    pub cookieable_schemes_list: cef_string_t,
    pub cookieable_schemes_exclude_defaults: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_request_context_settings_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_request_context_settings_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_request_context_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_request_context_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_request_context_settings_t))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_settings_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_cache_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache_path) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_settings_t),
                "::",
                stringify!(cache_path)
            )
        );
    }
    test_field_cache_path();
    fn test_field_persist_session_cookies() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).persist_session_cookies) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_settings_t),
                "::",
                stringify!(persist_session_cookies)
            )
        );
    }
    test_field_persist_session_cookies();
    fn test_field_persist_user_preferences() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).persist_user_preferences) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_settings_t),
                "::",
                stringify!(persist_user_preferences)
            )
        );
    }
    test_field_persist_user_preferences();
    fn test_field_accept_language_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accept_language_list) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_settings_t),
                "::",
                stringify!(accept_language_list)
            )
        );
    }
    test_field_accept_language_list();
    fn test_field_cookieable_schemes_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cookieable_schemes_list) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_settings_t),
                "::",
                stringify!(cookieable_schemes_list)
            )
        );
    }
    test_field_cookieable_schemes_list();
    fn test_field_cookieable_schemes_exclude_defaults() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cookieable_schemes_exclude_defaults) as usize
                    - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_settings_t),
                "::",
                stringify!(cookieable_schemes_exclude_defaults)
            )
        );
    }
    test_field_cookieable_schemes_exclude_defaults();
}
#[doc = ""]
#[doc = " Request context initialization settings. Specify NULL or 0 to get the"]
#[doc = " recommended default values."]
#[doc = ""]
pub type cef_request_context_settings_t = _cef_request_context_settings_t;
#[doc = ""]
#[doc = " Browser initialization settings. Specify NULL or 0 to get the recommended"]
#[doc = " default values. The consequences of using custom values may not be well"]
#[doc = " tested. Many of these and other settings can also configured using command-"]
#[doc = " line switches."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_browser_settings_t {
    #[doc = ""]
    #[doc = " Size of this structure."]
    #[doc = ""]
    pub size: size_t,
    #[doc = ""]
    #[doc = " The maximum rate in frames per second (fps) that CefRenderHandler::OnPaint"]
    #[doc = " will be called for a windowless browser. The actual fps may be lower if"]
    #[doc = " the browser cannot generate frames at the requested rate. The minimum"]
    #[doc = " value is 1 and the maximum value is 60 (default 30). This value can also"]
    #[doc = " be changed dynamically via CefBrowserHost::SetWindowlessFrameRate."]
    #[doc = ""]
    pub windowless_frame_rate: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Font settings."]
    #[doc = ""]
    pub standard_font_family: cef_string_t,
    pub fixed_font_family: cef_string_t,
    pub serif_font_family: cef_string_t,
    pub sans_serif_font_family: cef_string_t,
    pub cursive_font_family: cef_string_t,
    pub fantasy_font_family: cef_string_t,
    pub default_font_size: ::std::os::raw::c_int,
    pub default_fixed_font_size: ::std::os::raw::c_int,
    pub minimum_font_size: ::std::os::raw::c_int,
    pub minimum_logical_font_size: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Default encoding for Web content. If empty \"ISO-8859-1\" will be used. Also"]
    #[doc = " configurable using the \"default-encoding\" command-line switch."]
    #[doc = ""]
    pub default_encoding: cef_string_t,
    #[doc = ""]
    #[doc = " Controls the loading of fonts from remote sources. Also configurable using"]
    #[doc = " the \"disable-remote-fonts\" command-line switch."]
    #[doc = ""]
    pub remote_fonts: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether JavaScript can be executed. Also configurable using the"]
    #[doc = " \"disable-javascript\" command-line switch."]
    #[doc = ""]
    pub javascript: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether JavaScript can be used to close windows that were not"]
    #[doc = " opened via JavaScript. JavaScript can still be used to close windows that"]
    #[doc = " were opened via JavaScript or that have no back/forward history. Also"]
    #[doc = " configurable using the \"disable-javascript-close-windows\" command-line"]
    #[doc = " switch."]
    #[doc = ""]
    pub javascript_close_windows: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether JavaScript can access the clipboard. Also configurable"]
    #[doc = " using the \"disable-javascript-access-clipboard\" command-line switch."]
    #[doc = ""]
    pub javascript_access_clipboard: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether DOM pasting is supported in the editor via"]
    #[doc = " execCommand(\"paste\"). The |javascript_access_clipboard| setting must also"]
    #[doc = " be enabled. Also configurable using the \"disable-javascript-dom-paste\""]
    #[doc = " command-line switch."]
    #[doc = ""]
    pub javascript_dom_paste: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether image URLs will be loaded from the network. A cached"]
    #[doc = " image will still be rendered if requested. Also configurable using the"]
    #[doc = " \"disable-image-loading\" command-line switch."]
    #[doc = ""]
    pub image_loading: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether standalone images will be shrunk to fit the page. Also"]
    #[doc = " configurable using the \"image-shrink-standalone-to-fit\" command-line"]
    #[doc = " switch."]
    #[doc = ""]
    pub image_shrink_standalone_to_fit: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether text areas can be resized. Also configurable using the"]
    #[doc = " \"disable-text-area-resize\" command-line switch."]
    #[doc = ""]
    pub text_area_resize: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether the tab key can advance focus to links. Also configurable"]
    #[doc = " using the \"disable-tab-to-links\" command-line switch."]
    #[doc = ""]
    pub tab_to_links: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether local storage can be used. Also configurable using the"]
    #[doc = " \"disable-local-storage\" command-line switch."]
    #[doc = ""]
    pub local_storage: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether databases can be used. Also configurable using the"]
    #[doc = " \"disable-databases\" command-line switch."]
    #[doc = ""]
    pub databases: cef_state_t,
    #[doc = ""]
    #[doc = " Controls whether WebGL can be used. Note that WebGL requires hardware"]
    #[doc = " support and may not work on all systems even when enabled. Also"]
    #[doc = " configurable using the \"disable-webgl\" command-line switch."]
    #[doc = ""]
    pub webgl: cef_state_t,
    #[doc = ""]
    #[doc = " Background color used for the browser before a document is loaded and when"]
    #[doc = " no document color is specified. The alpha component must be either fully"]
    #[doc = " opaque (0xFF) or fully transparent (0x00). If the alpha component is fully"]
    #[doc = " opaque then the RGB components will be used as the background color. If"]
    #[doc = " the alpha component is fully transparent for a windowed browser then the"]
    #[doc = " CefSettings.background_color value will be used. If the alpha component is"]
    #[doc = " fully transparent for a windowless (off-screen) browser then transparent"]
    #[doc = " painting will be enabled."]
    #[doc = ""]
    pub background_color: cef_color_t,
    #[doc = ""]
    #[doc = " Comma delimited ordered list of language codes without any whitespace that"]
    #[doc = " will be used in the \"Accept-Language\" HTTP header. May be set globally"]
    #[doc = " using the CefSettings.accept_language_list value. If both values are"]
    #[doc = " empty then \"en-US,en\" will be used."]
    #[doc = ""]
    pub accept_language_list: cef_string_t,
    #[doc = ""]
    #[doc = " Controls whether the Chrome status bubble will be used. Only supported"]
    #[doc = " with the Chrome runtime. For details about the status bubble see"]
    #[doc = " https://www.chromium.org/user-experience/status-bubble/"]
    #[doc = ""]
    pub chrome_status_bubble: cef_state_t,
}
#[test]
fn bindgen_test_layout__cef_browser_settings_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_browser_settings_t>(),
        288usize,
        concat!("Size of: ", stringify!(_cef_browser_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_browser_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_browser_settings_t))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_windowless_frame_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).windowless_frame_rate) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(windowless_frame_rate)
            )
        );
    }
    test_field_windowless_frame_rate();
    fn test_field_standard_font_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).standard_font_family) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(standard_font_family)
            )
        );
    }
    test_field_standard_font_family();
    fn test_field_fixed_font_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fixed_font_family) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(fixed_font_family)
            )
        );
    }
    test_field_fixed_font_family();
    fn test_field_serif_font_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).serif_font_family) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(serif_font_family)
            )
        );
    }
    test_field_serif_font_family();
    fn test_field_sans_serif_font_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sans_serif_font_family) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(sans_serif_font_family)
            )
        );
    }
    test_field_sans_serif_font_family();
    fn test_field_cursive_font_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cursive_font_family) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(cursive_font_family)
            )
        );
    }
    test_field_cursive_font_family();
    fn test_field_fantasy_font_family() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fantasy_font_family) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(fantasy_font_family)
            )
        );
    }
    test_field_fantasy_font_family();
    fn test_field_default_font_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).default_font_size) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(default_font_size)
            )
        );
    }
    test_field_default_font_size();
    fn test_field_default_fixed_font_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).default_fixed_font_size) as usize - ptr as usize
            },
            164usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(default_fixed_font_size)
            )
        );
    }
    test_field_default_fixed_font_size();
    fn test_field_minimum_font_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minimum_font_size) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(minimum_font_size)
            )
        );
    }
    test_field_minimum_font_size();
    fn test_field_minimum_logical_font_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minimum_logical_font_size) as usize - ptr as usize
            },
            172usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(minimum_logical_font_size)
            )
        );
    }
    test_field_minimum_logical_font_size();
    fn test_field_default_encoding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).default_encoding) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(default_encoding)
            )
        );
    }
    test_field_default_encoding();
    fn test_field_remote_fonts() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remote_fonts) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(remote_fonts)
            )
        );
    }
    test_field_remote_fonts();
    fn test_field_javascript() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).javascript) as usize - ptr as usize
            },
            204usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(javascript)
            )
        );
    }
    test_field_javascript();
    fn test_field_javascript_close_windows() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).javascript_close_windows) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(javascript_close_windows)
            )
        );
    }
    test_field_javascript_close_windows();
    fn test_field_javascript_access_clipboard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).javascript_access_clipboard) as usize - ptr as usize
            },
            212usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(javascript_access_clipboard)
            )
        );
    }
    test_field_javascript_access_clipboard();
    fn test_field_javascript_dom_paste() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).javascript_dom_paste) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(javascript_dom_paste)
            )
        );
    }
    test_field_javascript_dom_paste();
    fn test_field_image_loading() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image_loading) as usize - ptr as usize
            },
            220usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(image_loading)
            )
        );
    }
    test_field_image_loading();
    fn test_field_image_shrink_standalone_to_fit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image_shrink_standalone_to_fit) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(image_shrink_standalone_to_fit)
            )
        );
    }
    test_field_image_shrink_standalone_to_fit();
    fn test_field_text_area_resize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).text_area_resize) as usize - ptr as usize
            },
            228usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(text_area_resize)
            )
        );
    }
    test_field_text_area_resize();
    fn test_field_tab_to_links() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tab_to_links) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(tab_to_links)
            )
        );
    }
    test_field_tab_to_links();
    fn test_field_local_storage() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).local_storage) as usize - ptr as usize
            },
            236usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(local_storage)
            )
        );
    }
    test_field_local_storage();
    fn test_field_databases() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).databases) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(databases)
            )
        );
    }
    test_field_databases();
    fn test_field_webgl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).webgl) as usize - ptr as usize
            },
            244usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(webgl)
            )
        );
    }
    test_field_webgl();
    fn test_field_background_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).background_color) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(background_color)
            )
        );
    }
    test_field_background_color();
    fn test_field_accept_language_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).accept_language_list) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(accept_language_list)
            )
        );
    }
    test_field_accept_language_list();
    fn test_field_chrome_status_bubble() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).chrome_status_bubble) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_settings_t),
                "::",
                stringify!(chrome_status_bubble)
            )
        );
    }
    test_field_chrome_status_bubble();
}
#[doc = ""]
#[doc = " Browser initialization settings. Specify NULL or 0 to get the recommended"]
#[doc = " default values. The consequences of using custom values may not be well"]
#[doc = " tested. Many of these and other settings can also configured using command-"]
#[doc = " line switches."]
#[doc = ""]
pub type cef_browser_settings_t = _cef_browser_settings_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Return value types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_return_value_t {
    #[doc = ""]
    #[doc = " Cancel immediately."]
    #[doc = ""]
    RV_CANCEL = 0,
    #[doc = ""]
    #[doc = " Continue immediately."]
    #[doc = ""]
    RV_CONTINUE = 1,
    #[doc = ""]
    #[doc = " Continue asynchronously (usually via a callback)."]
    #[doc = ""]
    RV_CONTINUE_ASYNC = 2,
}
#[doc = ""]
#[doc = " URL component parts."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_urlparts_t {
    #[doc = ""]
    #[doc = " The complete URL specification."]
    #[doc = ""]
    pub spec: cef_string_t,
    #[doc = ""]
    #[doc = " Scheme component not including the colon (e.g., \"http\")."]
    #[doc = ""]
    pub scheme: cef_string_t,
    #[doc = ""]
    #[doc = " User name component."]
    #[doc = ""]
    pub username: cef_string_t,
    #[doc = ""]
    #[doc = " Password component."]
    #[doc = ""]
    pub password: cef_string_t,
    #[doc = ""]
    #[doc = " Host component. This may be a hostname, an IPv4 address or an IPv6 literal"]
    #[doc = " surrounded by square brackets (e.g., \"[2001:db8::1]\")."]
    #[doc = ""]
    pub host: cef_string_t,
    #[doc = ""]
    #[doc = " Port number component."]
    #[doc = ""]
    pub port: cef_string_t,
    #[doc = ""]
    #[doc = " Origin contains just the scheme, host, and port from a URL. Equivalent to"]
    #[doc = " clearing any username and password, replacing the path with a slash, and"]
    #[doc = " clearing everything after that. This value will be empty for non-standard"]
    #[doc = " URLs."]
    #[doc = ""]
    pub origin: cef_string_t,
    #[doc = ""]
    #[doc = " Path component including the first slash following the host."]
    #[doc = ""]
    pub path: cef_string_t,
    #[doc = ""]
    #[doc = " Query string component (i.e., everything following the '?')."]
    #[doc = ""]
    pub query: cef_string_t,
    #[doc = ""]
    #[doc = " Fragment (hash) identifier component (i.e., the string following the '#')."]
    #[doc = ""]
    pub fragment: cef_string_t,
}
#[test]
fn bindgen_test_layout__cef_urlparts_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_urlparts_t>(),
        240usize,
        concat!("Size of: ", stringify!(_cef_urlparts_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_urlparts_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_urlparts_t))
    );
    fn test_field_spec() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_urlparts_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).spec) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_urlparts_t),
                "::",
                stringify!(spec)
            )
        );
    }
    test_field_spec();
    fn test_field_scheme() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_urlparts_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scheme) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_urlparts_t),
                "::",
                stringify!(scheme)
            )
        );
    }
    test_field_scheme();
    fn test_field_username() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_urlparts_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).username) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_urlparts_t),
                "::",
                stringify!(username)
            )
        );
    }
    test_field_username();
    fn test_field_password() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_urlparts_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).password) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_urlparts_t),
                "::",
                stringify!(password)
            )
        );
    }
    test_field_password();
    fn test_field_host() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_urlparts_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).host) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_urlparts_t),
                "::",
                stringify!(host)
            )
        );
    }
    test_field_host();
    fn test_field_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_urlparts_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_urlparts_t),
                "::",
                stringify!(port)
            )
        );
    }
    test_field_port();
    fn test_field_origin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_urlparts_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).origin) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_urlparts_t),
                "::",
                stringify!(origin)
            )
        );
    }
    test_field_origin();
    fn test_field_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_urlparts_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_urlparts_t),
                "::",
                stringify!(path)
            )
        );
    }
    test_field_path();
    fn test_field_query() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_urlparts_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).query) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_urlparts_t),
                "::",
                stringify!(query)
            )
        );
    }
    test_field_query();
    fn test_field_fragment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_urlparts_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fragment) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_urlparts_t),
                "::",
                stringify!(fragment)
            )
        );
    }
    test_field_fragment();
}
#[doc = ""]
#[doc = " URL component parts."]
#[doc = ""]
pub type cef_urlparts_t = _cef_urlparts_t;
#[repr(i32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Cookie priority values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_cookie_priority_t {
    CEF_COOKIE_PRIORITY_LOW = -1,
    CEF_COOKIE_PRIORITY_MEDIUM = 0,
    CEF_COOKIE_PRIORITY_HIGH = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Cookie same site values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_cookie_same_site_t {
    CEF_COOKIE_SAME_SITE_UNSPECIFIED = 0,
    CEF_COOKIE_SAME_SITE_NO_RESTRICTION = 1,
    CEF_COOKIE_SAME_SITE_LAX_MODE = 2,
    CEF_COOKIE_SAME_SITE_STRICT_MODE = 3,
}
#[doc = ""]
#[doc = " Cookie information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cookie_t {
    #[doc = ""]
    #[doc = " The cookie name."]
    #[doc = ""]
    pub name: cef_string_t,
    #[doc = ""]
    #[doc = " The cookie value."]
    #[doc = ""]
    pub value: cef_string_t,
    #[doc = ""]
    #[doc = " If |domain| is empty a host cookie will be created instead of a domain"]
    #[doc = " cookie. Domain cookies are stored with a leading \".\" and are visible to"]
    #[doc = " sub-domains whereas host cookies are not."]
    #[doc = ""]
    pub domain: cef_string_t,
    #[doc = ""]
    #[doc = " If |path| is non-empty only URLs at or below the path will get the cookie"]
    #[doc = " value."]
    #[doc = ""]
    pub path: cef_string_t,
    #[doc = ""]
    #[doc = " If |secure| is true the cookie will only be sent for HTTPS requests."]
    #[doc = ""]
    pub secure: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " If |httponly| is true the cookie will only be sent for HTTP requests."]
    #[doc = ""]
    pub httponly: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The cookie creation date. This is automatically populated by the system on"]
    #[doc = " cookie creation."]
    #[doc = ""]
    pub creation: cef_basetime_t,
    #[doc = ""]
    #[doc = " The cookie last access date. This is automatically populated by the system"]
    #[doc = " on access."]
    #[doc = ""]
    pub last_access: cef_basetime_t,
    #[doc = ""]
    #[doc = " The cookie expiration date is only valid if |has_expires| is true."]
    #[doc = ""]
    pub has_expires: ::std::os::raw::c_int,
    pub expires: cef_basetime_t,
    #[doc = ""]
    #[doc = " Same site."]
    #[doc = ""]
    pub same_site: cef_cookie_same_site_t,
    #[doc = ""]
    #[doc = " Priority."]
    #[doc = ""]
    pub priority: cef_cookie_priority_t,
}
#[test]
fn bindgen_test_layout__cef_cookie_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_cookie_t>(),
        144usize,
        concat!("Size of: ", stringify!(_cef_cookie_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_cookie_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_cookie_t))
    );
    fn test_field_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(name)
            )
        );
    }
    test_field_name();
    fn test_field_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(value)
            )
        );
    }
    test_field_value();
    fn test_field_domain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).domain) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(domain)
            )
        );
    }
    test_field_domain();
    fn test_field_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).path) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(path)
            )
        );
    }
    test_field_path();
    fn test_field_secure() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).secure) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(secure)
            )
        );
    }
    test_field_secure();
    fn test_field_httponly() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).httponly) as usize - ptr as usize
            },
            100usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(httponly)
            )
        );
    }
    test_field_httponly();
    fn test_field_creation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).creation) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(creation)
            )
        );
    }
    test_field_creation();
    fn test_field_last_access() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).last_access) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(last_access)
            )
        );
    }
    test_field_last_access();
    fn test_field_has_expires() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_expires) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(has_expires)
            )
        );
    }
    test_field_has_expires();
    fn test_field_expires() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).expires) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(expires)
            )
        );
    }
    test_field_expires();
    fn test_field_same_site() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).same_site) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(same_site)
            )
        );
    }
    test_field_same_site();
    fn test_field_priority() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).priority) as usize - ptr as usize
            },
            140usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_t),
                "::",
                stringify!(priority)
            )
        );
    }
    test_field_priority();
}
#[doc = ""]
#[doc = " Cookie information."]
#[doc = ""]
pub type cef_cookie_t = _cef_cookie_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Process termination status values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_termination_status_t {
    #[doc = ""]
    #[doc = " Non-zero exit status."]
    #[doc = ""]
    TS_ABNORMAL_TERMINATION = 0,
    #[doc = ""]
    #[doc = " SIGKILL or task manager kill."]
    #[doc = ""]
    TS_PROCESS_WAS_KILLED = 1,
    #[doc = ""]
    #[doc = " Segmentation fault."]
    #[doc = ""]
    TS_PROCESS_CRASHED = 2,
    #[doc = ""]
    #[doc = " Out of memory. Some platforms may use TS_PROCESS_CRASHED instead."]
    #[doc = ""]
    TS_PROCESS_OOM = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Path key values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_path_key_t {
    #[doc = ""]
    #[doc = " Current directory."]
    #[doc = ""]
    PK_DIR_CURRENT = 0,
    #[doc = ""]
    #[doc = " Directory containing PK_FILE_EXE."]
    #[doc = ""]
    PK_DIR_EXE = 1,
    #[doc = ""]
    #[doc = " Directory containing PK_FILE_MODULE."]
    #[doc = ""]
    PK_DIR_MODULE = 2,
    #[doc = ""]
    #[doc = " Temporary directory."]
    #[doc = ""]
    PK_DIR_TEMP = 3,
    #[doc = ""]
    #[doc = " Path and filename of the current executable."]
    #[doc = ""]
    PK_FILE_EXE = 4,
    #[doc = ""]
    #[doc = " Path and filename of the module containing the CEF code (usually the"]
    #[doc = " libcef module)."]
    #[doc = ""]
    PK_FILE_MODULE = 5,
    #[doc = ""]
    #[doc = " \"Local Settings\\Application Data\" directory under the user profile"]
    #[doc = " directory on Windows."]
    #[doc = ""]
    PK_LOCAL_APP_DATA = 6,
    #[doc = ""]
    #[doc = " \"Application Data\" directory under the user profile directory on Windows"]
    #[doc = " and \"~/Library/Application Support\" directory on MacOS."]
    #[doc = ""]
    PK_USER_DATA = 7,
    #[doc = ""]
    #[doc = " Directory containing application resources. Can be configured via"]
    #[doc = " CefSettings.resources_dir_path."]
    #[doc = ""]
    PK_DIR_RESOURCES = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Storage types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_storage_type_t {
    ST_LOCALSTORAGE = 0,
    ST_SESSIONSTORAGE = 1,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported error code values. For the complete list of error values see"]
#[doc = " \"include/base/internal/cef_net_error_list.h\"."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_errorcode_t {
    ERR_NONE = 0,
    ERR_IO_PENDING = -1,
    ERR_FAILED = -2,
    ERR_ABORTED = -3,
    ERR_INVALID_ARGUMENT = -4,
    ERR_INVALID_HANDLE = -5,
    ERR_FILE_NOT_FOUND = -6,
    ERR_TIMED_OUT = -7,
    ERR_FILE_TOO_BIG = -8,
    ERR_UNEXPECTED = -9,
    ERR_ACCESS_DENIED = -10,
    ERR_NOT_IMPLEMENTED = -11,
    ERR_INSUFFICIENT_RESOURCES = -12,
    ERR_OUT_OF_MEMORY = -13,
    ERR_UPLOAD_FILE_CHANGED = -14,
    ERR_SOCKET_NOT_CONNECTED = -15,
    ERR_FILE_EXISTS = -16,
    ERR_FILE_PATH_TOO_LONG = -17,
    ERR_FILE_NO_SPACE = -18,
    ERR_FILE_VIRUS_INFECTED = -19,
    ERR_BLOCKED_BY_CLIENT = -20,
    ERR_NETWORK_CHANGED = -21,
    ERR_BLOCKED_BY_ADMINISTRATOR = -22,
    ERR_SOCKET_IS_CONNECTED = -23,
    ERR_BLOCKED_ENROLLMENT_CHECK_PENDING = -24,
    ERR_UPLOAD_STREAM_REWIND_NOT_SUPPORTED = -25,
    ERR_CONTEXT_SHUT_DOWN = -26,
    ERR_BLOCKED_BY_RESPONSE = -27,
    ERR_CLEARTEXT_NOT_PERMITTED = -29,
    ERR_BLOCKED_BY_CSP = -30,
    ERR_H2_OR_QUIC_REQUIRED = -31,
    ERR_CONNECTION_CLOSED = -100,
    ERR_CONNECTION_RESET = -101,
    ERR_CONNECTION_REFUSED = -102,
    ERR_CONNECTION_ABORTED = -103,
    ERR_CONNECTION_FAILED = -104,
    ERR_NAME_NOT_RESOLVED = -105,
    ERR_INTERNET_DISCONNECTED = -106,
    ERR_SSL_PROTOCOL_ERROR = -107,
    ERR_ADDRESS_INVALID = -108,
    ERR_ADDRESS_UNREACHABLE = -109,
    ERR_SSL_CLIENT_AUTH_CERT_NEEDED = -110,
    ERR_TUNNEL_CONNECTION_FAILED = -111,
    ERR_NO_SSL_VERSIONS_ENABLED = -112,
    ERR_SSL_VERSION_OR_CIPHER_MISMATCH = -113,
    ERR_SSL_RENEGOTIATION_REQUESTED = -114,
    ERR_PROXY_AUTH_UNSUPPORTED = -115,
    ERR_BAD_SSL_CLIENT_AUTH_CERT = -117,
    ERR_CONNECTION_TIMED_OUT = -118,
    ERR_HOST_RESOLVER_QUEUE_TOO_LARGE = -119,
    ERR_SOCKS_CONNECTION_FAILED = -120,
    ERR_SOCKS_CONNECTION_HOST_UNREACHABLE = -121,
    ERR_ALPN_NEGOTIATION_FAILED = -122,
    ERR_SSL_NO_RENEGOTIATION = -123,
    ERR_WINSOCK_UNEXPECTED_WRITTEN_BYTES = -124,
    ERR_SSL_DECOMPRESSION_FAILURE_ALERT = -125,
    ERR_SSL_BAD_RECORD_MAC_ALERT = -126,
    ERR_PROXY_AUTH_REQUESTED = -127,
    ERR_PROXY_CONNECTION_FAILED = -130,
    ERR_MANDATORY_PROXY_CONFIGURATION_FAILED = -131,
    ERR_PRECONNECT_MAX_SOCKET_LIMIT = -133,
    ERR_SSL_CLIENT_AUTH_PRIVATE_KEY_ACCESS_DENIED = -134,
    ERR_SSL_CLIENT_AUTH_CERT_NO_PRIVATE_KEY = -135,
    ERR_PROXY_CERTIFICATE_INVALID = -136,
    ERR_NAME_RESOLUTION_FAILED = -137,
    ERR_NETWORK_ACCESS_DENIED = -138,
    ERR_TEMPORARILY_THROTTLED = -139,
    ERR_HTTPS_PROXY_TUNNEL_RESPONSE_REDIRECT = -140,
    ERR_SSL_CLIENT_AUTH_SIGNATURE_FAILED = -141,
    ERR_MSG_TOO_BIG = -142,
    ERR_WS_PROTOCOL_ERROR = -145,
    ERR_ADDRESS_IN_USE = -147,
    ERR_SSL_HANDSHAKE_NOT_COMPLETED = -148,
    ERR_SSL_BAD_PEER_PUBLIC_KEY = -149,
    ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN = -150,
    ERR_CLIENT_AUTH_CERT_TYPE_UNSUPPORTED = -151,
    ERR_SSL_DECRYPT_ERROR_ALERT = -153,
    ERR_WS_THROTTLE_QUEUE_TOO_LARGE = -154,
    ERR_SSL_SERVER_CERT_CHANGED = -156,
    ERR_SSL_UNRECOGNIZED_NAME_ALERT = -159,
    ERR_SOCKET_SET_RECEIVE_BUFFER_SIZE_ERROR = -160,
    ERR_SOCKET_SET_SEND_BUFFER_SIZE_ERROR = -161,
    ERR_SOCKET_RECEIVE_BUFFER_SIZE_UNCHANGEABLE = -162,
    ERR_SOCKET_SEND_BUFFER_SIZE_UNCHANGEABLE = -163,
    ERR_SSL_CLIENT_AUTH_CERT_BAD_FORMAT = -164,
    ERR_ICANN_NAME_COLLISION = -166,
    ERR_SSL_SERVER_CERT_BAD_FORMAT = -167,
    ERR_CT_STH_PARSING_FAILED = -168,
    ERR_CT_STH_INCOMPLETE = -169,
    ERR_UNABLE_TO_REUSE_CONNECTION_FOR_PROXY_AUTH = -170,
    ERR_CT_CONSISTENCY_PROOF_PARSING_FAILED = -171,
    ERR_SSL_OBSOLETE_CIPHER = -172,
    ERR_WS_UPGRADE = -173,
    ERR_READ_IF_READY_NOT_IMPLEMENTED = -174,
    ERR_NO_BUFFER_SPACE = -176,
    ERR_SSL_CLIENT_AUTH_NO_COMMON_ALGORITHMS = -177,
    ERR_EARLY_DATA_REJECTED = -178,
    ERR_WRONG_VERSION_ON_EARLY_DATA = -179,
    ERR_TLS13_DOWNGRADE_DETECTED = -180,
    ERR_SSL_KEY_USAGE_INCOMPATIBLE = -181,
    ERR_INVALID_ECH_CONFIG_LIST = -182,
    ERR_ECH_NOT_NEGOTIATED = -183,
    ERR_ECH_FALLBACK_CERTIFICATE_INVALID = -184,
    ERR_CERT_COMMON_NAME_INVALID = -200,
    ERR_CERT_DATE_INVALID = -201,
    ERR_CERT_AUTHORITY_INVALID = -202,
    ERR_CERT_CONTAINS_ERRORS = -203,
    ERR_CERT_NO_REVOCATION_MECHANISM = -204,
    ERR_CERT_UNABLE_TO_CHECK_REVOCATION = -205,
    ERR_CERT_REVOKED = -206,
    ERR_CERT_INVALID = -207,
    ERR_CERT_WEAK_SIGNATURE_ALGORITHM = -208,
    ERR_CERT_NON_UNIQUE_NAME = -210,
    ERR_CERT_WEAK_KEY = -211,
    ERR_CERT_NAME_CONSTRAINT_VIOLATION = -212,
    ERR_CERT_VALIDITY_TOO_LONG = -213,
    ERR_CERTIFICATE_TRANSPARENCY_REQUIRED = -214,
    ERR_CERT_SYMANTEC_LEGACY = -215,
    ERR_CERT_KNOWN_INTERCEPTION_BLOCKED = -217,
    ERR_CERT_END = -219,
    ERR_INVALID_URL = -300,
    ERR_DISALLOWED_URL_SCHEME = -301,
    ERR_UNKNOWN_URL_SCHEME = -302,
    ERR_INVALID_REDIRECT = -303,
    ERR_TOO_MANY_REDIRECTS = -310,
    ERR_UNSAFE_REDIRECT = -311,
    ERR_UNSAFE_PORT = -312,
    ERR_INVALID_RESPONSE = -320,
    ERR_INVALID_CHUNKED_ENCODING = -321,
    ERR_METHOD_NOT_SUPPORTED = -322,
    ERR_UNEXPECTED_PROXY_AUTH = -323,
    ERR_EMPTY_RESPONSE = -324,
    ERR_RESPONSE_HEADERS_TOO_BIG = -325,
    ERR_PAC_SCRIPT_FAILED = -327,
    ERR_REQUEST_RANGE_NOT_SATISFIABLE = -328,
    ERR_MALFORMED_IDENTITY = -329,
    ERR_CONTENT_DECODING_FAILED = -330,
    ERR_NETWORK_IO_SUSPENDED = -331,
    ERR_SYN_REPLY_NOT_RECEIVED = -332,
    ERR_ENCODING_CONVERSION_FAILED = -333,
    ERR_UNRECOGNIZED_FTP_DIRECTORY_LISTING_FORMAT = -334,
    ERR_NO_SUPPORTED_PROXIES = -336,
    ERR_HTTP2_PROTOCOL_ERROR = -337,
    ERR_INVALID_AUTH_CREDENTIALS = -338,
    ERR_UNSUPPORTED_AUTH_SCHEME = -339,
    ERR_ENCODING_DETECTION_FAILED = -340,
    ERR_MISSING_AUTH_CREDENTIALS = -341,
    ERR_UNEXPECTED_SECURITY_LIBRARY_STATUS = -342,
    ERR_MISCONFIGURED_AUTH_ENVIRONMENT = -343,
    ERR_UNDOCUMENTED_SECURITY_LIBRARY_STATUS = -344,
    ERR_RESPONSE_BODY_TOO_BIG_TO_DRAIN = -345,
    ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_LENGTH = -346,
    ERR_INCOMPLETE_HTTP2_HEADERS = -347,
    ERR_PAC_NOT_IN_DHCP = -348,
    ERR_RESPONSE_HEADERS_MULTIPLE_CONTENT_DISPOSITION = -349,
    ERR_RESPONSE_HEADERS_MULTIPLE_LOCATION = -350,
    ERR_HTTP2_SERVER_REFUSED_STREAM = -351,
    ERR_HTTP2_PING_FAILED = -352,
    ERR_CONTENT_LENGTH_MISMATCH = -354,
    ERR_INCOMPLETE_CHUNKED_ENCODING = -355,
    ERR_QUIC_PROTOCOL_ERROR = -356,
    ERR_RESPONSE_HEADERS_TRUNCATED = -357,
    ERR_QUIC_HANDSHAKE_FAILED = -358,
    ERR_HTTP2_INADEQUATE_TRANSPORT_SECURITY = -360,
    ERR_HTTP2_FLOW_CONTROL_ERROR = -361,
    ERR_HTTP2_FRAME_SIZE_ERROR = -362,
    ERR_HTTP2_COMPRESSION_ERROR = -363,
    ERR_PROXY_AUTH_REQUESTED_WITH_NO_CONNECTION = -364,
    ERR_HTTP_1_1_REQUIRED = -365,
    ERR_PROXY_HTTP_1_1_REQUIRED = -366,
    ERR_PAC_SCRIPT_TERMINATED = -367,
    ERR_INVALID_HTTP_RESPONSE = -370,
    ERR_CONTENT_DECODING_INIT_FAILED = -371,
    ERR_HTTP2_RST_STREAM_NO_ERROR_RECEIVED = -372,
    ERR_HTTP2_PUSHED_STREAM_NOT_AVAILABLE = -373,
    ERR_HTTP2_CLAIMED_PUSHED_STREAM_RESET_BY_SERVER = -374,
    ERR_TOO_MANY_RETRIES = -375,
    ERR_HTTP2_STREAM_CLOSED = -376,
    ERR_HTTP2_CLIENT_REFUSED_STREAM = -377,
    ERR_HTTP2_PUSHED_RESPONSE_DOES_NOT_MATCH = -378,
    ERR_HTTP_RESPONSE_CODE_FAILURE = -379,
    ERR_QUIC_CERT_ROOT_NOT_KNOWN = -380,
    ERR_QUIC_GOAWAY_REQUEST_CAN_BE_RETRIED = -381,
    ERR_TOO_MANY_ACCEPT_CH_RESTARTS = -382,
    ERR_INCONSISTENT_IP_ADDRESS_SPACE = -383,
    ERR_CACHE_MISS = -400,
    ERR_CACHE_READ_FAILURE = -401,
    ERR_CACHE_WRITE_FAILURE = -402,
    ERR_CACHE_OPERATION_NOT_SUPPORTED = -403,
    ERR_CACHE_OPEN_FAILURE = -404,
    ERR_CACHE_CREATE_FAILURE = -405,
    ERR_CACHE_RACE = -406,
    ERR_CACHE_CHECKSUM_READ_FAILURE = -407,
    ERR_CACHE_CHECKSUM_MISMATCH = -408,
    ERR_CACHE_LOCK_TIMEOUT = -409,
    ERR_CACHE_AUTH_FAILURE_AFTER_READ = -410,
    ERR_CACHE_ENTRY_NOT_SUITABLE = -411,
    ERR_CACHE_DOOM_FAILURE = -412,
    ERR_CACHE_OPEN_OR_CREATE_FAILURE = -413,
    ERR_INSECURE_RESPONSE = -501,
    ERR_NO_PRIVATE_KEY_FOR_CERT = -502,
    ERR_ADD_USER_CERT_FAILED = -503,
    ERR_INVALID_SIGNED_EXCHANGE = -504,
    ERR_INVALID_WEB_BUNDLE = -505,
    ERR_TRUST_TOKEN_OPERATION_FAILED = -506,
    ERR_TRUST_TOKEN_OPERATION_SUCCESS_WITHOUT_SENDING_REQUEST = -507,
    ERR_FTP_FAILED = -601,
    ERR_FTP_SERVICE_UNAVAILABLE = -602,
    ERR_FTP_TRANSFER_ABORTED = -603,
    ERR_FTP_FILE_BUSY = -604,
    ERR_FTP_SYNTAX_ERROR = -605,
    ERR_FTP_COMMAND_NOT_SUPPORTED = -606,
    ERR_FTP_BAD_COMMAND_SEQUENCE = -607,
    ERR_PKCS12_IMPORT_BAD_PASSWORD = -701,
    ERR_PKCS12_IMPORT_FAILED = -702,
    ERR_IMPORT_CA_CERT_NOT_CA = -703,
    ERR_IMPORT_CERT_ALREADY_EXISTS = -704,
    ERR_IMPORT_CA_CERT_FAILED = -705,
    ERR_IMPORT_SERVER_CERT_FAILED = -706,
    ERR_PKCS12_IMPORT_INVALID_MAC = -707,
    ERR_PKCS12_IMPORT_INVALID_FILE = -708,
    ERR_PKCS12_IMPORT_UNSUPPORTED = -709,
    ERR_KEY_GENERATION_FAILED = -710,
    ERR_PRIVATE_KEY_EXPORT_FAILED = -712,
    ERR_SELF_SIGNED_CERT_GENERATION_FAILED = -713,
    ERR_CERT_DATABASE_CHANGED = -714,
    ERR_DNS_MALFORMED_RESPONSE = -800,
    ERR_DNS_SERVER_REQUIRES_TCP = -801,
    ERR_DNS_SERVER_FAILED = -802,
    ERR_DNS_TIMED_OUT = -803,
    ERR_DNS_CACHE_MISS = -804,
    ERR_DNS_SEARCH_EMPTY = -805,
    ERR_DNS_SORT_ERROR = -806,
    ERR_DNS_SECURE_RESOLVER_HOSTNAME_RESOLUTION_FAILED = -808,
    ERR_DNS_NAME_HTTPS_ONLY = -809,
    ERR_DNS_REQUEST_CANCELLED = -810,
    ERR_DNS_NO_MACHING_SUPPORTED_ALPN = -811,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported certificate status code values. See net\\cert\\cert_status_flags.h"]
#[doc = " for more information. CERT_STATUS_NONE is new in CEF because we use an"]
#[doc = " enum while cert_status_flags.h uses a typedef and static const variables."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_cert_status_t {
    CERT_STATUS_NONE = 0,
    CERT_STATUS_COMMON_NAME_INVALID = 1,
    CERT_STATUS_DATE_INVALID = 2,
    CERT_STATUS_AUTHORITY_INVALID = 4,
    CERT_STATUS_NO_REVOCATION_MECHANISM = 16,
    CERT_STATUS_UNABLE_TO_CHECK_REVOCATION = 32,
    CERT_STATUS_REVOKED = 64,
    CERT_STATUS_INVALID = 128,
    CERT_STATUS_WEAK_SIGNATURE_ALGORITHM = 256,
    CERT_STATUS_NON_UNIQUE_NAME = 1024,
    CERT_STATUS_WEAK_KEY = 2048,
    CERT_STATUS_PINNED_KEY_MISSING = 8192,
    CERT_STATUS_NAME_CONSTRAINT_VIOLATION = 16384,
    CERT_STATUS_VALIDITY_TOO_LONG = 32768,
    CERT_STATUS_IS_EV = 65536,
    CERT_STATUS_REV_CHECKING_ENABLED = 131072,
    CERT_STATUS_SHA1_SIGNATURE_PRESENT = 524288,
    CERT_STATUS_CT_COMPLIANCE_FAILED = 1048576,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " The manner in which a link click should be opened. These constants match"]
#[doc = " their equivalents in Chromium's window_open_disposition.h and should not be"]
#[doc = " renumbered."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_window_open_disposition_t {
    WOD_UNKNOWN = 0,
    #[doc = ""]
    #[doc = " Current tab. This is the default in most cases."]
    #[doc = ""]
    WOD_CURRENT_TAB = 1,
    #[doc = ""]
    #[doc = " Indicates that only one tab with the url should exist in the same window."]
    #[doc = ""]
    WOD_SINGLETON_TAB = 2,
    #[doc = ""]
    #[doc = " Shift key + Middle mouse button or meta/ctrl key while clicking."]
    #[doc = ""]
    WOD_NEW_FOREGROUND_TAB = 3,
    #[doc = ""]
    #[doc = " Middle mouse button or meta/ctrl key while clicking."]
    #[doc = ""]
    WOD_NEW_BACKGROUND_TAB = 4,
    #[doc = ""]
    #[doc = " New popup window."]
    #[doc = ""]
    WOD_NEW_POPUP = 5,
    #[doc = ""]
    #[doc = " Shift key while clicking."]
    #[doc = ""]
    WOD_NEW_WINDOW = 6,
    #[doc = ""]
    #[doc = " Alt key while clicking."]
    #[doc = ""]
    WOD_SAVE_TO_DISK = 7,
    #[doc = ""]
    #[doc = " New off-the-record (incognito) window."]
    #[doc = ""]
    WOD_OFF_THE_RECORD = 8,
    #[doc = ""]
    #[doc = " Special case error condition from the renderer."]
    #[doc = ""]
    WOD_IGNORE_ACTION = 9,
    #[doc = ""]
    #[doc = " Activates an existing tab containing the url, rather than navigating."]
    #[doc = " This is similar to SINGLETON_TAB, but searches across all windows from"]
    #[doc = " the current profile and anonymity (instead of just the current one);"]
    #[doc = " closes the current tab on switching if the current tab was the NTP with"]
    #[doc = " no session history; and behaves like CURRENT_TAB instead of"]
    #[doc = " NEW_FOREGROUND_TAB when no existing tab is found."]
    #[doc = ""]
    WOD_SWITCH_TO_TAB = 10,
    #[doc = ""]
    #[doc = " Creates a new document picture-in-picture window showing a child WebView."]
    #[doc = ""]
    WOD_NEW_PICTURE_IN_PICTURE = 11,
}
impl cef_drag_operations_mask_t {
    pub const DRAG_OPERATION_NONE: cef_drag_operations_mask_t = cef_drag_operations_mask_t(0);
}
impl cef_drag_operations_mask_t {
    pub const DRAG_OPERATION_COPY: cef_drag_operations_mask_t = cef_drag_operations_mask_t(1);
}
impl cef_drag_operations_mask_t {
    pub const DRAG_OPERATION_LINK: cef_drag_operations_mask_t = cef_drag_operations_mask_t(2);
}
impl cef_drag_operations_mask_t {
    pub const DRAG_OPERATION_GENERIC: cef_drag_operations_mask_t = cef_drag_operations_mask_t(4);
}
impl cef_drag_operations_mask_t {
    pub const DRAG_OPERATION_PRIVATE: cef_drag_operations_mask_t = cef_drag_operations_mask_t(8);
}
impl cef_drag_operations_mask_t {
    pub const DRAG_OPERATION_MOVE: cef_drag_operations_mask_t = cef_drag_operations_mask_t(16);
}
impl cef_drag_operations_mask_t {
    pub const DRAG_OPERATION_DELETE: cef_drag_operations_mask_t = cef_drag_operations_mask_t(32);
}
impl cef_drag_operations_mask_t {
    pub const DRAG_OPERATION_EVERY: cef_drag_operations_mask_t =
        cef_drag_operations_mask_t(4294967295);
}
impl ::std::ops::BitOr<cef_drag_operations_mask_t> for cef_drag_operations_mask_t {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        cef_drag_operations_mask_t(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for cef_drag_operations_mask_t {
    #[inline]
    fn bitor_assign(&mut self, rhs: cef_drag_operations_mask_t) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<cef_drag_operations_mask_t> for cef_drag_operations_mask_t {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        cef_drag_operations_mask_t(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for cef_drag_operations_mask_t {
    #[inline]
    fn bitand_assign(&mut self, rhs: cef_drag_operations_mask_t) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[doc = ""]
#[doc = " \"Verb\" of a drag-and-drop operation as negotiated between the source and"]
#[doc = " destination. These constants match their equivalents in WebCore's"]
#[doc = " DragActions.h and should not be renumbered."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct cef_drag_operations_mask_t(pub ::std::os::raw::c_uint);
impl cef_text_input_mode_t {
    pub const CEF_TEXT_INPUT_MODE_MAX: cef_text_input_mode_t =
        cef_text_input_mode_t::CEF_TEXT_INPUT_MODE_SEARCH;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Input mode of a virtual keyboard. These constants match their equivalents"]
#[doc = " in Chromium's text_input_mode.h and should not be renumbered."]
#[doc = " See https://html.spec.whatwg.org/#input-modalities:-the-inputmode-attribute"]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_text_input_mode_t {
    CEF_TEXT_INPUT_MODE_DEFAULT = 0,
    CEF_TEXT_INPUT_MODE_NONE = 1,
    CEF_TEXT_INPUT_MODE_TEXT = 2,
    CEF_TEXT_INPUT_MODE_TEL = 3,
    CEF_TEXT_INPUT_MODE_URL = 4,
    CEF_TEXT_INPUT_MODE_EMAIL = 5,
    CEF_TEXT_INPUT_MODE_NUMERIC = 6,
    CEF_TEXT_INPUT_MODE_DECIMAL = 7,
    CEF_TEXT_INPUT_MODE_SEARCH = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " V8 access control values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_v8_accesscontrol_t {
    V8_ACCESS_CONTROL_DEFAULT = 0,
    V8_ACCESS_CONTROL_ALL_CAN_READ = 1,
    V8_ACCESS_CONTROL_ALL_CAN_WRITE = 2,
    V8_ACCESS_CONTROL_PROHIBITS_OVERWRITING = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " V8 property attribute values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_v8_propertyattribute_t {
    #[doc = ""]
    #[doc = " Writeable, Enumerable, Configurable"]
    #[doc = ""]
    V8_PROPERTY_ATTRIBUTE_NONE = 0,
    #[doc = ""]
    #[doc = " Not writeable"]
    #[doc = ""]
    V8_PROPERTY_ATTRIBUTE_READONLY = 1,
    #[doc = ""]
    #[doc = " Not enumerable"]
    #[doc = ""]
    V8_PROPERTY_ATTRIBUTE_DONTENUM = 2,
    #[doc = ""]
    #[doc = " Not configurable"]
    #[doc = ""]
    V8_PROPERTY_ATTRIBUTE_DONTDELETE = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Post data elements may represent either bytes or files."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_postdataelement_type_t {
    PDE_TYPE_EMPTY = 0,
    PDE_TYPE_BYTES = 1,
    PDE_TYPE_FILE = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Resource type for a request. These constants match their equivalents in"]
#[doc = " Chromium's ResourceType and should not be renumbered."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_resource_type_t {
    #[doc = ""]
    #[doc = " Top level page."]
    #[doc = ""]
    RT_MAIN_FRAME = 0,
    #[doc = ""]
    #[doc = " Frame or iframe."]
    #[doc = ""]
    RT_SUB_FRAME = 1,
    #[doc = ""]
    #[doc = " CSS stylesheet."]
    #[doc = ""]
    RT_STYLESHEET = 2,
    #[doc = ""]
    #[doc = " External script."]
    #[doc = ""]
    RT_SCRIPT = 3,
    #[doc = ""]
    #[doc = " Image (jpg/gif/png/etc)."]
    #[doc = ""]
    RT_IMAGE = 4,
    #[doc = ""]
    #[doc = " Font."]
    #[doc = ""]
    RT_FONT_RESOURCE = 5,
    #[doc = ""]
    #[doc = " Some other subresource. This is the default type if the actual type is"]
    #[doc = " unknown."]
    #[doc = ""]
    RT_SUB_RESOURCE = 6,
    #[doc = ""]
    #[doc = " Object (or embed) tag for a plugin, or a resource that a plugin requested."]
    #[doc = ""]
    RT_OBJECT = 7,
    #[doc = ""]
    #[doc = " Media resource."]
    #[doc = ""]
    RT_MEDIA = 8,
    #[doc = ""]
    #[doc = " Main resource of a dedicated worker."]
    #[doc = ""]
    RT_WORKER = 9,
    #[doc = ""]
    #[doc = " Main resource of a shared worker."]
    #[doc = ""]
    RT_SHARED_WORKER = 10,
    #[doc = ""]
    #[doc = " Explicitly requested prefetch."]
    #[doc = ""]
    RT_PREFETCH = 11,
    #[doc = ""]
    #[doc = " Favicon."]
    #[doc = ""]
    RT_FAVICON = 12,
    #[doc = ""]
    #[doc = " XMLHttpRequest."]
    #[doc = ""]
    RT_XHR = 13,
    #[doc = ""]
    #[doc = " A request for a \"<ping>\"."]
    #[doc = ""]
    RT_PING = 14,
    #[doc = ""]
    #[doc = " Main resource of a service worker."]
    #[doc = ""]
    RT_SERVICE_WORKER = 15,
    #[doc = ""]
    #[doc = " A report of Content Security Policy violations."]
    #[doc = ""]
    RT_CSP_REPORT = 16,
    #[doc = ""]
    #[doc = " A resource that a plugin requested."]
    #[doc = ""]
    RT_PLUGIN_RESOURCE = 17,
    #[doc = ""]
    #[doc = " A main-frame service worker navigation preload request."]
    #[doc = ""]
    RT_NAVIGATION_PRELOAD_MAIN_FRAME = 19,
    #[doc = ""]
    #[doc = " A sub-frame service worker navigation preload request."]
    #[doc = ""]
    RT_NAVIGATION_PRELOAD_SUB_FRAME = 20,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Transition type for a request. Made up of one source value and 0 or more"]
#[doc = " qualifiers."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_transition_type_t {
    #[doc = ""]
    #[doc = " Source is a link click or the JavaScript window.open function. This is"]
    #[doc = " also the default value for requests like sub-resource loads that are not"]
    #[doc = " navigations."]
    #[doc = ""]
    TT_LINK = 0,
    #[doc = ""]
    #[doc = " Source is some other \"explicit\" navigation. This is the default value for"]
    #[doc = " navigations where the actual type is unknown. See also"]
    #[doc = " TT_DIRECT_LOAD_FLAG."]
    #[doc = ""]
    TT_EXPLICIT = 1,
    #[doc = ""]
    #[doc = " User got to this page through a suggestion in the UI (for example, via the"]
    #[doc = " destinations page). Chrome runtime only."]
    #[doc = ""]
    TT_AUTO_BOOKMARK = 2,
    #[doc = ""]
    #[doc = " Source is a subframe navigation. This is any content that is automatically"]
    #[doc = " loaded in a non-toplevel frame. For example, if a page consists of several"]
    #[doc = " frames containing ads, those ad URLs will have this transition type."]
    #[doc = " The user may not even realize the content in these pages is a separate"]
    #[doc = " frame, so may not care about the URL."]
    #[doc = ""]
    TT_AUTO_SUBFRAME = 3,
    #[doc = ""]
    #[doc = " Source is a subframe navigation explicitly requested by the user that will"]
    #[doc = " generate new navigation entries in the back/forward list. These are"]
    #[doc = " probably more important than frames that were automatically loaded in"]
    #[doc = " the background because the user probably cares about the fact that this"]
    #[doc = " link was loaded."]
    #[doc = ""]
    TT_MANUAL_SUBFRAME = 4,
    #[doc = ""]
    #[doc = " User got to this page by typing in the URL bar and selecting an entry"]
    #[doc = " that did not look like a URL.  For example, a match might have the URL"]
    #[doc = " of a Google search result page, but appear like \"Search Google for ...\"."]
    #[doc = " These are not quite the same as EXPLICIT navigations because the user"]
    #[doc = " didn't type or see the destination URL. Chrome runtime only."]
    #[doc = " See also TT_KEYWORD."]
    #[doc = ""]
    TT_GENERATED = 5,
    #[doc = ""]
    #[doc = " This is a toplevel navigation. This is any content that is automatically"]
    #[doc = " loaded in a toplevel frame.  For example, opening a tab to show the ASH"]
    #[doc = " screen saver, opening the devtools window, opening the NTP after the safe"]
    #[doc = " browsing warning, opening web-based dialog boxes are examples of"]
    #[doc = " AUTO_TOPLEVEL navigations. Chrome runtime only."]
    #[doc = ""]
    TT_AUTO_TOPLEVEL = 6,
    #[doc = ""]
    #[doc = " Source is a form submission by the user. NOTE: In some situations"]
    #[doc = " submitting a form does not result in this transition type. This can happen"]
    #[doc = " if the form uses a script to submit the contents."]
    #[doc = ""]
    TT_FORM_SUBMIT = 7,
    #[doc = ""]
    #[doc = " Source is a \"reload\" of the page via the Reload function or by re-visiting"]
    #[doc = " the same URL. NOTE: This is distinct from the concept of whether a"]
    #[doc = " particular load uses \"reload semantics\" (i.e. bypasses cached data)."]
    #[doc = ""]
    TT_RELOAD = 8,
    #[doc = ""]
    #[doc = " The url was generated from a replaceable keyword other than the default"]
    #[doc = " search provider. If the user types a keyword (which also applies to"]
    #[doc = " tab-to-search) in the omnibox this qualifier is applied to the transition"]
    #[doc = " type of the generated url. TemplateURLModel then may generate an"]
    #[doc = " additional visit with a transition type of TT_KEYWORD_GENERATED against"]
    #[doc = " the url 'http://' + keyword. For example, if you do a tab-to-search"]
    #[doc = " against wikipedia the generated url has a transition qualifer of"]
    #[doc = " TT_KEYWORD, and TemplateURLModel generates a visit for 'wikipedia.org'"]
    #[doc = " with a transition type of TT_KEYWORD_GENERATED. Chrome runtime only."]
    #[doc = ""]
    TT_KEYWORD = 9,
    #[doc = ""]
    #[doc = " Corresponds to a visit generated for a keyword. See description of"]
    #[doc = " TT_KEYWORD for more details. Chrome runtime only."]
    #[doc = ""]
    TT_KEYWORD_GENERATED = 10,
    #[doc = ""]
    #[doc = " General mask defining the bits used for the source values."]
    #[doc = ""]
    TT_SOURCE_MASK = 255,
    #[doc = ""]
    #[doc = " Attempted to visit a URL but was blocked."]
    #[doc = ""]
    TT_BLOCKED_FLAG = 8388608,
    #[doc = ""]
    #[doc = " Used the Forward or Back function to navigate among browsing history."]
    #[doc = " Will be ORed to the transition type for the original load."]
    #[doc = ""]
    TT_FORWARD_BACK_FLAG = 16777216,
    #[doc = ""]
    #[doc = " Loaded a URL directly via CreateBrowser, LoadURL or LoadRequest."]
    #[doc = ""]
    TT_DIRECT_LOAD_FLAG = 33554432,
    #[doc = ""]
    #[doc = " User is navigating to the home page. Chrome runtime only."]
    #[doc = ""]
    TT_HOME_PAGE_FLAG = 67108864,
    #[doc = ""]
    #[doc = " The transition originated from an external application; the exact"]
    #[doc = " definition of this is embedder dependent. Chrome runtime and"]
    #[doc = " extension system only."]
    #[doc = ""]
    TT_FROM_API_FLAG = 134217728,
    #[doc = ""]
    #[doc = " The beginning of a navigation chain."]
    #[doc = ""]
    TT_CHAIN_START_FLAG = 268435456,
    #[doc = ""]
    #[doc = " The last transition in a redirect chain."]
    #[doc = ""]
    TT_CHAIN_END_FLAG = 536870912,
    #[doc = ""]
    #[doc = " Redirects caused by JavaScript or a meta refresh tag on the page."]
    #[doc = ""]
    TT_CLIENT_REDIRECT_FLAG = 1073741824,
    #[doc = ""]
    #[doc = " Redirects sent from the server by HTTP headers."]
    #[doc = ""]
    TT_SERVER_REDIRECT_FLAG = 2147483648,
    #[doc = ""]
    #[doc = " Used to test whether a transition involves a redirect."]
    #[doc = ""]
    TT_IS_REDIRECT_MASK = 3221225472,
    #[doc = ""]
    #[doc = " General mask defining the bits used for the qualifiers."]
    #[doc = ""]
    TT_QUALIFIER_MASK = 4294967040,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Flags used to customize the behavior of CefURLRequest."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_urlrequest_flags_t {
    #[doc = ""]
    #[doc = " Default behavior."]
    #[doc = ""]
    UR_FLAG_NONE = 0,
    #[doc = ""]
    #[doc = " If set the cache will be skipped when handling the request. Setting this"]
    #[doc = " value is equivalent to specifying the \"Cache-Control: no-cache\" request"]
    #[doc = " header. Setting this value in combination with UR_FLAG_ONLY_FROM_CACHE"]
    #[doc = " will cause the request to fail."]
    #[doc = ""]
    UR_FLAG_SKIP_CACHE = 1,
    #[doc = ""]
    #[doc = " If set the request will fail if it cannot be served from the cache (or"]
    #[doc = " some equivalent local store). Setting this value is equivalent to"]
    #[doc = " specifying the \"Cache-Control: only-if-cached\" request header. Setting"]
    #[doc = " this value in combination with UR_FLAG_SKIP_CACHE or UR_FLAG_DISABLE_CACHE"]
    #[doc = " will cause the request to fail."]
    #[doc = ""]
    UR_FLAG_ONLY_FROM_CACHE = 2,
    #[doc = ""]
    #[doc = " If set the cache will not be used at all. Setting this value is equivalent"]
    #[doc = " to specifying the \"Cache-Control: no-store\" request header. Setting this"]
    #[doc = " value in combination with UR_FLAG_ONLY_FROM_CACHE will cause the request"]
    #[doc = " to fail."]
    #[doc = ""]
    UR_FLAG_DISABLE_CACHE = 4,
    #[doc = ""]
    #[doc = " If set user name, password, and cookies may be sent with the request, and"]
    #[doc = " cookies may be saved from the response."]
    #[doc = ""]
    UR_FLAG_ALLOW_STORED_CREDENTIALS = 8,
    #[doc = ""]
    #[doc = " If set upload progress events will be generated when a request has a body."]
    #[doc = ""]
    UR_FLAG_REPORT_UPLOAD_PROGRESS = 16,
    #[doc = ""]
    #[doc = " If set the CefURLRequestClient::OnDownloadData method will not be called."]
    #[doc = ""]
    UR_FLAG_NO_DOWNLOAD_DATA = 32,
    #[doc = ""]
    #[doc = " If set 5XX redirect errors will be propagated to the observer instead of"]
    #[doc = " automatically re-tried. This currently only applies for requests"]
    #[doc = " originated in the browser process."]
    #[doc = ""]
    UR_FLAG_NO_RETRY_ON_5XX = 64,
    #[doc = ""]
    #[doc = " If set 3XX responses will cause the fetch to halt immediately rather than"]
    #[doc = " continue through the redirect."]
    #[doc = ""]
    UR_FLAG_STOP_ON_REDIRECT = 128,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Flags that represent CefURLRequest status."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_urlrequest_status_t {
    #[doc = ""]
    #[doc = " Unknown status."]
    #[doc = ""]
    UR_UNKNOWN = 0,
    #[doc = ""]
    #[doc = " Request succeeded."]
    #[doc = ""]
    UR_SUCCESS = 1,
    #[doc = ""]
    #[doc = " An IO request is pending, and the caller will be informed when it is"]
    #[doc = " completed."]
    #[doc = ""]
    UR_IO_PENDING = 2,
    #[doc = ""]
    #[doc = " Request was canceled programatically."]
    #[doc = ""]
    UR_CANCELED = 3,
    #[doc = ""]
    #[doc = " Request failed for some reason."]
    #[doc = ""]
    UR_FAILED = 4,
}
#[doc = " Structure representing a draggable region."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_draggable_region_t {
    #[doc = ""]
    #[doc = " Bounds of the region."]
    #[doc = ""]
    pub bounds: cef_rect_t,
    #[doc = ""]
    #[doc = " True (1) this this region is draggable and false (0) otherwise."]
    #[doc = ""]
    pub draggable: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_draggable_region_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_draggable_region_t>(),
        20usize,
        concat!("Size of: ", stringify!(_cef_draggable_region_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_draggable_region_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_draggable_region_t))
    );
    fn test_field_bounds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_draggable_region_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).bounds) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_draggable_region_t),
                "::",
                stringify!(bounds)
            )
        );
    }
    test_field_bounds();
    fn test_field_draggable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_draggable_region_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).draggable) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_draggable_region_t),
                "::",
                stringify!(draggable)
            )
        );
    }
    test_field_draggable();
}
#[doc = " Structure representing a draggable region."]
#[doc = ""]
pub type cef_draggable_region_t = _cef_draggable_region_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Existing process IDs."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_process_id_t {
    #[doc = ""]
    #[doc = " Browser process."]
    #[doc = ""]
    PID_BROWSER = 0,
    #[doc = ""]
    #[doc = " Renderer process."]
    #[doc = ""]
    PID_RENDERER = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Existing thread IDs."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_thread_id_t {
    #[doc = ""]
    #[doc = " The main thread in the browser. This will be the same as the main"]
    #[doc = " application thread if CefInitialize() is called with a"]
    #[doc = " CefSettings.multi_threaded_message_loop value of false. Do not perform"]
    #[doc = " blocking tasks on this thread. All tasks posted after"]
    #[doc = " CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()"]
    #[doc = " are guaranteed to run. This thread will outlive all other CEF threads."]
    #[doc = ""]
    TID_UI = 0,
    #[doc = ""]
    #[doc = " Used for blocking tasks like file system access where the user won't"]
    #[doc = " notice if the task takes an arbitrarily long time to complete. All tasks"]
    #[doc = " posted after CefBrowserProcessHandler::OnContextInitialized() and before"]
    #[doc = " CefShutdown() are guaranteed to run."]
    #[doc = ""]
    TID_FILE_BACKGROUND = 1,
    #[doc = ""]
    #[doc = " Used for blocking tasks like file system access that affect UI or"]
    #[doc = " responsiveness of future user interactions. Do not use if an immediate"]
    #[doc = " response to a user interaction is expected. All tasks posted after"]
    #[doc = " CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()"]
    #[doc = " are guaranteed to run."]
    #[doc = " Examples:"]
    #[doc = " - Updating the UI to reflect progress on a long task."]
    #[doc = " - Loading data that might be shown in the UI after a future user"]
    #[doc = "   interaction."]
    #[doc = ""]
    TID_FILE_USER_VISIBLE = 2,
    #[doc = ""]
    #[doc = " Used for blocking tasks like file system access that affect UI"]
    #[doc = " immediately after a user interaction. All tasks posted after"]
    #[doc = " CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()"]
    #[doc = " are guaranteed to run."]
    #[doc = " Example: Generating data shown in the UI immediately after a click."]
    #[doc = ""]
    TID_FILE_USER_BLOCKING = 3,
    #[doc = ""]
    #[doc = " Used to launch and terminate browser processes."]
    #[doc = ""]
    TID_PROCESS_LAUNCHER = 4,
    #[doc = ""]
    #[doc = " Used to process IPC and network messages. Do not perform blocking tasks on"]
    #[doc = " this thread. All tasks posted after"]
    #[doc = " CefBrowserProcessHandler::OnContextInitialized() and before CefShutdown()"]
    #[doc = " are guaranteed to run."]
    #[doc = ""]
    TID_IO = 5,
    #[doc = ""]
    #[doc = " The main thread in the renderer. Used for all WebKit and V8 interaction."]
    #[doc = " Tasks may be posted to this thread after"]
    #[doc = " CefRenderProcessHandler::OnWebKitInitialized but are not guaranteed to"]
    #[doc = " run before sub-process termination (sub-processes may be killed at any"]
    #[doc = " time without warning)."]
    #[doc = ""]
    TID_RENDERER = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Thread priority values listed in increasing order of importance."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_thread_priority_t {
    #[doc = ""]
    #[doc = " Suitable for threads that shouldn't disrupt high priority work."]
    #[doc = ""]
    TP_BACKGROUND = 0,
    #[doc = ""]
    #[doc = " Default priority level."]
    #[doc = ""]
    TP_NORMAL = 1,
    #[doc = ""]
    #[doc = " Suitable for threads which generate data for the display (at ~60Hz)."]
    #[doc = ""]
    TP_DISPLAY = 2,
    #[doc = ""]
    #[doc = " Suitable for low-latency, glitch-resistant audio."]
    #[doc = ""]
    TP_REALTIME_AUDIO = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Message loop types. Indicates the set of asynchronous events that a message"]
#[doc = " loop can process."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_message_loop_type_t {
    #[doc = ""]
    #[doc = " Supports tasks and timers."]
    #[doc = ""]
    ML_TYPE_DEFAULT = 0,
    #[doc = ""]
    #[doc = " Supports tasks, timers and native UI events (e.g. Windows messages)."]
    #[doc = ""]
    ML_TYPE_UI = 1,
    #[doc = ""]
    #[doc = " Supports tasks, timers and asynchronous IO events."]
    #[doc = ""]
    ML_TYPE_IO = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Windows COM initialization mode. Specifies how COM will be initialized for a"]
#[doc = " new thread."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_com_init_mode_t {
    #[doc = ""]
    #[doc = " No COM initialization."]
    #[doc = ""]
    COM_INIT_MODE_NONE = 0,
    #[doc = ""]
    #[doc = " Initialize COM using single-threaded apartments."]
    #[doc = ""]
    COM_INIT_MODE_STA = 1,
    #[doc = ""]
    #[doc = " Initialize COM using multi-threaded apartments."]
    #[doc = ""]
    COM_INIT_MODE_MTA = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported value types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_value_type_t {
    VTYPE_INVALID = 0,
    VTYPE_NULL = 1,
    VTYPE_BOOL = 2,
    VTYPE_INT = 3,
    VTYPE_DOUBLE = 4,
    VTYPE_STRING = 5,
    VTYPE_BINARY = 6,
    VTYPE_DICTIONARY = 7,
    VTYPE_LIST = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported JavaScript dialog types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_jsdialog_type_t {
    JSDIALOGTYPE_ALERT = 0,
    JSDIALOGTYPE_CONFIRM = 1,
    JSDIALOGTYPE_PROMPT = 2,
}
#[doc = ""]
#[doc = " Screen information used when window rendering is disabled. This structure is"]
#[doc = " passed as a parameter to CefRenderHandler::GetScreenInfo and should be"]
#[doc = " filled in by the client."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_screen_info_t {
    #[doc = ""]
    #[doc = " Device scale factor. Specifies the ratio between physical and logical"]
    #[doc = " pixels."]
    #[doc = ""]
    pub device_scale_factor: f32,
    #[doc = ""]
    #[doc = " The screen depth in bits per pixel."]
    #[doc = ""]
    pub depth: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The bits per color component. This assumes that the colors are balanced"]
    #[doc = " equally."]
    #[doc = ""]
    pub depth_per_component: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " This can be true for black and white printers."]
    #[doc = ""]
    pub is_monochrome: ::std::os::raw::c_int,
    #[doc = " The |rect| and |available_rect| properties are used to determine the"]
    #[doc = " available surface for rendering popup views."]
    #[doc = ""]
    pub rect: cef_rect_t,
    #[doc = " The |rect| and |available_rect| properties are used to determine the"]
    #[doc = " available surface for rendering popup views."]
    #[doc = ""]
    pub available_rect: cef_rect_t,
}
#[test]
fn bindgen_test_layout__cef_screen_info_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_screen_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_screen_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_screen_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_screen_info_t))
    );
    fn test_field_device_scale_factor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_screen_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).device_scale_factor) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_screen_info_t),
                "::",
                stringify!(device_scale_factor)
            )
        );
    }
    test_field_device_scale_factor();
    fn test_field_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_screen_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_screen_info_t),
                "::",
                stringify!(depth)
            )
        );
    }
    test_field_depth();
    fn test_field_depth_per_component() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_screen_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).depth_per_component) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_screen_info_t),
                "::",
                stringify!(depth_per_component)
            )
        );
    }
    test_field_depth_per_component();
    fn test_field_is_monochrome() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_screen_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_monochrome) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_screen_info_t),
                "::",
                stringify!(is_monochrome)
            )
        );
    }
    test_field_is_monochrome();
    fn test_field_rect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_screen_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rect) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_screen_info_t),
                "::",
                stringify!(rect)
            )
        );
    }
    test_field_rect();
    fn test_field_available_rect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_screen_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).available_rect) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_screen_info_t),
                "::",
                stringify!(available_rect)
            )
        );
    }
    test_field_available_rect();
}
#[doc = ""]
#[doc = " Screen information used when window rendering is disabled. This structure is"]
#[doc = " passed as a parameter to CefRenderHandler::GetScreenInfo and should be"]
#[doc = " filled in by the client."]
#[doc = ""]
pub type cef_screen_info_t = _cef_screen_info_t;
impl cef_menu_id_t {
    pub const MENU_ID_SPELLCHECK_SUGGESTION_LAST: cef_menu_id_t =
        cef_menu_id_t::MENU_ID_SPELLCHECK_SUGGESTION_4;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported menu IDs. Non-English translations can be provided for the"]
#[doc = " IDS_MENU_* strings in CefResourceBundleHandler::GetLocalizedString()."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_menu_id_t {
    MENU_ID_BACK = 100,
    MENU_ID_FORWARD = 101,
    MENU_ID_RELOAD = 102,
    MENU_ID_RELOAD_NOCACHE = 103,
    MENU_ID_STOPLOAD = 104,
    MENU_ID_UNDO = 110,
    MENU_ID_REDO = 111,
    MENU_ID_CUT = 112,
    MENU_ID_COPY = 113,
    MENU_ID_PASTE = 114,
    MENU_ID_DELETE = 115,
    MENU_ID_SELECT_ALL = 116,
    MENU_ID_FIND = 130,
    MENU_ID_PRINT = 131,
    MENU_ID_VIEW_SOURCE = 132,
    MENU_ID_SPELLCHECK_SUGGESTION_0 = 200,
    MENU_ID_SPELLCHECK_SUGGESTION_1 = 201,
    MENU_ID_SPELLCHECK_SUGGESTION_2 = 202,
    MENU_ID_SPELLCHECK_SUGGESTION_3 = 203,
    MENU_ID_SPELLCHECK_SUGGESTION_4 = 204,
    MENU_ID_NO_SPELLING_SUGGESTIONS = 205,
    MENU_ID_ADD_TO_DICTIONARY = 206,
    MENU_ID_CUSTOM_FIRST = 220,
    MENU_ID_CUSTOM_LAST = 250,
    MENU_ID_USER_FIRST = 26500,
    MENU_ID_USER_LAST = 28500,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Mouse button types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_mouse_button_type_t {
    MBT_LEFT = 0,
    MBT_MIDDLE = 1,
    MBT_RIGHT = 2,
}
#[doc = ""]
#[doc = " Structure representing mouse event information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_mouse_event_t {
    #[doc = ""]
    #[doc = " X coordinate relative to the left side of the view."]
    #[doc = ""]
    pub x: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Y coordinate relative to the top side of the view."]
    #[doc = ""]
    pub y: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Bit flags describing any pressed modifier keys. See"]
    #[doc = " cef_event_flags_t for values."]
    #[doc = ""]
    pub modifiers: uint32,
}
#[test]
fn bindgen_test_layout__cef_mouse_event_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_mouse_event_t>(),
        12usize,
        concat!("Size of: ", stringify!(_cef_mouse_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_mouse_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_mouse_event_t))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_mouse_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_mouse_event_t),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_mouse_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_mouse_event_t),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_modifiers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_mouse_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_mouse_event_t),
                "::",
                stringify!(modifiers)
            )
        );
    }
    test_field_modifiers();
}
#[doc = ""]
#[doc = " Structure representing mouse event information."]
#[doc = ""]
pub type cef_mouse_event_t = _cef_mouse_event_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Touch points states types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_touch_event_type_t {
    CEF_TET_RELEASED = 0,
    CEF_TET_PRESSED = 1,
    CEF_TET_MOVED = 2,
    CEF_TET_CANCELLED = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " The device type that caused the event."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_pointer_type_t {
    CEF_POINTER_TYPE_TOUCH = 0,
    CEF_POINTER_TYPE_MOUSE = 1,
    CEF_POINTER_TYPE_PEN = 2,
    CEF_POINTER_TYPE_ERASER = 3,
    CEF_POINTER_TYPE_UNKNOWN = 4,
}
#[doc = ""]
#[doc = " Structure representing touch event information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_touch_event_t {
    #[doc = ""]
    #[doc = " Id of a touch point. Must be unique per touch, can be any number except"]
    #[doc = " -1. Note that a maximum of 16 concurrent touches will be tracked; touches"]
    #[doc = " beyond that will be ignored."]
    #[doc = ""]
    pub id: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " X coordinate relative to the left side of the view."]
    #[doc = ""]
    pub x: f32,
    #[doc = ""]
    #[doc = " Y coordinate relative to the top side of the view."]
    #[doc = ""]
    pub y: f32,
    #[doc = ""]
    #[doc = " X radius in pixels. Set to 0 if not applicable."]
    #[doc = ""]
    pub radius_x: f32,
    #[doc = ""]
    #[doc = " Y radius in pixels. Set to 0 if not applicable."]
    #[doc = ""]
    pub radius_y: f32,
    #[doc = ""]
    #[doc = " Rotation angle in radians. Set to 0 if not applicable."]
    #[doc = ""]
    pub rotation_angle: f32,
    #[doc = ""]
    #[doc = " The normalized pressure of the pointer input in the range of [0,1]."]
    #[doc = " Set to 0 if not applicable."]
    #[doc = ""]
    pub pressure: f32,
    #[doc = ""]
    #[doc = " The state of the touch point. Touches begin with one CEF_TET_PRESSED event"]
    #[doc = " followed by zero or more CEF_TET_MOVED events and finally one"]
    #[doc = " CEF_TET_RELEASED or CEF_TET_CANCELLED event. Events not respecting this"]
    #[doc = " order will be ignored."]
    #[doc = ""]
    pub type_: cef_touch_event_type_t,
    #[doc = ""]
    #[doc = " Bit flags describing any pressed modifier keys. See"]
    #[doc = " cef_event_flags_t for values."]
    #[doc = ""]
    pub modifiers: uint32,
    #[doc = ""]
    #[doc = " The device type that caused the event."]
    #[doc = ""]
    pub pointer_type: cef_pointer_type_t,
}
#[test]
fn bindgen_test_layout__cef_touch_event_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_touch_event_t>(),
        40usize,
        concat!("Size of: ", stringify!(_cef_touch_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_touch_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_touch_event_t))
    );
    fn test_field_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_event_t),
                "::",
                stringify!(id)
            )
        );
    }
    test_field_id();
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_event_t),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_event_t),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_radius_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).radius_x) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_event_t),
                "::",
                stringify!(radius_x)
            )
        );
    }
    test_field_radius_x();
    fn test_field_radius_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).radius_y) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_event_t),
                "::",
                stringify!(radius_y)
            )
        );
    }
    test_field_radius_y();
    fn test_field_rotation_angle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).rotation_angle) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_event_t),
                "::",
                stringify!(rotation_angle)
            )
        );
    }
    test_field_rotation_angle();
    fn test_field_pressure() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pressure) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_event_t),
                "::",
                stringify!(pressure)
            )
        );
    }
    test_field_pressure();
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_event_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_modifiers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_event_t),
                "::",
                stringify!(modifiers)
            )
        );
    }
    test_field_modifiers();
    fn test_field_pointer_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pointer_type) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_event_t),
                "::",
                stringify!(pointer_type)
            )
        );
    }
    test_field_pointer_type();
}
#[doc = ""]
#[doc = " Structure representing touch event information."]
#[doc = ""]
pub type cef_touch_event_t = _cef_touch_event_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Paint element types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_paint_element_type_t {
    PET_VIEW = 0,
    PET_POPUP = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported event bit flags."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_event_flags_t {
    EVENTFLAG_NONE = 0,
    EVENTFLAG_CAPS_LOCK_ON = 1,
    EVENTFLAG_SHIFT_DOWN = 2,
    EVENTFLAG_CONTROL_DOWN = 4,
    EVENTFLAG_ALT_DOWN = 8,
    EVENTFLAG_LEFT_MOUSE_BUTTON = 16,
    EVENTFLAG_MIDDLE_MOUSE_BUTTON = 32,
    EVENTFLAG_RIGHT_MOUSE_BUTTON = 64,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_COMMAND_DOWN = 128,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_NUM_LOCK_ON = 256,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_IS_KEY_PAD = 512,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_IS_LEFT = 1024,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_IS_RIGHT = 2048,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_ALTGR_DOWN = 4096,
    #[doc = " Mac OS-X command key."]
    EVENTFLAG_IS_REPEAT = 8192,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported menu item types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_menu_item_type_t {
    MENUITEMTYPE_NONE = 0,
    MENUITEMTYPE_COMMAND = 1,
    MENUITEMTYPE_CHECK = 2,
    MENUITEMTYPE_RADIO = 3,
    MENUITEMTYPE_SEPARATOR = 4,
    MENUITEMTYPE_SUBMENU = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported context menu type flags."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_context_menu_type_flags_t {
    #[doc = ""]
    #[doc = " No node is selected."]
    #[doc = ""]
    CM_TYPEFLAG_NONE = 0,
    #[doc = ""]
    #[doc = " The top page is selected."]
    #[doc = ""]
    CM_TYPEFLAG_PAGE = 1,
    #[doc = ""]
    #[doc = " A subframe page is selected."]
    #[doc = ""]
    CM_TYPEFLAG_FRAME = 2,
    #[doc = ""]
    #[doc = " A link is selected."]
    #[doc = ""]
    CM_TYPEFLAG_LINK = 4,
    #[doc = ""]
    #[doc = " A media node is selected."]
    #[doc = ""]
    CM_TYPEFLAG_MEDIA = 8,
    #[doc = ""]
    #[doc = " There is a textual or mixed selection that is selected."]
    #[doc = ""]
    CM_TYPEFLAG_SELECTION = 16,
    #[doc = ""]
    #[doc = " An editable element is selected."]
    #[doc = ""]
    CM_TYPEFLAG_EDITABLE = 32,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported context menu media types. These constants match their equivalents"]
#[doc = " in Chromium's ContextMenuDataMediaType and should not be renumbered."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_context_menu_media_type_t {
    #[doc = ""]
    #[doc = " No special node is in context."]
    #[doc = ""]
    CM_MEDIATYPE_NONE = 0,
    #[doc = ""]
    #[doc = " An image node is selected."]
    #[doc = ""]
    CM_MEDIATYPE_IMAGE = 1,
    #[doc = ""]
    #[doc = " A video node is selected."]
    #[doc = ""]
    CM_MEDIATYPE_VIDEO = 2,
    #[doc = ""]
    #[doc = " An audio node is selected."]
    #[doc = ""]
    CM_MEDIATYPE_AUDIO = 3,
    #[doc = ""]
    #[doc = " An canvas node is selected."]
    #[doc = ""]
    CM_MEDIATYPE_CANVAS = 4,
    #[doc = ""]
    #[doc = " A file node is selected."]
    #[doc = ""]
    CM_MEDIATYPE_FILE = 5,
    #[doc = ""]
    #[doc = " A plugin node is selected."]
    #[doc = ""]
    CM_MEDIATYPE_PLUGIN = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported context menu media state bit flags. These constants match their"]
#[doc = " equivalents in Chromium's ContextMenuData::MediaFlags and should not be"]
#[doc = " renumbered."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_context_menu_media_state_flags_t {
    CM_MEDIAFLAG_NONE = 0,
    CM_MEDIAFLAG_IN_ERROR = 1,
    CM_MEDIAFLAG_PAUSED = 2,
    CM_MEDIAFLAG_MUTED = 4,
    CM_MEDIAFLAG_LOOP = 8,
    CM_MEDIAFLAG_CAN_SAVE = 16,
    CM_MEDIAFLAG_HAS_AUDIO = 32,
    CM_MEDIAFLAG_CAN_TOGGLE_CONTROLS = 64,
    CM_MEDIAFLAG_CONTROLS = 128,
    CM_MEDIAFLAG_CAN_PRINT = 256,
    CM_MEDIAFLAG_CAN_ROTATE = 512,
    CM_MEDIAFLAG_CAN_PICTURE_IN_PICTURE = 1024,
    CM_MEDIAFLAG_PICTURE_IN_PICTURE = 2048,
    CM_MEDIAFLAG_CAN_LOOP = 4096,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported context menu edit state bit flags. These constants match their"]
#[doc = " equivalents in Chromium's ContextMenuDataEditFlags and should not be"]
#[doc = " renumbered."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_context_menu_edit_state_flags_t {
    CM_EDITFLAG_NONE = 0,
    CM_EDITFLAG_CAN_UNDO = 1,
    CM_EDITFLAG_CAN_REDO = 2,
    CM_EDITFLAG_CAN_CUT = 4,
    CM_EDITFLAG_CAN_COPY = 8,
    CM_EDITFLAG_CAN_PASTE = 16,
    CM_EDITFLAG_CAN_DELETE = 32,
    CM_EDITFLAG_CAN_SELECT_ALL = 64,
    CM_EDITFLAG_CAN_TRANSLATE = 128,
    CM_EDITFLAG_CAN_EDIT_RICHLY = 256,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported quick menu state bit flags."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_quick_menu_edit_state_flags_t {
    QM_EDITFLAG_NONE = 0,
    QM_EDITFLAG_CAN_ELLIPSIS = 1,
    QM_EDITFLAG_CAN_CUT = 2,
    QM_EDITFLAG_CAN_COPY = 4,
    QM_EDITFLAG_CAN_PASTE = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Key event types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_key_event_type_t {
    #[doc = ""]
    #[doc = " Notification that a key transitioned from \"up\" to \"down\"."]
    #[doc = ""]
    KEYEVENT_RAWKEYDOWN = 0,
    #[doc = ""]
    #[doc = " Notification that a key was pressed. This does not necessarily correspond"]
    #[doc = " to a character depending on the key and language. Use KEYEVENT_CHAR for"]
    #[doc = " character input."]
    #[doc = ""]
    KEYEVENT_KEYDOWN = 1,
    #[doc = ""]
    #[doc = " Notification that a key was released."]
    #[doc = ""]
    KEYEVENT_KEYUP = 2,
    #[doc = ""]
    #[doc = " Notification that a character was typed. Use this for text input. Key"]
    #[doc = " down events may generate 0, 1, or more than one character event depending"]
    #[doc = " on the key, locale, and operating system."]
    #[doc = ""]
    KEYEVENT_CHAR = 3,
}
#[doc = ""]
#[doc = " Structure representing keyboard event information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_key_event_t {
    #[doc = ""]
    #[doc = " The type of keyboard event."]
    #[doc = ""]
    pub type_: cef_key_event_type_t,
    #[doc = ""]
    #[doc = " Bit flags describing any pressed modifier keys. See"]
    #[doc = " cef_event_flags_t for values."]
    #[doc = ""]
    pub modifiers: uint32,
    #[doc = ""]
    #[doc = " The Windows key code for the key event. This value is used by the DOM"]
    #[doc = " specification. Sometimes it comes directly from the event (i.e. on"]
    #[doc = " Windows) and sometimes it's determined using a mapping function. See"]
    #[doc = " WebCore/platform/chromium/KeyboardCodes.h for the list of values."]
    #[doc = ""]
    pub windows_key_code: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The actual key code genenerated by the platform."]
    #[doc = ""]
    pub native_key_code: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Indicates whether the event is considered a \"system key\" event (see"]
    #[doc = " http://msdn.microsoft.com/en-us/library/ms646286(VS.85).aspx for details)."]
    #[doc = " This value will always be false on non-Windows platforms."]
    #[doc = ""]
    pub is_system_key: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The character generated by the keystroke."]
    #[doc = ""]
    pub character: char16,
    #[doc = ""]
    #[doc = " Same as |character| but unmodified by any concurrently-held modifiers"]
    #[doc = " (except shift). This is useful for working out shortcut keys."]
    #[doc = ""]
    pub unmodified_character: char16,
    #[doc = ""]
    #[doc = " True if the focus is currently on an editable field on the page. This is"]
    #[doc = " useful for determining if standard key events should be intercepted."]
    #[doc = ""]
    pub focus_on_editable_field: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_key_event_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_key_event_t>(),
        28usize,
        concat!("Size of: ", stringify!(_cef_key_event_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_key_event_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_key_event_t))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_key_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_key_event_t),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_modifiers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_key_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).modifiers) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_key_event_t),
                "::",
                stringify!(modifiers)
            )
        );
    }
    test_field_modifiers();
    fn test_field_windows_key_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_key_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).windows_key_code) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_key_event_t),
                "::",
                stringify!(windows_key_code)
            )
        );
    }
    test_field_windows_key_code();
    fn test_field_native_key_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_key_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).native_key_code) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_key_event_t),
                "::",
                stringify!(native_key_code)
            )
        );
    }
    test_field_native_key_code();
    fn test_field_is_system_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_key_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_system_key) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_key_event_t),
                "::",
                stringify!(is_system_key)
            )
        );
    }
    test_field_is_system_key();
    fn test_field_character() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_key_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).character) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_key_event_t),
                "::",
                stringify!(character)
            )
        );
    }
    test_field_character();
    fn test_field_unmodified_character() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_key_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unmodified_character) as usize - ptr as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_key_event_t),
                "::",
                stringify!(unmodified_character)
            )
        );
    }
    test_field_unmodified_character();
    fn test_field_focus_on_editable_field() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_key_event_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).focus_on_editable_field) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_key_event_t),
                "::",
                stringify!(focus_on_editable_field)
            )
        );
    }
    test_field_focus_on_editable_field();
}
#[doc = ""]
#[doc = " Structure representing keyboard event information."]
#[doc = ""]
pub type cef_key_event_t = _cef_key_event_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Focus sources."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_focus_source_t {
    #[doc = ""]
    #[doc = " The source is explicit navigation via the API (LoadURL(), etc)."]
    #[doc = ""]
    FOCUS_SOURCE_NAVIGATION = 0,
    #[doc = ""]
    #[doc = " The source is a system-generated focus event."]
    #[doc = ""]
    FOCUS_SOURCE_SYSTEM = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Navigation types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_navigation_type_t {
    NAVIGATION_LINK_CLICKED = 0,
    NAVIGATION_FORM_SUBMITTED = 1,
    NAVIGATION_BACK_FORWARD = 2,
    NAVIGATION_RELOAD = 3,
    NAVIGATION_FORM_RESUBMITTED = 4,
    NAVIGATION_OTHER = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported XML encoding types. The parser supports ASCII, ISO-8859-1, and"]
#[doc = " UTF16 (LE and BE) by default. All other types must be translated to UTF8"]
#[doc = " before being passed to the parser. If a BOM is detected and the correct"]
#[doc = " decoder is available then that decoder will be used automatically."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_xml_encoding_type_t {
    XML_ENCODING_NONE = 0,
    XML_ENCODING_UTF8 = 1,
    XML_ENCODING_UTF16LE = 2,
    XML_ENCODING_UTF16BE = 3,
    XML_ENCODING_ASCII = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " XML node types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_xml_node_type_t {
    XML_NODE_UNSUPPORTED = 0,
    XML_NODE_PROCESSING_INSTRUCTION = 1,
    XML_NODE_DOCUMENT_TYPE = 2,
    XML_NODE_ELEMENT_START = 3,
    XML_NODE_ELEMENT_END = 4,
    XML_NODE_ATTRIBUTE = 5,
    XML_NODE_TEXT = 6,
    XML_NODE_CDATA = 7,
    XML_NODE_ENTITY_REFERENCE = 8,
    XML_NODE_WHITESPACE = 9,
    XML_NODE_COMMENT = 10,
}
#[doc = ""]
#[doc = " Popup window features."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_popup_features_t {
    pub x: ::std::os::raw::c_int,
    pub xSet: ::std::os::raw::c_int,
    pub y: ::std::os::raw::c_int,
    pub ySet: ::std::os::raw::c_int,
    pub width: ::std::os::raw::c_int,
    pub widthSet: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub heightSet: ::std::os::raw::c_int,
    pub menuBarVisible: ::std::os::raw::c_int,
    pub statusBarVisible: ::std::os::raw::c_int,
    pub toolBarVisible: ::std::os::raw::c_int,
    pub scrollbarsVisible: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_popup_features_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_popup_features_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_popup_features_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_popup_features_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_popup_features_t))
    );
    fn test_field_x() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(x)
            )
        );
    }
    test_field_x();
    fn test_field_xSet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).xSet) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(xSet)
            )
        );
    }
    test_field_xSet();
    fn test_field_y() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(y)
            )
        );
    }
    test_field_y();
    fn test_field_ySet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ySet) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(ySet)
            )
        );
    }
    test_field_ySet();
    fn test_field_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(width)
            )
        );
    }
    test_field_width();
    fn test_field_widthSet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).widthSet) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(widthSet)
            )
        );
    }
    test_field_widthSet();
    fn test_field_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(height)
            )
        );
    }
    test_field_height();
    fn test_field_heightSet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heightSet) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(heightSet)
            )
        );
    }
    test_field_heightSet();
    fn test_field_menuBarVisible() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).menuBarVisible) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(menuBarVisible)
            )
        );
    }
    test_field_menuBarVisible();
    fn test_field_statusBarVisible() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).statusBarVisible) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(statusBarVisible)
            )
        );
    }
    test_field_statusBarVisible();
    fn test_field_toolBarVisible() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).toolBarVisible) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(toolBarVisible)
            )
        );
    }
    test_field_toolBarVisible();
    fn test_field_scrollbarsVisible() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_popup_features_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scrollbarsVisible) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_popup_features_t),
                "::",
                stringify!(scrollbarsVisible)
            )
        );
    }
    test_field_scrollbarsVisible();
}
#[doc = ""]
#[doc = " Popup window features."]
#[doc = ""]
pub type cef_popup_features_t = _cef_popup_features_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " DOM document types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_dom_document_type_t {
    DOM_DOCUMENT_TYPE_UNKNOWN = 0,
    DOM_DOCUMENT_TYPE_HTML = 1,
    DOM_DOCUMENT_TYPE_XHTML = 2,
    DOM_DOCUMENT_TYPE_PLUGIN = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " DOM event category flags."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_dom_event_category_t {
    DOM_EVENT_CATEGORY_UNKNOWN = 0,
    DOM_EVENT_CATEGORY_UI = 1,
    DOM_EVENT_CATEGORY_MOUSE = 2,
    DOM_EVENT_CATEGORY_MUTATION = 4,
    DOM_EVENT_CATEGORY_KEYBOARD = 8,
    DOM_EVENT_CATEGORY_TEXT = 16,
    DOM_EVENT_CATEGORY_COMPOSITION = 32,
    DOM_EVENT_CATEGORY_DRAG = 64,
    DOM_EVENT_CATEGORY_CLIPBOARD = 128,
    DOM_EVENT_CATEGORY_MESSAGE = 256,
    DOM_EVENT_CATEGORY_WHEEL = 512,
    DOM_EVENT_CATEGORY_BEFORE_TEXT_INSERTED = 1024,
    DOM_EVENT_CATEGORY_OVERFLOW = 2048,
    DOM_EVENT_CATEGORY_PAGE_TRANSITION = 4096,
    DOM_EVENT_CATEGORY_POPSTATE = 8192,
    DOM_EVENT_CATEGORY_PROGRESS = 16384,
    DOM_EVENT_CATEGORY_XMLHTTPREQUEST_PROGRESS = 32768,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " DOM event processing phases."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_dom_event_phase_t {
    DOM_EVENT_PHASE_UNKNOWN = 0,
    DOM_EVENT_PHASE_CAPTURING = 1,
    DOM_EVENT_PHASE_AT_TARGET = 2,
    DOM_EVENT_PHASE_BUBBLING = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " DOM node types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_dom_node_type_t {
    DOM_NODE_TYPE_UNSUPPORTED = 0,
    DOM_NODE_TYPE_ELEMENT = 1,
    DOM_NODE_TYPE_ATTRIBUTE = 2,
    DOM_NODE_TYPE_TEXT = 3,
    DOM_NODE_TYPE_CDATA_SECTION = 4,
    DOM_NODE_TYPE_PROCESSING_INSTRUCTIONS = 5,
    DOM_NODE_TYPE_COMMENT = 6,
    DOM_NODE_TYPE_DOCUMENT = 7,
    DOM_NODE_TYPE_DOCUMENT_TYPE = 8,
    DOM_NODE_TYPE_DOCUMENT_FRAGMENT = 9,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported file dialog modes."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_file_dialog_mode_t {
    #[doc = ""]
    #[doc = " Requires that the file exists before allowing the user to pick it."]
    #[doc = ""]
    FILE_DIALOG_OPEN = 0,
    #[doc = ""]
    #[doc = " Like Open, but allows picking multiple files to open."]
    #[doc = ""]
    FILE_DIALOG_OPEN_MULTIPLE = 1,
    #[doc = ""]
    #[doc = " Like Open, but selects a folder to open."]
    #[doc = ""]
    FILE_DIALOG_OPEN_FOLDER = 2,
    #[doc = ""]
    #[doc = " Allows picking a nonexistent file, and prompts to overwrite if the file"]
    #[doc = " already exists."]
    #[doc = ""]
    FILE_DIALOG_SAVE = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Print job color mode values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_color_model_t {
    COLOR_MODEL_UNKNOWN = 0,
    COLOR_MODEL_GRAY = 1,
    COLOR_MODEL_COLOR = 2,
    COLOR_MODEL_CMYK = 3,
    COLOR_MODEL_CMY = 4,
    COLOR_MODEL_KCMY = 5,
    COLOR_MODEL_CMY_K = 6,
    COLOR_MODEL_BLACK = 7,
    COLOR_MODEL_GRAYSCALE = 8,
    COLOR_MODEL_RGB = 9,
    COLOR_MODEL_RGB16 = 10,
    COLOR_MODEL_RGBA = 11,
    COLOR_MODEL_COLORMODE_COLOR = 12,
    COLOR_MODEL_COLORMODE_MONOCHROME = 13,
    COLOR_MODEL_HP_COLOR_COLOR = 14,
    COLOR_MODEL_HP_COLOR_BLACK = 15,
    COLOR_MODEL_PRINTOUTMODE_NORMAL = 16,
    COLOR_MODEL_PRINTOUTMODE_NORMAL_GRAY = 17,
    COLOR_MODEL_PROCESSCOLORMODEL_CMYK = 18,
    COLOR_MODEL_PROCESSCOLORMODEL_GREYSCALE = 19,
    COLOR_MODEL_PROCESSCOLORMODEL_RGB = 20,
}
#[repr(i32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Print job duplex mode values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_duplex_mode_t {
    DUPLEX_MODE_UNKNOWN = -1,
    DUPLEX_MODE_SIMPLEX = 0,
    DUPLEX_MODE_LONG_EDGE = 1,
    DUPLEX_MODE_SHORT_EDGE = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Cursor type values."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_cursor_type_t {
    CT_POINTER = 0,
    CT_CROSS = 1,
    CT_HAND = 2,
    CT_IBEAM = 3,
    CT_WAIT = 4,
    CT_HELP = 5,
    CT_EASTRESIZE = 6,
    CT_NORTHRESIZE = 7,
    CT_NORTHEASTRESIZE = 8,
    CT_NORTHWESTRESIZE = 9,
    CT_SOUTHRESIZE = 10,
    CT_SOUTHEASTRESIZE = 11,
    CT_SOUTHWESTRESIZE = 12,
    CT_WESTRESIZE = 13,
    CT_NORTHSOUTHRESIZE = 14,
    CT_EASTWESTRESIZE = 15,
    CT_NORTHEASTSOUTHWESTRESIZE = 16,
    CT_NORTHWESTSOUTHEASTRESIZE = 17,
    CT_COLUMNRESIZE = 18,
    CT_ROWRESIZE = 19,
    CT_MIDDLEPANNING = 20,
    CT_EASTPANNING = 21,
    CT_NORTHPANNING = 22,
    CT_NORTHEASTPANNING = 23,
    CT_NORTHWESTPANNING = 24,
    CT_SOUTHPANNING = 25,
    CT_SOUTHEASTPANNING = 26,
    CT_SOUTHWESTPANNING = 27,
    CT_WESTPANNING = 28,
    CT_MOVE = 29,
    CT_VERTICALTEXT = 30,
    CT_CELL = 31,
    CT_CONTEXTMENU = 32,
    CT_ALIAS = 33,
    CT_PROGRESS = 34,
    CT_NODROP = 35,
    CT_COPY = 36,
    CT_NONE = 37,
    CT_NOTALLOWED = 38,
    CT_ZOOMIN = 39,
    CT_ZOOMOUT = 40,
    CT_GRAB = 41,
    CT_GRABBING = 42,
    CT_MIDDLE_PANNING_VERTICAL = 43,
    CT_MIDDLE_PANNING_HORIZONTAL = 44,
    CT_CUSTOM = 45,
    CT_DND_NONE = 46,
    CT_DND_MOVE = 47,
    CT_DND_COPY = 48,
    CT_DND_LINK = 49,
}
#[doc = ""]
#[doc = " Structure representing cursor information. |buffer| will be"]
#[doc = " |size.width|*|size.height|*4 bytes in size and represents a BGRA image with"]
#[doc = " an upper-left origin."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cursor_info_t {
    pub hotspot: cef_point_t,
    pub image_scale_factor: f32,
    pub buffer: *mut ::std::os::raw::c_void,
    pub size: cef_size_t,
}
#[test]
fn bindgen_test_layout__cef_cursor_info_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_cursor_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(_cef_cursor_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_cursor_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_cursor_info_t))
    );
    fn test_field_hotspot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cursor_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).hotspot) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cursor_info_t),
                "::",
                stringify!(hotspot)
            )
        );
    }
    test_field_hotspot();
    fn test_field_image_scale_factor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cursor_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).image_scale_factor) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cursor_info_t),
                "::",
                stringify!(image_scale_factor)
            )
        );
    }
    test_field_image_scale_factor();
    fn test_field_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cursor_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).buffer) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cursor_info_t),
                "::",
                stringify!(buffer)
            )
        );
    }
    test_field_buffer();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cursor_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cursor_info_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
}
#[doc = ""]
#[doc = " Structure representing cursor information. |buffer| will be"]
#[doc = " |size.width|*|size.height|*4 bytes in size and represents a BGRA image with"]
#[doc = " an upper-left origin."]
#[doc = ""]
pub type cef_cursor_info_t = _cef_cursor_info_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " URI unescape rules passed to CefURIDecode()."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_uri_unescape_rule_t {
    #[doc = ""]
    #[doc = " Don't unescape anything at all."]
    #[doc = ""]
    UU_NONE = 0,
    #[doc = ""]
    #[doc = " Don't unescape anything special, but all normal unescaping will happen."]
    #[doc = " This is a placeholder and can't be combined with other flags (since it's"]
    #[doc = " just the absence of them). All other unescape rules imply \"normal\" in"]
    #[doc = " addition to their special meaning. Things like escaped letters, digits,"]
    #[doc = " and most symbols will get unescaped with this mode."]
    #[doc = ""]
    UU_NORMAL = 1,
    #[doc = ""]
    #[doc = " Convert %20 to spaces. In some places where we're showing URLs, we may"]
    #[doc = " want this. In places where the URL may be copied and pasted out, then"]
    #[doc = " you wouldn't want this since it might not be interpreted in one piece"]
    #[doc = " by other applications."]
    #[doc = ""]
    UU_SPACES = 2,
    #[doc = ""]
    #[doc = " Unescapes '/' and '\\\\'. If these characters were unescaped, the resulting"]
    #[doc = " URL won't be the same as the source one. Moreover, they are dangerous to"]
    #[doc = " unescape in strings that will be used as file paths or names. This value"]
    #[doc = " should only be used when slashes don't have special meaning, like data"]
    #[doc = " URLs."]
    #[doc = ""]
    UU_PATH_SEPARATORS = 4,
    #[doc = ""]
    #[doc = " Unescapes various characters that will change the meaning of URLs,"]
    #[doc = " including '%', '+', '&', '#'. Does not unescape path separators."]
    #[doc = " If these characters were unescaped, the resulting URL won't be the same"]
    #[doc = " as the source one. This flag is used when generating final output like"]
    #[doc = " filenames for URLs where we won't be interpreting as a URL and want to do"]
    #[doc = " as much unescaping as possible."]
    #[doc = ""]
    UU_URL_SPECIAL_CHARS_EXCEPT_PATH_SEPARATORS = 8,
    #[doc = ""]
    #[doc = " URL queries use \"+\" for space. This flag controls that replacement."]
    #[doc = ""]
    UU_REPLACE_PLUS_WITH_SPACE = 16,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Options that can be passed to CefParseJSON."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_json_parser_options_t {
    #[doc = ""]
    #[doc = " Parses the input strictly according to RFC 4627. See comments in"]
    #[doc = " Chromium's base/json/json_reader.h file for known limitations/"]
    #[doc = " deviations from the RFC."]
    #[doc = ""]
    JSON_PARSER_RFC = 0,
    #[doc = ""]
    #[doc = " Allows commas to exist after the last element in structures."]
    #[doc = ""]
    JSON_PARSER_ALLOW_TRAILING_COMMAS = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Options that can be passed to CefWriteJSON."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_json_writer_options_t {
    #[doc = ""]
    #[doc = " Default behavior."]
    #[doc = ""]
    JSON_WRITER_DEFAULT = 0,
    #[doc = ""]
    #[doc = " This option instructs the writer that if a Binary value is encountered,"]
    #[doc = " the value (and key if within a dictionary) will be omitted from the"]
    #[doc = " output, and success will be returned. Otherwise, if a binary value is"]
    #[doc = " encountered, failure will be returned."]
    #[doc = ""]
    JSON_WRITER_OMIT_BINARY_VALUES = 1,
    #[doc = ""]
    #[doc = " This option instructs the writer to write doubles that have no fractional"]
    #[doc = " part as a normal integer (i.e., without using exponential notation"]
    #[doc = " or appending a '.0') as long as the value is within the range of a"]
    #[doc = " 64-bit int."]
    #[doc = ""]
    JSON_WRITER_OMIT_DOUBLE_TYPE_PRESERVATION = 2,
    #[doc = ""]
    #[doc = " Return a slightly nicer formatted json string (pads with whitespace to"]
    #[doc = " help with readability)."]
    #[doc = ""]
    JSON_WRITER_PRETTY_PRINT = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Margin type for PDF printing."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_pdf_print_margin_type_t {
    #[doc = ""]
    #[doc = " Default margins."]
    #[doc = ""]
    PDF_PRINT_MARGIN_DEFAULT = 0,
    #[doc = ""]
    #[doc = " No margins."]
    #[doc = ""]
    PDF_PRINT_MARGIN_NONE = 1,
    #[doc = ""]
    #[doc = " Minimum margins."]
    #[doc = ""]
    PDF_PRINT_MARGIN_MINIMUM = 2,
    #[doc = ""]
    #[doc = " Custom margins using the |margin_*| values from cef_pdf_print_settings_t."]
    #[doc = ""]
    PDF_PRINT_MARGIN_CUSTOM = 3,
}
#[doc = ""]
#[doc = " Structure representing PDF print settings."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_pdf_print_settings_t {
    #[doc = ""]
    #[doc = " Page title to display in the header. Only used if |header_footer_enabled|"]
    #[doc = " is set to true (1)."]
    #[doc = ""]
    pub header_footer_title: cef_string_t,
    #[doc = ""]
    #[doc = " URL to display in the footer. Only used if |header_footer_enabled| is set"]
    #[doc = " to true (1)."]
    #[doc = ""]
    pub header_footer_url: cef_string_t,
    #[doc = ""]
    #[doc = " Output page size in microns. If either of these values is less than or"]
    #[doc = " equal to zero then the default paper size (A4) will be used."]
    #[doc = ""]
    pub page_width: ::std::os::raw::c_int,
    pub page_height: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " The percentage to scale the PDF by before printing (e.g. 50 is 50%)."]
    #[doc = " If this value is less than or equal to zero the default value of 100"]
    #[doc = " will be used."]
    #[doc = ""]
    pub scale_factor: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Margins in points. Only used if |margin_type| is set to"]
    #[doc = " PDF_PRINT_MARGIN_CUSTOM."]
    #[doc = ""]
    pub margin_top: ::std::os::raw::c_int,
    pub margin_right: ::std::os::raw::c_int,
    pub margin_bottom: ::std::os::raw::c_int,
    pub margin_left: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Margin type."]
    #[doc = ""]
    pub margin_type: cef_pdf_print_margin_type_t,
    #[doc = ""]
    #[doc = " Set to true (1) to print headers and footers or false (0) to not print"]
    #[doc = " headers and footers."]
    #[doc = ""]
    pub header_footer_enabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to print the selection only or false (0) to print all."]
    #[doc = ""]
    pub selection_only: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) for landscape mode or false (0) for portrait mode."]
    #[doc = ""]
    pub landscape: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Set to true (1) to print background graphics or false (0) to not print"]
    #[doc = " background graphics."]
    #[doc = ""]
    pub backgrounds_enabled: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_pdf_print_settings_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_pdf_print_settings_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_pdf_print_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_pdf_print_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_pdf_print_settings_t))
    );
    fn test_field_header_footer_title() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).header_footer_title) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(header_footer_title)
            )
        );
    }
    test_field_header_footer_title();
    fn test_field_header_footer_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).header_footer_url) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(header_footer_url)
            )
        );
    }
    test_field_header_footer_url();
    fn test_field_page_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).page_width) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(page_width)
            )
        );
    }
    test_field_page_width();
    fn test_field_page_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).page_height) as usize - ptr as usize
            },
            52usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(page_height)
            )
        );
    }
    test_field_page_height();
    fn test_field_scale_factor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).scale_factor) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(scale_factor)
            )
        );
    }
    test_field_scale_factor();
    fn test_field_margin_top() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).margin_top) as usize - ptr as usize
            },
            60usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(margin_top)
            )
        );
    }
    test_field_margin_top();
    fn test_field_margin_right() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).margin_right) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(margin_right)
            )
        );
    }
    test_field_margin_right();
    fn test_field_margin_bottom() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).margin_bottom) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(margin_bottom)
            )
        );
    }
    test_field_margin_bottom();
    fn test_field_margin_left() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).margin_left) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(margin_left)
            )
        );
    }
    test_field_margin_left();
    fn test_field_margin_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).margin_type) as usize - ptr as usize
            },
            76usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(margin_type)
            )
        );
    }
    test_field_margin_type();
    fn test_field_header_footer_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).header_footer_enabled) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(header_footer_enabled)
            )
        );
    }
    test_field_header_footer_enabled();
    fn test_field_selection_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).selection_only) as usize - ptr as usize
            },
            84usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(selection_only)
            )
        );
    }
    test_field_selection_only();
    fn test_field_landscape() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).landscape) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(landscape)
            )
        );
    }
    test_field_landscape();
    fn test_field_backgrounds_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).backgrounds_enabled) as usize - ptr as usize
            },
            92usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_settings_t),
                "::",
                stringify!(backgrounds_enabled)
            )
        );
    }
    test_field_backgrounds_enabled();
}
#[doc = ""]
#[doc = " Structure representing PDF print settings."]
#[doc = ""]
pub type cef_pdf_print_settings_t = _cef_pdf_print_settings_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported UI scale factors for the platform. SCALE_FACTOR_NONE is used for"]
#[doc = " density independent resources such as string, html/js files or an image that"]
#[doc = " can be used for any scale factors (such as wallpapers)."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_scale_factor_t {
    SCALE_FACTOR_NONE = 0,
    SCALE_FACTOR_100P = 1,
    SCALE_FACTOR_125P = 2,
    SCALE_FACTOR_133P = 3,
    SCALE_FACTOR_140P = 4,
    SCALE_FACTOR_150P = 5,
    SCALE_FACTOR_180P = 6,
    SCALE_FACTOR_200P = 7,
    SCALE_FACTOR_250P = 8,
    SCALE_FACTOR_300P = 9,
}
impl cef_referrer_policy_t {
    pub const REFERRER_POLICY_DEFAULT: cef_referrer_policy_t =
        cef_referrer_policy_t::REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE;
}
impl cef_referrer_policy_t {
    pub const REFERRER_POLICY_LAST_VALUE: cef_referrer_policy_t =
        cef_referrer_policy_t::REFERRER_POLICY_NO_REFERRER;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Policy for how the Referrer HTTP header value will be sent during"]
#[doc = " navigation. If the `--no-referrers` command-line flag is specified then the"]
#[doc = " policy value will be ignored and the Referrer value will never be sent. Must"]
#[doc = " be kept synchronized with net::URLRequest::ReferrerPolicy from Chromium."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_referrer_policy_t {
    #[doc = ""]
    #[doc = " Clear the referrer header if the header value is HTTPS but the request"]
    #[doc = " destination is HTTP. This is the default behavior."]
    #[doc = ""]
    REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE = 0,
    #[doc = ""]
    #[doc = " A slight variant on CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE:"]
    #[doc = " If the request destination is HTTP, an HTTPS referrer will be cleared. If"]
    #[doc = " the request's destination is cross-origin with the referrer (but does not"]
    #[doc = " downgrade), the referrer's granularity will be stripped down to an origin"]
    #[doc = " rather than a full URL. Same-origin requests will send the full referrer."]
    #[doc = ""]
    REFERRER_POLICY_REDUCE_REFERRER_GRANULARITY_ON_TRANSITION_CROSS_ORIGIN = 1,
    #[doc = ""]
    #[doc = " Strip the referrer down to an origin when the origin of the referrer is"]
    #[doc = " different from the destination's origin."]
    #[doc = ""]
    REFERRER_POLICY_ORIGIN_ONLY_ON_TRANSITION_CROSS_ORIGIN = 2,
    #[doc = ""]
    #[doc = " Never change the referrer."]
    #[doc = ""]
    REFERRER_POLICY_NEVER_CLEAR_REFERRER = 3,
    #[doc = ""]
    #[doc = " Strip the referrer down to the origin regardless of the redirect location."]
    #[doc = ""]
    REFERRER_POLICY_ORIGIN = 4,
    #[doc = ""]
    #[doc = " Clear the referrer when the request's referrer is cross-origin with the"]
    #[doc = " request's destination."]
    #[doc = ""]
    REFERRER_POLICY_CLEAR_REFERRER_ON_TRANSITION_CROSS_ORIGIN = 5,
    #[doc = ""]
    #[doc = " Strip the referrer down to the origin, but clear it entirely if the"]
    #[doc = " referrer value is HTTPS and the destination is HTTP."]
    #[doc = ""]
    REFERRER_POLICY_ORIGIN_CLEAR_ON_TRANSITION_FROM_SECURE_TO_INSECURE = 6,
    #[doc = ""]
    #[doc = " Always clear the referrer regardless of the request destination."]
    #[doc = ""]
    REFERRER_POLICY_NO_REFERRER = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Return values for CefResponseFilter::Filter()."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_response_filter_status_t {
    #[doc = ""]
    #[doc = " Some or all of the pre-filter data was read successfully but more data is"]
    #[doc = " needed in order to continue filtering (filtered output is pending)."]
    #[doc = ""]
    RESPONSE_FILTER_NEED_MORE_DATA = 0,
    #[doc = ""]
    #[doc = " Some or all of the pre-filter data was read successfully and all available"]
    #[doc = " filtered output has been written."]
    #[doc = ""]
    RESPONSE_FILTER_DONE = 1,
    #[doc = ""]
    #[doc = " An error occurred during filtering."]
    #[doc = ""]
    RESPONSE_FILTER_ERROR = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Describes how to interpret the components of a pixel."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_color_type_t {
    #[doc = ""]
    #[doc = " RGBA with 8 bits per pixel (32bits total)."]
    #[doc = ""]
    CEF_COLOR_TYPE_RGBA_8888 = 0,
    #[doc = ""]
    #[doc = " BGRA with 8 bits per pixel (32bits total)."]
    #[doc = ""]
    CEF_COLOR_TYPE_BGRA_8888 = 1,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Describes how to interpret the alpha component of a pixel."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_alpha_type_t {
    #[doc = ""]
    #[doc = " No transparency. The alpha component is ignored."]
    #[doc = ""]
    CEF_ALPHA_TYPE_OPAQUE = 0,
    #[doc = ""]
    #[doc = " Transparency with pre-multiplied alpha component."]
    #[doc = ""]
    CEF_ALPHA_TYPE_PREMULTIPLIED = 1,
    #[doc = ""]
    #[doc = " Transparency with post-multiplied alpha component."]
    #[doc = ""]
    CEF_ALPHA_TYPE_POSTMULTIPLIED = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Text style types. Should be kepy in sync with gfx::TextStyle."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_text_style_t {
    CEF_TEXT_STYLE_BOLD = 0,
    CEF_TEXT_STYLE_ITALIC = 1,
    CEF_TEXT_STYLE_STRIKE = 2,
    CEF_TEXT_STYLE_DIAGONAL_STRIKE = 3,
    CEF_TEXT_STYLE_UNDERLINE = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Specifies where along the main axis the CefBoxLayout child views should be"]
#[doc = " laid out."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_main_axis_alignment_t {
    #[doc = ""]
    #[doc = " Child views will be left-aligned."]
    #[doc = ""]
    CEF_MAIN_AXIS_ALIGNMENT_START = 0,
    #[doc = ""]
    #[doc = " Child views will be center-aligned."]
    #[doc = ""]
    CEF_MAIN_AXIS_ALIGNMENT_CENTER = 1,
    #[doc = ""]
    #[doc = " Child views will be right-aligned."]
    #[doc = ""]
    CEF_MAIN_AXIS_ALIGNMENT_END = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Specifies where along the cross axis the CefBoxLayout child views should be"]
#[doc = " laid out."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_cross_axis_alignment_t {
    #[doc = ""]
    #[doc = " Child views will be stretched to fit."]
    #[doc = ""]
    CEF_CROSS_AXIS_ALIGNMENT_STRETCH = 0,
    #[doc = ""]
    #[doc = " Child views will be left-aligned."]
    #[doc = ""]
    CEF_CROSS_AXIS_ALIGNMENT_START = 1,
    #[doc = ""]
    #[doc = " Child views will be center-aligned."]
    #[doc = ""]
    CEF_CROSS_AXIS_ALIGNMENT_CENTER = 2,
    #[doc = ""]
    #[doc = " Child views will be right-aligned."]
    #[doc = ""]
    CEF_CROSS_AXIS_ALIGNMENT_END = 3,
}
#[doc = ""]
#[doc = " Settings used when initializing a CefBoxLayout."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_box_layout_settings_t {
    #[doc = ""]
    #[doc = " If true (1) the layout will be horizontal, otherwise the layout will be"]
    #[doc = " vertical."]
    #[doc = ""]
    pub horizontal: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Adds additional horizontal space between the child view area and the host"]
    #[doc = " view border."]
    #[doc = ""]
    pub inside_border_horizontal_spacing: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Adds additional vertical space between the child view area and the host"]
    #[doc = " view border."]
    #[doc = ""]
    pub inside_border_vertical_spacing: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Adds additional space around the child view area."]
    #[doc = ""]
    pub inside_border_insets: cef_insets_t,
    #[doc = ""]
    #[doc = " Adds additional space between child views."]
    #[doc = ""]
    pub between_child_spacing: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Specifies where along the main axis the child views should be laid out."]
    #[doc = ""]
    pub main_axis_alignment: cef_main_axis_alignment_t,
    #[doc = ""]
    #[doc = " Specifies where along the cross axis the child views should be laid out."]
    #[doc = ""]
    pub cross_axis_alignment: cef_cross_axis_alignment_t,
    #[doc = ""]
    #[doc = " Minimum cross axis size."]
    #[doc = ""]
    pub minimum_cross_axis_size: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Default flex for views when none is specified via CefBoxLayout methods."]
    #[doc = " Using the preferred size as the basis, free space along the main axis is"]
    #[doc = " distributed to views in the ratio of their flex weights. Similarly, if the"]
    #[doc = " views will overflow the parent, space is subtracted in these ratios. A"]
    #[doc = " flex of 0 means this view is not resized. Flex values must not be"]
    #[doc = " negative."]
    #[doc = ""]
    pub default_flex: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_box_layout_settings_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_box_layout_settings_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_box_layout_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_box_layout_settings_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_box_layout_settings_t))
    );
    fn test_field_horizontal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_box_layout_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).horizontal) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_box_layout_settings_t),
                "::",
                stringify!(horizontal)
            )
        );
    }
    test_field_horizontal();
    fn test_field_inside_border_horizontal_spacing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_box_layout_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inside_border_horizontal_spacing) as usize
                    - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_box_layout_settings_t),
                "::",
                stringify!(inside_border_horizontal_spacing)
            )
        );
    }
    test_field_inside_border_horizontal_spacing();
    fn test_field_inside_border_vertical_spacing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_box_layout_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inside_border_vertical_spacing) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_box_layout_settings_t),
                "::",
                stringify!(inside_border_vertical_spacing)
            )
        );
    }
    test_field_inside_border_vertical_spacing();
    fn test_field_inside_border_insets() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_box_layout_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).inside_border_insets) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_box_layout_settings_t),
                "::",
                stringify!(inside_border_insets)
            )
        );
    }
    test_field_inside_border_insets();
    fn test_field_between_child_spacing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_box_layout_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).between_child_spacing) as usize - ptr as usize
            },
            28usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_box_layout_settings_t),
                "::",
                stringify!(between_child_spacing)
            )
        );
    }
    test_field_between_child_spacing();
    fn test_field_main_axis_alignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_box_layout_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).main_axis_alignment) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_box_layout_settings_t),
                "::",
                stringify!(main_axis_alignment)
            )
        );
    }
    test_field_main_axis_alignment();
    fn test_field_cross_axis_alignment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_box_layout_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cross_axis_alignment) as usize - ptr as usize
            },
            36usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_box_layout_settings_t),
                "::",
                stringify!(cross_axis_alignment)
            )
        );
    }
    test_field_cross_axis_alignment();
    fn test_field_minimum_cross_axis_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_box_layout_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).minimum_cross_axis_size) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_box_layout_settings_t),
                "::",
                stringify!(minimum_cross_axis_size)
            )
        );
    }
    test_field_minimum_cross_axis_size();
    fn test_field_default_flex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_box_layout_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).default_flex) as usize - ptr as usize
            },
            44usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_box_layout_settings_t),
                "::",
                stringify!(default_flex)
            )
        );
    }
    test_field_default_flex();
}
#[doc = ""]
#[doc = " Settings used when initializing a CefBoxLayout."]
#[doc = ""]
pub type cef_box_layout_settings_t = _cef_box_layout_settings_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Specifies the button display state."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_button_state_t {
    CEF_BUTTON_STATE_NORMAL = 0,
    CEF_BUTTON_STATE_HOVERED = 1,
    CEF_BUTTON_STATE_PRESSED = 2,
    CEF_BUTTON_STATE_DISABLED = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Specifies the horizontal text alignment mode."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_horizontal_alignment_t {
    #[doc = ""]
    #[doc = " Align the text's left edge with that of its display area."]
    #[doc = ""]
    CEF_HORIZONTAL_ALIGNMENT_LEFT = 0,
    #[doc = ""]
    #[doc = " Align the text's center with that of its display area."]
    #[doc = ""]
    CEF_HORIZONTAL_ALIGNMENT_CENTER = 1,
    #[doc = ""]
    #[doc = " Align the text's right edge with that of its display area."]
    #[doc = ""]
    CEF_HORIZONTAL_ALIGNMENT_RIGHT = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Specifies how a menu will be anchored for non-RTL languages. The opposite"]
#[doc = " position will be used for RTL languages."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_menu_anchor_position_t {
    CEF_MENU_ANCHOR_TOPLEFT = 0,
    CEF_MENU_ANCHOR_TOPRIGHT = 1,
    CEF_MENU_ANCHOR_BOTTOMCENTER = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported color types for menu items."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_menu_color_type_t {
    CEF_MENU_COLOR_TEXT = 0,
    CEF_MENU_COLOR_TEXT_HOVERED = 1,
    CEF_MENU_COLOR_TEXT_ACCELERATOR = 2,
    CEF_MENU_COLOR_TEXT_ACCELERATOR_HOVERED = 3,
    CEF_MENU_COLOR_BACKGROUND = 4,
    CEF_MENU_COLOR_BACKGROUND_HOVERED = 5,
    CEF_MENU_COLOR_COUNT = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Supported SSL version values. See net/ssl/ssl_connection_status_flags.h"]
#[doc = " for more information."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_ssl_version_t {
    SSL_CONNECTION_VERSION_UNKNOWN = 0,
    SSL_CONNECTION_VERSION_SSL2 = 1,
    SSL_CONNECTION_VERSION_SSL3 = 2,
    SSL_CONNECTION_VERSION_TLS1 = 3,
    SSL_CONNECTION_VERSION_TLS1_1 = 4,
    SSL_CONNECTION_VERSION_TLS1_2 = 5,
    SSL_CONNECTION_VERSION_TLS1_3 = 6,
    SSL_CONNECTION_VERSION_QUIC = 7,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Supported SSL content status flags. See content/public/common/ssl_status.h"]
#[doc = " for more information."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_ssl_content_status_t {
    SSL_CONTENT_NORMAL_CONTENT = 0,
    SSL_CONTENT_DISPLAYED_INSECURE_CONTENT = 1,
    SSL_CONTENT_RAN_INSECURE_CONTENT = 2,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = " Configuration options for registering a custom scheme."]
#[doc = " These values are used when calling AddCustomScheme."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_scheme_options_t {
    CEF_SCHEME_OPTION_NONE = 0,
    #[doc = " For non-standard scheme URLs only the \"scheme:\" component is parsed and"]
    #[doc = " canonicalized. The remainder of the URL will be passed to the handler as-"]
    #[doc = " is. For example, \"scheme:///some%20text\" will remain the same."]
    #[doc = " Non-standard scheme URLs cannot be used as a target for form submission."]
    #[doc = ""]
    CEF_SCHEME_OPTION_STANDARD = 1,
    #[doc = ""]
    #[doc = " If CEF_SCHEME_OPTION_LOCAL is set the scheme will be treated with the same"]
    #[doc = " security rules as those applied to \"file\" URLs. Normal pages cannot link"]
    #[doc = " to or access local URLs. Also, by default, local URLs can only perform"]
    #[doc = " XMLHttpRequest calls to the same URL (origin + path) that originated the"]
    #[doc = " request. To allow XMLHttpRequest calls from a local URL to other URLs with"]
    #[doc = " the same origin set the CefSettings.file_access_from_file_urls_allowed"]
    #[doc = " value to true (1). To allow XMLHttpRequest calls from a local URL to all"]
    #[doc = " origins set the CefSettings.universal_access_from_file_urls_allowed value"]
    #[doc = " to true (1)."]
    #[doc = ""]
    CEF_SCHEME_OPTION_LOCAL = 2,
    #[doc = ""]
    #[doc = " If CEF_SCHEME_OPTION_DISPLAY_ISOLATED is set the scheme can only be"]
    #[doc = " displayed from other content hosted with the same scheme. For example,"]
    #[doc = " pages in other origins cannot create iframes or hyperlinks to URLs with"]
    #[doc = " the scheme. For schemes that must be accessible from other schemes don't"]
    #[doc = " set this, set CEF_SCHEME_OPTION_CORS_ENABLED, and use CORS"]
    #[doc = " \"Access-Control-Allow-Origin\" headers to further restrict access."]
    #[doc = ""]
    CEF_SCHEME_OPTION_DISPLAY_ISOLATED = 4,
    #[doc = ""]
    #[doc = " If CEF_SCHEME_OPTION_SECURE is set the scheme will be treated with the"]
    #[doc = " same security rules as those applied to \"https\" URLs. For example, loading"]
    #[doc = " this scheme from other secure schemes will not trigger mixed content"]
    #[doc = " warnings."]
    #[doc = ""]
    CEF_SCHEME_OPTION_SECURE = 8,
    #[doc = ""]
    #[doc = " If CEF_SCHEME_OPTION_CORS_ENABLED is set the scheme can be sent CORS"]
    #[doc = " requests. This value should be set in most cases where"]
    #[doc = " CEF_SCHEME_OPTION_STANDARD is set."]
    #[doc = ""]
    CEF_SCHEME_OPTION_CORS_ENABLED = 16,
    #[doc = ""]
    #[doc = " If CEF_SCHEME_OPTION_CSP_BYPASSING is set the scheme can bypass Content-"]
    #[doc = " Security-Policy (CSP) checks. This value should not be set in most cases"]
    #[doc = " where CEF_SCHEME_OPTION_STANDARD is set."]
    #[doc = ""]
    CEF_SCHEME_OPTION_CSP_BYPASSING = 32,
    #[doc = ""]
    #[doc = " If CEF_SCHEME_OPTION_FETCH_ENABLED is set the scheme can perform Fetch API"]
    #[doc = " requests."]
    #[doc = ""]
    CEF_SCHEME_OPTION_FETCH_ENABLED = 64,
}
#[doc = ""]
#[doc = " Structure representing a range."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_range_t {
    pub from: ::std::os::raw::c_int,
    pub to: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_range_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_range_t>(),
        8usize,
        concat!("Size of: ", stringify!(_cef_range_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_range_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_range_t))
    );
    fn test_field_from() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_range_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).from) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_range_t),
                "::",
                stringify!(from)
            )
        );
    }
    test_field_from();
    fn test_field_to() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_range_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).to) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_range_t),
                "::",
                stringify!(to)
            )
        );
    }
    test_field_to();
}
#[doc = ""]
#[doc = " Structure representing a range."]
#[doc = ""]
pub type cef_range_t = _cef_range_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Composition underline style."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_composition_underline_style_t {
    CEF_CUS_SOLID = 0,
    CEF_CUS_DOT = 1,
    CEF_CUS_DASH = 2,
    CEF_CUS_NONE = 3,
}
#[doc = ""]
#[doc = " Structure representing IME composition underline information. This is a thin"]
#[doc = " wrapper around Blink's WebCompositionUnderline class and should be kept in"]
#[doc = " sync with that."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_composition_underline_t {
    #[doc = ""]
    #[doc = " Underline character range."]
    #[doc = ""]
    pub range: cef_range_t,
    #[doc = ""]
    #[doc = " Text color."]
    #[doc = ""]
    pub color: cef_color_t,
    #[doc = ""]
    #[doc = " Background color."]
    #[doc = ""]
    pub background_color: cef_color_t,
    #[doc = ""]
    #[doc = " Set to true (1) for thick underline."]
    #[doc = ""]
    pub thick: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Style."]
    #[doc = ""]
    pub style: cef_composition_underline_style_t,
}
#[test]
fn bindgen_test_layout__cef_composition_underline_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_composition_underline_t>(),
        24usize,
        concat!("Size of: ", stringify!(_cef_composition_underline_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_composition_underline_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_composition_underline_t))
    );
    fn test_field_range() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_composition_underline_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).range) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_composition_underline_t),
                "::",
                stringify!(range)
            )
        );
    }
    test_field_range();
    fn test_field_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_composition_underline_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_composition_underline_t),
                "::",
                stringify!(color)
            )
        );
    }
    test_field_color();
    fn test_field_background_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_composition_underline_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).background_color) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_composition_underline_t),
                "::",
                stringify!(background_color)
            )
        );
    }
    test_field_background_color();
    fn test_field_thick() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_composition_underline_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).thick) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_composition_underline_t),
                "::",
                stringify!(thick)
            )
        );
    }
    test_field_thick();
    fn test_field_style() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_composition_underline_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).style) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_composition_underline_t),
                "::",
                stringify!(style)
            )
        );
    }
    test_field_style();
}
#[doc = ""]
#[doc = " Structure representing IME composition underline information. This is a thin"]
#[doc = " wrapper around Blink's WebCompositionUnderline class and should be kept in"]
#[doc = " sync with that."]
#[doc = ""]
pub type cef_composition_underline_t = _cef_composition_underline_t;
impl cef_channel_layout_t {
    pub const CEF_CHANNEL_LAYOUT_MAX: cef_channel_layout_t =
        cef_channel_layout_t::CEF_CHANNEL_LAYOUT_5_1_4_DOWNMIX;
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Enumerates the various representations of the ordering of audio channels."]
#[doc = " Must be kept synchronized with media::ChannelLayout from Chromium."]
#[doc = " See media\\base\\channel_layout.h"]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_channel_layout_t {
    CEF_CHANNEL_LAYOUT_NONE = 0,
    CEF_CHANNEL_LAYOUT_UNSUPPORTED = 1,
    #[doc = " Front C"]
    CEF_CHANNEL_LAYOUT_MONO = 2,
    #[doc = " Front L, Front R"]
    CEF_CHANNEL_LAYOUT_STEREO = 3,
    #[doc = " Front L, Front R, Back C"]
    CEF_CHANNEL_LAYOUT_2_1 = 4,
    #[doc = " Front L, Front R, Front C"]
    CEF_CHANNEL_LAYOUT_SURROUND = 5,
    #[doc = " Front L, Front R, Front C, Back C"]
    CEF_CHANNEL_LAYOUT_4_0 = 6,
    #[doc = " Front L, Front R, Side L, Side R"]
    CEF_CHANNEL_LAYOUT_2_2 = 7,
    #[doc = " Front L, Front R, Back L, Back R"]
    CEF_CHANNEL_LAYOUT_QUAD = 8,
    #[doc = " Front L, Front R, Front C, Side L, Side R"]
    CEF_CHANNEL_LAYOUT_5_0 = 9,
    #[doc = " Front L, Front R, Front C, LFE, Side L, Side R"]
    CEF_CHANNEL_LAYOUT_5_1 = 10,
    #[doc = " Front L, Front R, Front C, Back L, Back R"]
    CEF_CHANNEL_LAYOUT_5_0_BACK = 11,
    #[doc = " Front L, Front R, Front C, LFE, Back L, Back R"]
    CEF_CHANNEL_LAYOUT_5_1_BACK = 12,
    #[doc = " Front L, Front R, Front C, Side L, Side R, Back L, Back R"]
    CEF_CHANNEL_LAYOUT_7_0 = 13,
    #[doc = " Front L, Front R, Front C, LFE, Side L, Side R, Back L, Back R"]
    CEF_CHANNEL_LAYOUT_7_1 = 14,
    #[doc = " Front L, Front R, Front C, LFE, Side L, Side R, Front LofC, Front RofC"]
    CEF_CHANNEL_LAYOUT_7_1_WIDE = 15,
    #[doc = " Stereo L, Stereo R"]
    CEF_CHANNEL_LAYOUT_STEREO_DOWNMIX = 16,
    #[doc = " Stereo L, Stereo R, LFE"]
    CEF_CHANNEL_LAYOUT_2POINT1 = 17,
    #[doc = " Stereo L, Stereo R, Front C, LFE"]
    CEF_CHANNEL_LAYOUT_3_1 = 18,
    #[doc = " Stereo L, Stereo R, Front C, Rear C, LFE"]
    CEF_CHANNEL_LAYOUT_4_1 = 19,
    #[doc = " Stereo L, Stereo R, Front C, Side L, Side R, Back C"]
    CEF_CHANNEL_LAYOUT_6_0 = 20,
    #[doc = " Stereo L, Stereo R, Side L, Side R, Front LofC, Front RofC"]
    CEF_CHANNEL_LAYOUT_6_0_FRONT = 21,
    #[doc = " Stereo L, Stereo R, Front C, Rear L, Rear R, Rear C"]
    CEF_CHANNEL_LAYOUT_HEXAGONAL = 22,
    #[doc = " Stereo L, Stereo R, Front C, LFE, Side L, Side R, Rear Center"]
    CEF_CHANNEL_LAYOUT_6_1 = 23,
    #[doc = " Stereo L, Stereo R, Front C, LFE, Back L, Back R, Rear Center"]
    CEF_CHANNEL_LAYOUT_6_1_BACK = 24,
    #[doc = " Stereo L, Stereo R, Side L, Side R, Front LofC, Front RofC, LFE"]
    CEF_CHANNEL_LAYOUT_6_1_FRONT = 25,
    #[doc = " Front L, Front R, Front C, Side L, Side R, Front LofC, Front RofC"]
    CEF_CHANNEL_LAYOUT_7_0_FRONT = 26,
    #[doc = " Front L, Front R, Front C, LFE, Back L, Back R, Front LofC, Front RofC"]
    CEF_CHANNEL_LAYOUT_7_1_WIDE_BACK = 27,
    #[doc = " Front L, Front R, Front C, Side L, Side R, Rear L, Back R, Back C."]
    CEF_CHANNEL_LAYOUT_OCTAGONAL = 28,
    #[doc = " Channels are not explicitly mapped to speakers."]
    CEF_CHANNEL_LAYOUT_DISCRETE = 29,
    #[doc = " Front L, Front R, Front C. Front C contains the keyboard mic audio. This"]
    #[doc = " layout is only intended for input for WebRTC. The Front C channel"]
    #[doc = " is stripped away in the WebRTC audio input pipeline and never seen outside"]
    #[doc = " of that."]
    CEF_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC = 30,
    #[doc = " Front L, Front R, Side L, Side R, LFE"]
    CEF_CHANNEL_LAYOUT_4_1_QUAD_SIDE = 31,
    #[doc = " Actual channel layout is specified in the bitstream and the actual channel"]
    #[doc = " count is unknown at Chromium media pipeline level (useful for audio"]
    #[doc = " pass-through mode)."]
    CEF_CHANNEL_LAYOUT_BITSTREAM = 32,
    #[doc = " Front L, Front R, Front C, LFE, Side L, Side R,"]
    #[doc = " Front Height L, Front Height R, Rear Height L, Rear Height R"]
    #[doc = " Will be represented as six channels (5.1) due to eight channel limit"]
    #[doc = " kMaxConcurrentChannels"]
    CEF_CHANNEL_LAYOUT_5_1_4_DOWNMIX = 33,
}
#[doc = ""]
#[doc = " Structure representing the audio parameters for setting up the audio"]
#[doc = " handler."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_audio_parameters_t {
    #[doc = ""]
    #[doc = " Layout of the audio channels"]
    #[doc = ""]
    pub channel_layout: cef_channel_layout_t,
    #[doc = ""]
    #[doc = " Sample rate"]
    pub sample_rate: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Number of frames per buffer"]
    #[doc = ""]
    pub frames_per_buffer: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__cef_audio_parameters_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_audio_parameters_t>(),
        12usize,
        concat!("Size of: ", stringify!(_cef_audio_parameters_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_audio_parameters_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_audio_parameters_t))
    );
    fn test_field_channel_layout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_audio_parameters_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).channel_layout) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_audio_parameters_t),
                "::",
                stringify!(channel_layout)
            )
        );
    }
    test_field_channel_layout();
    fn test_field_sample_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_audio_parameters_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).sample_rate) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_audio_parameters_t),
                "::",
                stringify!(sample_rate)
            )
        );
    }
    test_field_sample_rate();
    fn test_field_frames_per_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_audio_parameters_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).frames_per_buffer) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_audio_parameters_t),
                "::",
                stringify!(frames_per_buffer)
            )
        );
    }
    test_field_frames_per_buffer();
}
#[doc = ""]
#[doc = " Structure representing the audio parameters for setting up the audio"]
#[doc = " handler."]
#[doc = ""]
pub type cef_audio_parameters_t = _cef_audio_parameters_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Result codes for CefMediaRouter::CreateRoute. Should be kept in sync with"]
#[doc = " Chromium's media_router::mojom::RouteRequestResultCode type."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_media_route_create_result_t {
    CEF_MRCR_UNKNOWN_ERROR = 0,
    CEF_MRCR_OK = 1,
    CEF_MRCR_TIMED_OUT = 2,
    CEF_MRCR_ROUTE_NOT_FOUND = 3,
    CEF_MRCR_SINK_NOT_FOUND = 4,
    CEF_MRCR_INVALID_ORIGIN = 5,
    CEF_MRCR_NO_SUPPORTED_PROVIDER = 7,
    CEF_MRCR_CANCELLED = 8,
    CEF_MRCR_ROUTE_ALREADY_EXISTS = 9,
    CEF_MRCR_ROUTE_ALREADY_TERMINATED = 11,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Connection state for a MediaRoute object."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_media_route_connection_state_t {
    CEF_MRCS_UNKNOWN = 0,
    CEF_MRCS_CONNECTING = 1,
    CEF_MRCS_CONNECTED = 2,
    CEF_MRCS_CLOSED = 3,
    CEF_MRCS_TERMINATED = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Icon types for a MediaSink object. Should be kept in sync with Chromium's"]
#[doc = " media_router::SinkIconType type."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_media_sink_icon_type_t {
    CEF_MSIT_CAST = 0,
    CEF_MSIT_CAST_AUDIO_GROUP = 1,
    CEF_MSIT_CAST_AUDIO = 2,
    CEF_MSIT_MEETING = 3,
    CEF_MSIT_HANGOUT = 4,
    CEF_MSIT_EDUCATION = 5,
    CEF_MSIT_WIRED_DISPLAY = 6,
    CEF_MSIT_GENERIC = 7,
    CEF_MSIT_TOTAL_COUNT = 8,
}
#[doc = ""]
#[doc = " Device information for a MediaSink object."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_sink_device_info_t {
    pub ip_address: cef_string_t,
    pub port: ::std::os::raw::c_int,
    pub model_name: cef_string_t,
}
#[test]
fn bindgen_test_layout__cef_media_sink_device_info_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_media_sink_device_info_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_media_sink_device_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_media_sink_device_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_sink_device_info_t))
    );
    fn test_field_ip_address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_device_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ip_address) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_device_info_t),
                "::",
                stringify!(ip_address)
            )
        );
    }
    test_field_ip_address();
    fn test_field_port() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_device_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_device_info_t),
                "::",
                stringify!(port)
            )
        );
    }
    test_field_port();
    fn test_field_model_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_device_info_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).model_name) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_device_info_t),
                "::",
                stringify!(model_name)
            )
        );
    }
    test_field_model_name();
}
#[doc = ""]
#[doc = " Device information for a MediaSink object."]
#[doc = ""]
pub type cef_media_sink_device_info_t = _cef_media_sink_device_info_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Represents commands available to TextField."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_text_field_commands_t {
    CEF_TFC_CUT = 1,
    CEF_TFC_COPY = 2,
    CEF_TFC_PASTE = 3,
    CEF_TFC_UNDO = 4,
    CEF_TFC_DELETE = 5,
    CEF_TFC_SELECT_ALL = 6,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Supported Chrome toolbar types."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_chrome_toolbar_type_t {
    CEF_CTT_NONE = 1,
    CEF_CTT_NORMAL = 2,
    CEF_CTT_LOCATION = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Docking modes supported by CefWindow::AddOverlay."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_docking_mode_t {
    CEF_DOCKING_MODE_TOP_LEFT = 1,
    CEF_DOCKING_MODE_TOP_RIGHT = 2,
    CEF_DOCKING_MODE_BOTTOM_LEFT = 3,
    CEF_DOCKING_MODE_BOTTOM_RIGHT = 4,
    CEF_DOCKING_MODE_CUSTOM = 5,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Show states supported by CefWindowDelegate::GetInitialShowState."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_show_state_t {
    CEF_SHOW_STATE_NORMAL = 1,
    CEF_SHOW_STATE_MINIMIZED = 2,
    CEF_SHOW_STATE_MAXIMIZED = 3,
    CEF_SHOW_STATE_FULLSCREEN = 4,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Values indicating what state of the touch handle is set."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_touch_handle_state_flags_t {
    CEF_THS_FLAG_NONE = 0,
    CEF_THS_FLAG_ENABLED = 1,
    CEF_THS_FLAG_ORIENTATION = 2,
    CEF_THS_FLAG_ORIGIN = 4,
    CEF_THS_FLAG_ALPHA = 8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_touch_handle_state_t {
    #[doc = ""]
    #[doc = " Touch handle id. Increments for each new touch handle."]
    #[doc = ""]
    pub touch_handle_id: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Combination of cef_touch_handle_state_flags_t values indicating what state"]
    #[doc = " is set."]
    #[doc = ""]
    pub flags: uint32,
    #[doc = ""]
    #[doc = " Enabled state. Only set if |flags| contains CEF_THS_FLAG_ENABLED."]
    #[doc = ""]
    pub enabled: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Orientation state. Only set if |flags| contains CEF_THS_FLAG_ORIENTATION."]
    #[doc = ""]
    pub orientation: cef_horizontal_alignment_t,
    pub mirror_vertical: ::std::os::raw::c_int,
    pub mirror_horizontal: ::std::os::raw::c_int,
    #[doc = ""]
    #[doc = " Origin state. Only set if |flags| contains CEF_THS_FLAG_ORIGIN."]
    #[doc = ""]
    pub origin: cef_point_t,
    #[doc = ""]
    #[doc = " Alpha state. Only set if |flags| contains CEF_THS_FLAG_ALPHA."]
    #[doc = ""]
    pub alpha: f32,
}
#[test]
fn bindgen_test_layout__cef_touch_handle_state_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_touch_handle_state_t>(),
        36usize,
        concat!("Size of: ", stringify!(_cef_touch_handle_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_touch_handle_state_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_cef_touch_handle_state_t))
    );
    fn test_field_touch_handle_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_handle_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).touch_handle_id) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_handle_state_t),
                "::",
                stringify!(touch_handle_id)
            )
        );
    }
    test_field_touch_handle_id();
    fn test_field_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_handle_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_handle_state_t),
                "::",
                stringify!(flags)
            )
        );
    }
    test_field_flags();
    fn test_field_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_handle_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_handle_state_t),
                "::",
                stringify!(enabled)
            )
        );
    }
    test_field_enabled();
    fn test_field_orientation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_handle_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).orientation) as usize - ptr as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_handle_state_t),
                "::",
                stringify!(orientation)
            )
        );
    }
    test_field_orientation();
    fn test_field_mirror_vertical() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_handle_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mirror_vertical) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_handle_state_t),
                "::",
                stringify!(mirror_vertical)
            )
        );
    }
    test_field_mirror_vertical();
    fn test_field_mirror_horizontal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_handle_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mirror_horizontal) as usize - ptr as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_handle_state_t),
                "::",
                stringify!(mirror_horizontal)
            )
        );
    }
    test_field_mirror_horizontal();
    fn test_field_origin() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_handle_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).origin) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_handle_state_t),
                "::",
                stringify!(origin)
            )
        );
    }
    test_field_origin();
    fn test_field_alpha() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_touch_handle_state_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_touch_handle_state_t),
                "::",
                stringify!(alpha)
            )
        );
    }
    test_field_alpha();
}
pub type cef_touch_handle_state_t = _cef_touch_handle_state_t;
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Media access permissions used by OnRequestMediaAccessPermission."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_media_access_permission_types_t {
    #[doc = ""]
    #[doc = " No permission."]
    #[doc = ""]
    CEF_MEDIA_PERMISSION_NONE = 0,
    #[doc = ""]
    #[doc = " Device audio capture permission."]
    #[doc = ""]
    CEF_MEDIA_PERMISSION_DEVICE_AUDIO_CAPTURE = 1,
    #[doc = ""]
    #[doc = " Device video capture permission."]
    #[doc = ""]
    CEF_MEDIA_PERMISSION_DEVICE_VIDEO_CAPTURE = 2,
    #[doc = ""]
    #[doc = " Desktop audio capture permission."]
    #[doc = ""]
    CEF_MEDIA_PERMISSION_DESKTOP_AUDIO_CAPTURE = 4,
    #[doc = ""]
    #[doc = " Desktop video capture permission."]
    #[doc = ""]
    CEF_MEDIA_PERMISSION_DESKTOP_VIDEO_CAPTURE = 8,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Permission types used with OnShowPermissionPrompt. Some types are"]
#[doc = " platform-specific or only supported with the Chrome runtime. Should be kept"]
#[doc = " in sync with Chromium's permissions::RequestType type."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_permission_request_types_t {
    CEF_PERMISSION_TYPE_NONE = 0,
    CEF_PERMISSION_TYPE_ACCESSIBILITY_EVENTS = 1,
    CEF_PERMISSION_TYPE_AR_SESSION = 2,
    CEF_PERMISSION_TYPE_CAMERA_PAN_TILT_ZOOM = 4,
    CEF_PERMISSION_TYPE_CAMERA_STREAM = 8,
    CEF_PERMISSION_TYPE_CLIPBOARD = 16,
    CEF_PERMISSION_TYPE_DISK_QUOTA = 32,
    CEF_PERMISSION_TYPE_LOCAL_FONTS = 64,
    CEF_PERMISSION_TYPE_GEOLOCATION = 128,
    CEF_PERMISSION_TYPE_IDLE_DETECTION = 256,
    CEF_PERMISSION_TYPE_MIC_STREAM = 512,
    CEF_PERMISSION_TYPE_MIDI_SYSEX = 1024,
    CEF_PERMISSION_TYPE_MULTIPLE_DOWNLOADS = 2048,
    CEF_PERMISSION_TYPE_NOTIFICATIONS = 4096,
    CEF_PERMISSION_TYPE_PROTECTED_MEDIA_IDENTIFIER = 8192,
    CEF_PERMISSION_TYPE_REGISTER_PROTOCOL_HANDLER = 16384,
    CEF_PERMISSION_TYPE_SECURITY_ATTESTATION = 32768,
    CEF_PERMISSION_TYPE_STORAGE_ACCESS = 65536,
    CEF_PERMISSION_TYPE_U2F_API_REQUEST = 131072,
    CEF_PERMISSION_TYPE_VR_SESSION = 262144,
    CEF_PERMISSION_TYPE_WINDOW_PLACEMENT = 524288,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Permission request results."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_permission_request_result_t {
    #[doc = ""]
    #[doc = " Accept the permission request as an explicit user action."]
    #[doc = ""]
    CEF_PERMISSION_RESULT_ACCEPT = 0,
    #[doc = ""]
    #[doc = " Deny the permission request as an explicit user action."]
    #[doc = ""]
    CEF_PERMISSION_RESULT_DENY = 1,
    #[doc = ""]
    #[doc = " Dismiss the permission request as an explicit user action."]
    #[doc = ""]
    CEF_PERMISSION_RESULT_DISMISS = 2,
    #[doc = ""]
    #[doc = " Ignore the permission request. If the prompt remains unhandled (e.g."]
    #[doc = " OnShowPermissionPrompt returns false and there is no default permissions"]
    #[doc = " UI) then any related promises may remain unresolved."]
    #[doc = ""]
    CEF_PERMISSION_RESULT_IGNORE = 3,
}
#[repr(u32)]
#[non_exhaustive]
#[doc = ""]
#[doc = " Certificate types supported by CefTestServer::CreateAndStart. The matching"]
#[doc = " certificate file must exist in the \"net/data/ssl/certificates\" directory."]
#[doc = " See CefSetDataDirectoryForTests() for related configuration."]
#[doc = ""]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum cef_test_cert_type_t {
    #[doc = " Valid certificate using the IP (127.0.0.1). Loads the \"ok_cert.pem\" file."]
    CEF_TEST_CERT_OK_IP = 0,
    #[doc = " Valid certificate using the domain (\"localhost\"). Loads the"]
    #[doc = " \"localhost_cert.pem\" file."]
    CEF_TEST_CERT_OK_DOMAIN = 1,
    #[doc = " Expired certificate. Loads the \"expired_cert.pem\" file."]
    CEF_TEST_CERT_EXPIRED = 2,
}
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_base_ref_counted_t {
    #[doc = ""]
    pub size: size_t,
    #[doc = ""]
    pub add_ref: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_base_ref_counted_t)>,
    #[doc = ""]
    pub release: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_base_ref_counted_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    pub has_one_ref: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_base_ref_counted_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    pub has_at_least_one_ref: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_base_ref_counted_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_base_ref_counted_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_base_ref_counted_t>(),
        40usize,
        concat!("Size of: ", stringify!(_cef_base_ref_counted_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_base_ref_counted_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_base_ref_counted_t))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_base_ref_counted_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_base_ref_counted_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_add_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_base_ref_counted_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_ref) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_base_ref_counted_t),
                "::",
                stringify!(add_ref)
            )
        );
    }
    test_field_add_ref();
    fn test_field_release() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_base_ref_counted_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_base_ref_counted_t),
                "::",
                stringify!(release)
            )
        );
    }
    test_field_release();
    fn test_field_has_one_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_base_ref_counted_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_one_ref) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_base_ref_counted_t),
                "::",
                stringify!(has_one_ref)
            )
        );
    }
    test_field_has_one_ref();
    fn test_field_has_at_least_one_ref() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_base_ref_counted_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_at_least_one_ref) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_base_ref_counted_t),
                "::",
                stringify!(has_at_least_one_ref)
            )
        );
    }
    test_field_has_at_least_one_ref();
}
#[doc = ""]
pub type cef_base_ref_counted_t = _cef_base_ref_counted_t;
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_base_scoped_t {
    #[doc = ""]
    pub size: size_t,
    #[doc = ""]
    pub del: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_base_scoped_t)>,
}
#[test]
fn bindgen_test_layout__cef_base_scoped_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_base_scoped_t>(),
        16usize,
        concat!("Size of: ", stringify!(_cef_base_scoped_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_base_scoped_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_base_scoped_t))
    );
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_base_scoped_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_base_scoped_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_del() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_base_scoped_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).del) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_base_scoped_t),
                "::",
                stringify!(del)
            )
        );
    }
    test_field_del();
}
#[doc = ""]
pub type cef_base_scoped_t = _cef_base_scoped_t;
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::AddDevToolsMessageObserver. The"]
#[doc = " functions of this structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_dev_tools_message_observer_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called on receipt of a DevTools protocol message."]
    #[doc = " |browser| is the originating browser instance. |message| is a UTF8-encoded"]
    #[doc = " JSON dictionary representing either a function result or an event."]
    #[doc = " |message| is only valid for the scope of this callback and should be"]
    #[doc = " copied if necessary. Return true (1) if the message was handled or false"]
    #[doc = " (0) if the message should be further processed and passed to the"]
    #[doc = " OnDevToolsMethodResult or OnDevToolsEvent functions as appropriate."]
    #[doc = ""]
    #[doc = " Method result dictionaries include an \"id\" (int) value that identifies the"]
    #[doc = " orginating function call sent from"]
    #[doc = " cef_browser_host_t::SendDevToolsMessage, and optionally either a \"result\""]
    #[doc = " (dictionary) or \"error\" (dictionary) value. The \"error\" dictionary will"]
    #[doc = " contain \"code\" (int) and \"message\" (string) values. Event dictionaries"]
    #[doc = " include a \"function\" (string) value and optionally a \"params\" (dictionary)"]
    #[doc = " value. See the DevTools protocol documentation at"]
    #[doc = " https://chromedevtools.github.io/devtools-protocol/ for details of"]
    #[doc = " supported function calls and the expected \"result\" or \"params\" dictionary"]
    #[doc = " contents. JSON dictionaries can be parsed using the CefParseJSON function"]
    #[doc = " if desired, however be aware of performance considerations when parsing"]
    #[doc = " large messages (some of which may exceed 1MB in size)."]
    #[doc = ""]
    pub on_dev_tools_message: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dev_tools_message_observer_t,
            browser: *mut _cef_browser_t,
            message: *const ::std::os::raw::c_void,
            message_size: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Method that will be called after attempted execution of a DevTools"]
    #[doc = " protocol function. |browser| is the originating browser instance."]
    #[doc = " |message_id| is the \"id\" value that identifies the originating function"]
    #[doc = " call message. If the function succeeded |success| will be true (1) and"]
    #[doc = " |result| will be the UTF8-encoded JSON \"result\" dictionary value (which"]
    #[doc = " may be NULL). If the function failed |success| will be false (0) and"]
    #[doc = " |result| will be the UTF8-encoded JSON \"error\" dictionary value. |result|"]
    #[doc = " is only valid for the scope of this callback and should be copied if"]
    #[doc = " necessary. See the OnDevToolsMessage documentation for additional details"]
    #[doc = " on |result| contents."]
    #[doc = ""]
    pub on_dev_tools_method_result: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dev_tools_message_observer_t,
            browser: *mut _cef_browser_t,
            message_id: ::std::os::raw::c_int,
            success: ::std::os::raw::c_int,
            result: *const ::std::os::raw::c_void,
            result_size: size_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Method that will be called on receipt of a DevTools protocol event."]
    #[doc = " |browser| is the originating browser instance. |function| is the"]
    #[doc = " \"function\" value. |params| is the UTF8-encoded JSON \"params\" dictionary"]
    #[doc = " value (which may be NULL). |params| is only valid for the scope of this"]
    #[doc = " callback and should be copied if necessary. See the OnDevToolsMessage"]
    #[doc = " documentation for additional details on |params| contents."]
    #[doc = ""]
    pub on_dev_tools_event: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dev_tools_message_observer_t,
            browser: *mut _cef_browser_t,
            method: *const cef_string_t,
            params: *const ::std::os::raw::c_void,
            params_size: size_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Method that will be called when the DevTools agent has attached. |browser|"]
    #[doc = " is the originating browser instance. This will generally occur in response"]
    #[doc = " to the first message sent while the agent is detached."]
    #[doc = ""]
    pub on_dev_tools_agent_attached: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dev_tools_message_observer_t,
            browser: *mut _cef_browser_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Method that will be called when the DevTools agent has detached. |browser|"]
    #[doc = " is the originating browser instance. Any function results that were"]
    #[doc = " pending before the agent became detached will not be delivered, and any"]
    #[doc = " active event subscriptions will be canceled."]
    #[doc = ""]
    pub on_dev_tools_agent_detached: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dev_tools_message_observer_t,
            browser: *mut _cef_browser_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_dev_tools_message_observer_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_dev_tools_message_observer_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_dev_tools_message_observer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_dev_tools_message_observer_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_dev_tools_message_observer_t)
        )
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dev_tools_message_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dev_tools_message_observer_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_dev_tools_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dev_tools_message_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_dev_tools_message) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dev_tools_message_observer_t),
                "::",
                stringify!(on_dev_tools_message)
            )
        );
    }
    test_field_on_dev_tools_message();
    fn test_field_on_dev_tools_method_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dev_tools_message_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_dev_tools_method_result) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dev_tools_message_observer_t),
                "::",
                stringify!(on_dev_tools_method_result)
            )
        );
    }
    test_field_on_dev_tools_method_result();
    fn test_field_on_dev_tools_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dev_tools_message_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_dev_tools_event) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dev_tools_message_observer_t),
                "::",
                stringify!(on_dev_tools_event)
            )
        );
    }
    test_field_on_dev_tools_event();
    fn test_field_on_dev_tools_agent_attached() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dev_tools_message_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_dev_tools_agent_attached) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dev_tools_message_observer_t),
                "::",
                stringify!(on_dev_tools_agent_attached)
            )
        );
    }
    test_field_on_dev_tools_agent_attached();
    fn test_field_on_dev_tools_agent_detached() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dev_tools_message_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_dev_tools_agent_detached) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dev_tools_message_observer_t),
                "::",
                stringify!(on_dev_tools_agent_detached)
            )
        );
    }
    test_field_on_dev_tools_agent_detached();
}
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::AddDevToolsMessageObserver. The"]
#[doc = " functions of this structure will be called on the browser process UI thread."]
#[doc = ""]
pub type cef_dev_tools_message_observer_t = _cef_dev_tools_message_observer_t;
#[doc = ""]
#[doc = " Structure that wraps other data value types. Complex types (binary,"]
#[doc = " dictionary and list) will be referenced but not owned by this object. Can be"]
#[doc = " used on any process and thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_value_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying data is valid. This will always be true"]
    #[doc = " (1) for simple types. For complex types (binary, dictionary and list) the"]
    #[doc = " underlying data may become invalid if owned by another object (e.g. list"]
    #[doc = " or dictionary) and that other object is then modified or destroyed. This"]
    #[doc = " value object can be re-used by calling Set*() even if the underlying data"]
    #[doc = " is invalid."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying data is owned by another object."]
    #[doc = ""]
    pub is_owned: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying data is read-only. Some APIs may expose"]
    #[doc = " read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have the same underlying"]
    #[doc = " data. If true (1) modifications to this object will also affect |that|"]
    #[doc = " object and vice-versa."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            that: *mut _cef_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have an equivalent"]
    #[doc = " underlying value but are not necessarily the same object."]
    #[doc = ""]
    pub is_equal: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            that: *mut _cef_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a copy of this object. The underlying data will also be copied."]
    #[doc = ""]
    pub copy:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_value_t>,
    #[doc = ""]
    #[doc = " Returns the underlying value type."]
    #[doc = ""]
    pub get_type:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_value_t) -> cef_value_type_t>,
    #[doc = ""]
    #[doc = " Returns the underlying value as type bool."]
    #[doc = ""]
    pub get_bool: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the underlying value as type int."]
    #[doc = ""]
    pub get_int: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the underlying value as type double."]
    #[doc = ""]
    pub get_double: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_value_t) -> f64>,
    #[doc = ""]
    #[doc = " Returns the underlying value as type string."]
    #[doc = ""]
    pub get_string: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the underlying value as type binary. The returned reference may"]
    #[doc = " become invalid if the value is owned by another object or if ownership is"]
    #[doc = " transferred to another object in the future. To maintain a reference to"]
    #[doc = " the value after assigning ownership to a dictionary or list pass this"]
    #[doc = " object to the set_value() function instead of passing the returned"]
    #[doc = " reference to set_binary()."]
    #[doc = ""]
    pub get_binary: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the underlying value as type dictionary. The returned reference"]
    #[doc = " may become invalid if the value is owned by another object or if ownership"]
    #[doc = " is transferred to another object in the future. To maintain a reference to"]
    #[doc = " the value after assigning ownership to a dictionary or list pass this"]
    #[doc = " object to the set_value() function instead of passing the returned"]
    #[doc = " reference to set_dictionary()."]
    #[doc = ""]
    pub get_dictionary: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the underlying value as type list. The returned reference may"]
    #[doc = " become invalid if the value is owned by another object or if ownership is"]
    #[doc = " transferred to another object in the future. To maintain a reference to"]
    #[doc = " the value after assigning ownership to a dictionary or list pass this"]
    #[doc = " object to the set_value() function instead of passing the returned"]
    #[doc = " reference to set_list()."]
    #[doc = ""]
    pub get_list: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> *mut _cef_list_value_t,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type null. Returns true (1) if the value was"]
    #[doc = " set successfully."]
    #[doc = ""]
    pub set_null: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type bool. Returns true (1) if the value was"]
    #[doc = " set successfully."]
    #[doc = ""]
    pub set_bool: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type int. Returns true (1) if the value was"]
    #[doc = " set successfully."]
    #[doc = ""]
    pub set_int: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type double. Returns true (1) if the value"]
    #[doc = " was set successfully."]
    #[doc = ""]
    pub set_double: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_value_t, value: f64) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type string. Returns true (1) if the value"]
    #[doc = " was set successfully."]
    #[doc = ""]
    pub set_string: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type binary. Returns true (1) if the value"]
    #[doc = " was set successfully. This object keeps a reference to |value| and"]
    #[doc = " ownership of the underlying data remains unchanged."]
    #[doc = ""]
    pub set_binary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *mut _cef_binary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type dict. Returns true (1) if the value was"]
    #[doc = " set successfully. This object keeps a reference to |value| and ownership"]
    #[doc = " of the underlying data remains unchanged."]
    #[doc = ""]
    pub set_dictionary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *mut _cef_dictionary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the underlying value as type list. Returns true (1) if the value was"]
    #[doc = " set successfully. This object keeps a reference to |value| and ownership"]
    #[doc = " of the underlying data remains unchanged."]
    #[doc = ""]
    pub set_list: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_value_t,
            value: *mut _cef_list_value_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_value_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_value_t>(),
        216usize,
        concat!("Size of: ", stringify!(_cef_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_value_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_is_owned() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_owned) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(is_owned)
            )
        );
    }
    test_field_is_owned();
    fn test_field_is_read_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(is_read_only)
            )
        );
    }
    test_field_is_read_only();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_is_equal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_equal) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(is_equal)
            )
        );
    }
    test_field_is_equal();
    fn test_field_copy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(copy)
            )
        );
    }
    test_field_copy();
    fn test_field_get_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(get_type)
            )
        );
    }
    test_field_get_type();
    fn test_field_get_bool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_bool) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(get_bool)
            )
        );
    }
    test_field_get_bool();
    fn test_field_get_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_int) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(get_int)
            )
        );
    }
    test_field_get_int();
    fn test_field_get_double() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_double) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(get_double)
            )
        );
    }
    test_field_get_double();
    fn test_field_get_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_string) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(get_string)
            )
        );
    }
    test_field_get_string();
    fn test_field_get_binary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_binary) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(get_binary)
            )
        );
    }
    test_field_get_binary();
    fn test_field_get_dictionary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_dictionary) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(get_dictionary)
            )
        );
    }
    test_field_get_dictionary();
    fn test_field_get_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_list) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(get_list)
            )
        );
    }
    test_field_get_list();
    fn test_field_set_null() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_null) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(set_null)
            )
        );
    }
    test_field_set_null();
    fn test_field_set_bool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_bool) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(set_bool)
            )
        );
    }
    test_field_set_bool();
    fn test_field_set_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_int) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(set_int)
            )
        );
    }
    test_field_set_int();
    fn test_field_set_double() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_double) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(set_double)
            )
        );
    }
    test_field_set_double();
    fn test_field_set_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_string) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(set_string)
            )
        );
    }
    test_field_set_string();
    fn test_field_set_binary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_binary) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(set_binary)
            )
        );
    }
    test_field_set_binary();
    fn test_field_set_dictionary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_dictionary) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(set_dictionary)
            )
        );
    }
    test_field_set_dictionary();
    fn test_field_set_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_list) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_value_t),
                "::",
                stringify!(set_list)
            )
        );
    }
    test_field_set_list();
}
#[doc = ""]
#[doc = " Structure that wraps other data value types. Complex types (binary,"]
#[doc = " dictionary and list) will be referenced but not owned by this object. Can be"]
#[doc = " used on any process and thread."]
#[doc = ""]
pub type cef_value_t = _cef_value_t;
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new object."]
    #[doc = ""]
    pub fn cef_value_create() -> *mut cef_value_t;
}
#[doc = ""]
#[doc = " Structure representing a binary value. Can be used on any process and"]
#[doc = " thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_binary_value_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. This object may become invalid"]
    #[doc = " if the underlying data is owned by another object (e.g. list or"]
    #[doc = " dictionary) and that other object is then modified or destroyed. Do not"]
    #[doc = " call any other functions if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is currently owned by another object."]
    #[doc = ""]
    pub is_owned: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have the same underlying"]
    #[doc = " data."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_binary_value_t,
            that: *mut _cef_binary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have an equivalent"]
    #[doc = " underlying value but are not necessarily the same object."]
    #[doc = ""]
    pub is_equal: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_binary_value_t,
            that: *mut _cef_binary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a copy of this object. The data in this object will also be"]
    #[doc = " copied."]
    #[doc = ""]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the data size."]
    #[doc = ""]
    pub get_size:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_binary_value_t) -> size_t>,
    #[doc = ""]
    #[doc = " Read up to |buffer_size| number of bytes into |buffer|. Reading begins at"]
    #[doc = " the specified byte |data_offset|. Returns the number of bytes read."]
    #[doc = ""]
    pub get_data: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_binary_value_t,
            buffer: *mut ::std::os::raw::c_void,
            buffer_size: size_t,
            data_offset: size_t,
        ) -> size_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_binary_value_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_binary_value_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_binary_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_binary_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_binary_value_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_binary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_binary_value_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_binary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_binary_value_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_is_owned() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_binary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_owned) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_binary_value_t),
                "::",
                stringify!(is_owned)
            )
        );
    }
    test_field_is_owned();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_binary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_binary_value_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_is_equal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_binary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_equal) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_binary_value_t),
                "::",
                stringify!(is_equal)
            )
        );
    }
    test_field_is_equal();
    fn test_field_copy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_binary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_binary_value_t),
                "::",
                stringify!(copy)
            )
        );
    }
    test_field_copy();
    fn test_field_get_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_binary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_size) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_binary_value_t),
                "::",
                stringify!(get_size)
            )
        );
    }
    test_field_get_size();
    fn test_field_get_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_binary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_data) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_binary_value_t),
                "::",
                stringify!(get_data)
            )
        );
    }
    test_field_get_data();
}
#[doc = ""]
#[doc = " Structure representing a binary value. Can be used on any process and"]
#[doc = " thread."]
#[doc = ""]
pub type cef_binary_value_t = _cef_binary_value_t;
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new object that is not owned by any other object. The specified"]
    #[doc = " |data| will be copied."]
    #[doc = ""]
    pub fn cef_binary_value_create(
        data: *const ::std::os::raw::c_void,
        data_size: size_t,
    ) -> *mut cef_binary_value_t;
}
#[doc = ""]
#[doc = " Structure representing a dictionary value. Can be used on any process and"]
#[doc = " thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_dictionary_value_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. This object may become invalid"]
    #[doc = " if the underlying data is owned by another object (e.g. list or"]
    #[doc = " dictionary) and that other object is then modified or destroyed. Do not"]
    #[doc = " call any other functions if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is currently owned by another object."]
    #[doc = ""]
    pub is_owned: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the values of this object are read-only. Some APIs may"]
    #[doc = " expose read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have the same underlying"]
    #[doc = " data. If true (1) modifications to this object will also affect |that|"]
    #[doc = " object and vice-versa."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            that: *mut _cef_dictionary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have an equivalent"]
    #[doc = " underlying value but are not necessarily the same object."]
    #[doc = ""]
    pub is_equal: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            that: *mut _cef_dictionary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a writable copy of this object. If |exclude_NULL_children| is true"]
    #[doc = " (1) any NULL dictionaries or lists will be excluded from the copy."]
    #[doc = ""]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            exclude_empty_children: ::std::os::raw::c_int,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the number of values."]
    #[doc = ""]
    pub get_size:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> size_t>,
    #[doc = ""]
    #[doc = " Removes all values. Returns true (1) on success."]
    #[doc = ""]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the current dictionary has a value for the given key."]
    #[doc = ""]
    pub has_key: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Reads all keys for this dictionary into the specified vector."]
    #[doc = ""]
    pub get_keys: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            keys: cef_string_list_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Removes the value at the specified key. Returns true (1) is the value was"]
    #[doc = " removed successfully."]
    #[doc = ""]
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value type for the specified key."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> cef_value_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key. For simple types the returned"]
    #[doc = " value will copy existing data and modifications to the value will not"]
    #[doc = " modify this object. For complex types (binary, dictionary and list) the"]
    #[doc = " returned value will reference existing data and modifications to the value"]
    #[doc = " will modify this object."]
    #[doc = ""]
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type bool."]
    #[doc = ""]
    pub get_bool: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type int."]
    #[doc = ""]
    pub get_int: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type double."]
    #[doc = ""]
    pub get_double: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_dictionary_value_t, key: *const cef_string_t) -> f64,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type string."]
    #[doc = ""]
    pub get_string: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type binary. The returned value"]
    #[doc = " will reference existing data."]
    #[doc = ""]
    pub get_binary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type dictionary. The returned"]
    #[doc = " value will reference existing data and modifications to the value will"]
    #[doc = " modify this object."]
    #[doc = ""]
    pub get_dictionary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified key as type list. The returned value"]
    #[doc = " will reference existing data and modifications to the value will modify"]
    #[doc = " this object."]
    #[doc = ""]
    pub get_list: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_list_value_t,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key. Returns true (1) if the value was set"]
    #[doc = " successfully. If |value| represents simple data then the underlying data"]
    #[doc = " will be copied and modifications to |value| will not modify this object."]
    #[doc = " If |value| represents complex data (binary, dictionary or list) then the"]
    #[doc = " underlying data will be referenced and modifications to |value| will"]
    #[doc = " modify this object."]
    #[doc = ""]
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type null. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_null: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type bool. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_bool: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type int. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_int: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type double. Returns true (1) if"]
    #[doc = " the value was set successfully."]
    #[doc = ""]
    pub set_double: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: f64,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type string. Returns true (1) if"]
    #[doc = " the value was set successfully."]
    #[doc = ""]
    pub set_string: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type binary. Returns true (1) if"]
    #[doc = " the value was set successfully. If |value| is currently owned by another"]
    #[doc = " object then the value will be copied and the |value| reference will not"]
    #[doc = " change. Otherwise, ownership will be transferred to this object and the"]
    #[doc = " |value| reference will be invalidated."]
    #[doc = ""]
    pub set_binary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_binary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type dict. Returns true (1) if the"]
    #[doc = " value was set successfully. If |value| is currently owned by another"]
    #[doc = " object then the value will be copied and the |value| reference will not"]
    #[doc = " change. Otherwise, ownership will be transferred to this object and the"]
    #[doc = " |value| reference will be invalidated."]
    #[doc = ""]
    pub set_dictionary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_dictionary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified key as type list. Returns true (1) if the"]
    #[doc = " value was set successfully. If |value| is currently owned by another"]
    #[doc = " object then the value will be copied and the |value| reference will not"]
    #[doc = " change. Otherwise, ownership will be transferred to this object and the"]
    #[doc = " |value| reference will be invalidated."]
    #[doc = ""]
    pub set_list: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dictionary_value_t,
            key: *const cef_string_t,
            value: *mut _cef_list_value_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_dictionary_value_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_dictionary_value_t>(),
        272usize,
        concat!("Size of: ", stringify!(_cef_dictionary_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_dictionary_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_dictionary_value_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_is_owned() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_owned) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(is_owned)
            )
        );
    }
    test_field_is_owned();
    fn test_field_is_read_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(is_read_only)
            )
        );
    }
    test_field_is_read_only();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_is_equal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_equal) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(is_equal)
            )
        );
    }
    test_field_is_equal();
    fn test_field_copy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(copy)
            )
        );
    }
    test_field_copy();
    fn test_field_get_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_size) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(get_size)
            )
        );
    }
    test_field_get_size();
    fn test_field_clear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clear) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(clear)
            )
        );
    }
    test_field_clear();
    fn test_field_has_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_key) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(has_key)
            )
        );
    }
    test_field_has_key();
    fn test_field_get_keys() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_keys) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(get_keys)
            )
        );
    }
    test_field_get_keys();
    fn test_field_remove() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(remove)
            )
        );
    }
    test_field_remove();
    fn test_field_get_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(get_type)
            )
        );
    }
    test_field_get_type();
    fn test_field_get_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(get_value)
            )
        );
    }
    test_field_get_value();
    fn test_field_get_bool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_bool) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(get_bool)
            )
        );
    }
    test_field_get_bool();
    fn test_field_get_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_int) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(get_int)
            )
        );
    }
    test_field_get_int();
    fn test_field_get_double() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_double) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(get_double)
            )
        );
    }
    test_field_get_double();
    fn test_field_get_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_string) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(get_string)
            )
        );
    }
    test_field_get_string();
    fn test_field_get_binary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_binary) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(get_binary)
            )
        );
    }
    test_field_get_binary();
    fn test_field_get_dictionary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_dictionary) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(get_dictionary)
            )
        );
    }
    test_field_get_dictionary();
    fn test_field_get_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_list) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(get_list)
            )
        );
    }
    test_field_get_list();
    fn test_field_set_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(set_value)
            )
        );
    }
    test_field_set_value();
    fn test_field_set_null() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_null) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(set_null)
            )
        );
    }
    test_field_set_null();
    fn test_field_set_bool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_bool) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(set_bool)
            )
        );
    }
    test_field_set_bool();
    fn test_field_set_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_int) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(set_int)
            )
        );
    }
    test_field_set_int();
    fn test_field_set_double() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_double) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(set_double)
            )
        );
    }
    test_field_set_double();
    fn test_field_set_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_string) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(set_string)
            )
        );
    }
    test_field_set_string();
    fn test_field_set_binary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_binary) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(set_binary)
            )
        );
    }
    test_field_set_binary();
    fn test_field_set_dictionary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_dictionary) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(set_dictionary)
            )
        );
    }
    test_field_set_dictionary();
    fn test_field_set_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dictionary_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_list) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dictionary_value_t),
                "::",
                stringify!(set_list)
            )
        );
    }
    test_field_set_list();
}
#[doc = ""]
#[doc = " Structure representing a dictionary value. Can be used on any process and"]
#[doc = " thread."]
#[doc = ""]
pub type cef_dictionary_value_t = _cef_dictionary_value_t;
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new object that is not owned by any other object."]
    #[doc = ""]
    pub fn cef_dictionary_value_create() -> *mut cef_dictionary_value_t;
}
#[doc = ""]
#[doc = " Structure representing a list value. Can be used on any process and thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_list_value_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. This object may become invalid"]
    #[doc = " if the underlying data is owned by another object (e.g. list or"]
    #[doc = " dictionary) and that other object is then modified or destroyed. Do not"]
    #[doc = " call any other functions if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is currently owned by another object."]
    #[doc = ""]
    pub is_owned: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the values of this object are read-only. Some APIs may"]
    #[doc = " expose read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have the same underlying"]
    #[doc = " data. If true (1) modifications to this object will also affect |that|"]
    #[doc = " object and vice-versa."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            that: *mut _cef_list_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object and |that| object have an equivalent"]
    #[doc = " underlying value but are not necessarily the same object."]
    #[doc = ""]
    pub is_equal: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            that: *mut _cef_list_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a writable copy of this object."]
    #[doc = ""]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> *mut _cef_list_value_t,
    >,
    #[doc = ""]
    #[doc = " Sets the number of values. If the number of values is expanded all new"]
    #[doc = " value slots will default to type null. Returns true (1) on success."]
    #[doc = ""]
    pub set_size: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, size: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the number of values."]
    #[doc = ""]
    pub get_size:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> size_t>,
    #[doc = ""]
    #[doc = " Removes all values. Returns true (1) on success."]
    #[doc = ""]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Removes the value at the specified index."]
    #[doc = ""]
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value type at the specified index."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: size_t) -> cef_value_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index. For simple types the returned"]
    #[doc = " value will copy existing data and modifications to the value will not"]
    #[doc = " modify this object. For complex types (binary, dictionary and list) the"]
    #[doc = " returned value will reference existing data and modifications to the value"]
    #[doc = " will modify this object."]
    #[doc = ""]
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: size_t) -> *mut _cef_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type bool."]
    #[doc = ""]
    pub get_bool: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type int."]
    #[doc = ""]
    pub get_int: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type double."]
    #[doc = ""]
    pub get_double: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: size_t) -> f64,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type string."]
    #[doc = ""]
    pub get_string: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: size_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type binary. The returned"]
    #[doc = " value will reference existing data."]
    #[doc = ""]
    pub get_binary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: size_t,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type dictionary. The returned"]
    #[doc = " value will reference existing data and modifications to the value will"]
    #[doc = " modify this object."]
    #[doc = ""]
    pub get_dictionary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: size_t,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value at the specified index as type list. The returned value"]
    #[doc = " will reference existing data and modifications to the value will modify"]
    #[doc = " this object."]
    #[doc = ""]
    pub get_list: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: size_t,
        ) -> *mut _cef_list_value_t,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index. Returns true (1) if the value was"]
    #[doc = " set successfully. If |value| represents simple data then the underlying"]
    #[doc = " data will be copied and modifications to |value| will not modify this"]
    #[doc = " object. If |value| represents complex data (binary, dictionary or list)"]
    #[doc = " then the underlying data will be referenced and modifications to |value|"]
    #[doc = " will modify this object."]
    #[doc = ""]
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: size_t,
            value: *mut _cef_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type null. Returns true (1) if"]
    #[doc = " the value was set successfully."]
    #[doc = ""]
    pub set_null: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_list_value_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type bool. Returns true (1) if"]
    #[doc = " the value was set successfully."]
    #[doc = ""]
    pub set_bool: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: size_t,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type int. Returns true (1) if the"]
    #[doc = " value was set successfully."]
    #[doc = ""]
    pub set_int: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: size_t,
            value: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type double. Returns true (1) if"]
    #[doc = " the value was set successfully."]
    #[doc = ""]
    pub set_double: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: size_t,
            value: f64,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type string. Returns true (1) if"]
    #[doc = " the value was set successfully."]
    #[doc = ""]
    pub set_string: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: size_t,
            value: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type binary. Returns true (1) if"]
    #[doc = " the value was set successfully. If |value| is currently owned by another"]
    #[doc = " object then the value will be copied and the |value| reference will not"]
    #[doc = " change. Otherwise, ownership will be transferred to this object and the"]
    #[doc = " |value| reference will be invalidated."]
    #[doc = ""]
    pub set_binary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: size_t,
            value: *mut _cef_binary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type dict. Returns true (1) if"]
    #[doc = " the value was set successfully. If |value| is currently owned by another"]
    #[doc = " object then the value will be copied and the |value| reference will not"]
    #[doc = " change. Otherwise, ownership will be transferred to this object and the"]
    #[doc = " |value| reference will be invalidated."]
    #[doc = ""]
    pub set_dictionary: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: size_t,
            value: *mut _cef_dictionary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the value at the specified index as type list. Returns true (1) if"]
    #[doc = " the value was set successfully. If |value| is currently owned by another"]
    #[doc = " object then the value will be copied and the |value| reference will not"]
    #[doc = " change. Otherwise, ownership will be transferred to this object and the"]
    #[doc = " |value| reference will be invalidated."]
    #[doc = ""]
    pub set_list: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_list_value_t,
            index: size_t,
            value: *mut _cef_list_value_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_list_value_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_list_value_t>(),
        264usize,
        concat!("Size of: ", stringify!(_cef_list_value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_list_value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_list_value_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_is_owned() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_owned) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(is_owned)
            )
        );
    }
    test_field_is_owned();
    fn test_field_is_read_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(is_read_only)
            )
        );
    }
    test_field_is_read_only();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_is_equal() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_equal) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(is_equal)
            )
        );
    }
    test_field_is_equal();
    fn test_field_copy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(copy)
            )
        );
    }
    test_field_copy();
    fn test_field_set_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_size) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(set_size)
            )
        );
    }
    test_field_set_size();
    fn test_field_get_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_size) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(get_size)
            )
        );
    }
    test_field_get_size();
    fn test_field_clear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clear) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(clear)
            )
        );
    }
    test_field_clear();
    fn test_field_remove() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(remove)
            )
        );
    }
    test_field_remove();
    fn test_field_get_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(get_type)
            )
        );
    }
    test_field_get_type();
    fn test_field_get_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(get_value)
            )
        );
    }
    test_field_get_value();
    fn test_field_get_bool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_bool) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(get_bool)
            )
        );
    }
    test_field_get_bool();
    fn test_field_get_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_int) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(get_int)
            )
        );
    }
    test_field_get_int();
    fn test_field_get_double() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_double) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(get_double)
            )
        );
    }
    test_field_get_double();
    fn test_field_get_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_string) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(get_string)
            )
        );
    }
    test_field_get_string();
    fn test_field_get_binary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_binary) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(get_binary)
            )
        );
    }
    test_field_get_binary();
    fn test_field_get_dictionary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_dictionary) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(get_dictionary)
            )
        );
    }
    test_field_get_dictionary();
    fn test_field_get_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_list) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(get_list)
            )
        );
    }
    test_field_get_list();
    fn test_field_set_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(set_value)
            )
        );
    }
    test_field_set_value();
    fn test_field_set_null() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_null) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(set_null)
            )
        );
    }
    test_field_set_null();
    fn test_field_set_bool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_bool) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(set_bool)
            )
        );
    }
    test_field_set_bool();
    fn test_field_set_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_int) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(set_int)
            )
        );
    }
    test_field_set_int();
    fn test_field_set_double() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_double) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(set_double)
            )
        );
    }
    test_field_set_double();
    fn test_field_set_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_string) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(set_string)
            )
        );
    }
    test_field_set_string();
    fn test_field_set_binary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_binary) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(set_binary)
            )
        );
    }
    test_field_set_binary();
    fn test_field_set_dictionary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_dictionary) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(set_dictionary)
            )
        );
    }
    test_field_set_dictionary();
    fn test_field_set_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_list_value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_list) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_list_value_t),
                "::",
                stringify!(set_list)
            )
        );
    }
    test_field_set_list();
}
#[doc = ""]
#[doc = " Structure representing a list value. Can be used on any process and thread."]
#[doc = ""]
pub type cef_list_value_t = _cef_list_value_t;
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new object that is not owned by any other object."]
    #[doc = ""]
    pub fn cef_list_value_create() -> *mut cef_list_value_t;
}
#[doc = ""]
#[doc = " Container for a single image represented at different scale factors. All"]
#[doc = " image representations should be the same size in density independent pixel"]
#[doc = " (DIP) units. For example, if the image at scale factor 1.0 is 100x100 pixels"]
#[doc = " then the image at scale factor 2.0 should be 200x200 pixels -- both images"]
#[doc = " will display with a DIP size of 100x100 units. The functions of this"]
#[doc = " structure can be called on any browser process thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_image_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this Image is NULL."]
    #[doc = ""]
    pub is_empty: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_image_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this Image and |that| Image share the same underlying"]
    #[doc = " storage. Will also return true (1) if both images are NULL."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            that: *mut _cef_image_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add a bitmap image representation for |scale_factor|. Only 32-bit"]
    #[doc = " RGBA/BGRA formats are supported. |pixel_width| and |pixel_height| are the"]
    #[doc = " bitmap representation size in pixel coordinates. |pixel_data| is the array"]
    #[doc = " of pixel data and should be |pixel_width| x |pixel_height| x 4 bytes in"]
    #[doc = " size. |color_type| and |alpha_type| values specify the pixel format."]
    #[doc = ""]
    pub add_bitmap: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            pixel_width: ::std::os::raw::c_int,
            pixel_height: ::std::os::raw::c_int,
            color_type: cef_color_type_t,
            alpha_type: cef_alpha_type_t,
            pixel_data: *const ::std::os::raw::c_void,
            pixel_data_size: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add a PNG image representation for |scale_factor|. |png_data| is the image"]
    #[doc = " data of size |png_data_size|. Any alpha transparency in the PNG data will"]
    #[doc = " be maintained."]
    #[doc = ""]
    pub add_png: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            png_data: *const ::std::os::raw::c_void,
            png_data_size: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Create a JPEG image representation for |scale_factor|. |jpeg_data| is the"]
    #[doc = " image data of size |jpeg_data_size|. The JPEG format does not support"]
    #[doc = " transparency so the alpha byte will be set to 0xFF for all pixels."]
    #[doc = ""]
    pub add_jpeg: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            jpeg_data: *const ::std::os::raw::c_void,
            jpeg_data_size: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the image width in density independent pixel (DIP) units."]
    #[doc = ""]
    pub get_width: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_image_t) -> size_t>,
    #[doc = ""]
    #[doc = " Returns the image height in density independent pixel (DIP) units."]
    #[doc = ""]
    pub get_height: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_image_t) -> size_t>,
    #[doc = ""]
    #[doc = " Returns true (1) if this image contains a representation for"]
    #[doc = " |scale_factor|."]
    #[doc = ""]
    pub has_representation: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_image_t, scale_factor: f32) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Removes the representation for |scale_factor|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub remove_representation: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_image_t, scale_factor: f32) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns information for the representation that most closely matches"]
    #[doc = " |scale_factor|. |actual_scale_factor| is the actual scale factor for the"]
    #[doc = " representation. |pixel_width| and |pixel_height| are the representation"]
    #[doc = " size in pixel coordinates. Returns true (1) on success."]
    #[doc = ""]
    pub get_representation_info: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            actual_scale_factor: *mut f32,
            pixel_width: *mut ::std::os::raw::c_int,
            pixel_height: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the bitmap representation that most closely matches"]
    #[doc = " |scale_factor|. Only 32-bit RGBA/BGRA formats are supported. |color_type|"]
    #[doc = " and |alpha_type| values specify the desired output pixel format."]
    #[doc = " |pixel_width| and |pixel_height| are the output representation size in"]
    #[doc = " pixel coordinates. Returns a cef_binary_value_t containing the pixel data"]
    #[doc = " on success or NULL on failure."]
    #[doc = ""]
    pub get_as_bitmap: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            color_type: cef_color_type_t,
            alpha_type: cef_alpha_type_t,
            pixel_width: *mut ::std::os::raw::c_int,
            pixel_height: *mut ::std::os::raw::c_int,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the PNG representation that most closely matches |scale_factor|."]
    #[doc = " If |with_transparency| is true (1) any alpha transparency in the image"]
    #[doc = " will be represented in the resulting PNG data. |pixel_width| and"]
    #[doc = " |pixel_height| are the output representation size in pixel coordinates."]
    #[doc = " Returns a cef_binary_value_t containing the PNG image data on success or"]
    #[doc = " NULL on failure."]
    #[doc = ""]
    pub get_as_png: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            with_transparency: ::std::os::raw::c_int,
            pixel_width: *mut ::std::os::raw::c_int,
            pixel_height: *mut ::std::os::raw::c_int,
        ) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the JPEG representation that most closely matches |scale_factor|."]
    #[doc = " |quality| determines the compression level with 0 == lowest and 100 =="]
    #[doc = " highest. The JPEG format does not support alpha transparency and the alpha"]
    #[doc = " channel, if any, will be discarded. |pixel_width| and |pixel_height| are"]
    #[doc = " the output representation size in pixel coordinates. Returns a"]
    #[doc = " cef_binary_value_t containing the JPEG image data on success or NULL on"]
    #[doc = " failure."]
    #[doc = ""]
    pub get_as_jpeg: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_image_t,
            scale_factor: f32,
            quality: ::std::os::raw::c_int,
            pixel_width: *mut ::std::os::raw::c_int,
            pixel_height: *mut ::std::os::raw::c_int,
        ) -> *mut _cef_binary_value_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_image_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_image_t>(),
        144usize,
        concat!("Size of: ", stringify!(_cef_image_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_image_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_image_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_empty() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_empty) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(is_empty)
            )
        );
    }
    test_field_is_empty();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_add_bitmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_bitmap) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(add_bitmap)
            )
        );
    }
    test_field_add_bitmap();
    fn test_field_add_png() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_png) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(add_png)
            )
        );
    }
    test_field_add_png();
    fn test_field_add_jpeg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_jpeg) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(add_jpeg)
            )
        );
    }
    test_field_add_jpeg();
    fn test_field_get_width() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_width) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(get_width)
            )
        );
    }
    test_field_get_width();
    fn test_field_get_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_height) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(get_height)
            )
        );
    }
    test_field_get_height();
    fn test_field_has_representation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_representation) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(has_representation)
            )
        );
    }
    test_field_has_representation();
    fn test_field_remove_representation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove_representation) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(remove_representation)
            )
        );
    }
    test_field_remove_representation();
    fn test_field_get_representation_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_representation_info) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(get_representation_info)
            )
        );
    }
    test_field_get_representation_info();
    fn test_field_get_as_bitmap() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_as_bitmap) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(get_as_bitmap)
            )
        );
    }
    test_field_get_as_bitmap();
    fn test_field_get_as_png() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_as_png) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(get_as_png)
            )
        );
    }
    test_field_get_as_png();
    fn test_field_get_as_jpeg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_image_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_as_jpeg) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_image_t),
                "::",
                stringify!(get_as_jpeg)
            )
        );
    }
    test_field_get_as_jpeg();
}
#[doc = ""]
#[doc = " Container for a single image represented at different scale factors. All"]
#[doc = " image representations should be the same size in density independent pixel"]
#[doc = " (DIP) units. For example, if the image at scale factor 1.0 is 100x100 pixels"]
#[doc = " then the image at scale factor 2.0 should be 200x200 pixels -- both images"]
#[doc = " will display with a DIP size of 100x100 units. The functions of this"]
#[doc = " structure can be called on any browser process thread."]
#[doc = ""]
pub type cef_image_t = _cef_image_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_image_t. It will initially be NULL. Use the Add*()"]
    #[doc = " functions to add representations at different scale factors."]
    #[doc = ""]
    pub fn cef_image_create() -> *mut cef_image_t;
}
#[doc = ""]
#[doc = " Structure the client can implement to provide a custom stream reader. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_read_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Read raw binary data."]
    #[doc = ""]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_read_handler_t,
            ptr: *mut ::std::os::raw::c_void,
            size: size_t,
            n: size_t,
        ) -> size_t,
    >,
    #[doc = ""]
    #[doc = " Seek to the specified offset position. |whence| may be any one of"]
    #[doc = " SEEK_CUR, SEEK_END or SEEK_SET. Return zero on success and non-zero on"]
    #[doc = " failure."]
    #[doc = ""]
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_read_handler_t,
            offset: int64,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the current offset position."]
    #[doc = ""]
    pub tell: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_read_handler_t) -> int64>,
    #[doc = ""]
    #[doc = " Return non-zero if at end of file."]
    #[doc = ""]
    pub eof: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_read_handler_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return true (1) if this handler performs work like accessing the file"]
    #[doc = " system which may block. Used as a hint for determining the thread to"]
    #[doc = " access the handler from."]
    #[doc = ""]
    pub may_block: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_read_handler_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_read_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_read_handler_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_read_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_read_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_read_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_read_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_read_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_read_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_read_handler_t),
                "::",
                stringify!(read)
            )
        );
    }
    test_field_read();
    fn test_field_seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_read_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_read_handler_t),
                "::",
                stringify!(seek)
            )
        );
    }
    test_field_seek();
    fn test_field_tell() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_read_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_read_handler_t),
                "::",
                stringify!(tell)
            )
        );
    }
    test_field_tell();
    fn test_field_eof() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_read_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eof) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_read_handler_t),
                "::",
                stringify!(eof)
            )
        );
    }
    test_field_eof();
    fn test_field_may_block() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_read_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).may_block) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_read_handler_t),
                "::",
                stringify!(may_block)
            )
        );
    }
    test_field_may_block();
}
#[doc = ""]
#[doc = " Structure the client can implement to provide a custom stream reader. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
pub type cef_read_handler_t = _cef_read_handler_t;
#[doc = ""]
#[doc = " Structure used to read data from a stream. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_stream_reader_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Read raw binary data."]
    #[doc = ""]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_reader_t,
            ptr: *mut ::std::os::raw::c_void,
            size: size_t,
            n: size_t,
        ) -> size_t,
    >,
    #[doc = ""]
    #[doc = " Seek to the specified offset position. |whence| may be any one of"]
    #[doc = " SEEK_CUR, SEEK_END or SEEK_SET. Returns zero on success and non-zero on"]
    #[doc = " failure."]
    #[doc = ""]
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_reader_t,
            offset: int64,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the current offset position."]
    #[doc = ""]
    pub tell:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_stream_reader_t) -> int64>,
    #[doc = ""]
    #[doc = " Return non-zero if at end of file."]
    #[doc = ""]
    pub eof: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_reader_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this reader performs work like accessing the file"]
    #[doc = " system which may block. Used as a hint for determining the thread to"]
    #[doc = " access the reader from."]
    #[doc = ""]
    pub may_block: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_reader_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_stream_reader_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_stream_reader_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_stream_reader_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_stream_reader_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_stream_reader_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_reader_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_reader_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_reader_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_reader_t),
                "::",
                stringify!(read)
            )
        );
    }
    test_field_read();
    fn test_field_seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_reader_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_reader_t),
                "::",
                stringify!(seek)
            )
        );
    }
    test_field_seek();
    fn test_field_tell() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_reader_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_reader_t),
                "::",
                stringify!(tell)
            )
        );
    }
    test_field_tell();
    fn test_field_eof() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_reader_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eof) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_reader_t),
                "::",
                stringify!(eof)
            )
        );
    }
    test_field_eof();
    fn test_field_may_block() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_reader_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).may_block) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_reader_t),
                "::",
                stringify!(may_block)
            )
        );
    }
    test_field_may_block();
}
#[doc = ""]
#[doc = " Structure used to read data from a stream. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
pub type cef_stream_reader_t = _cef_stream_reader_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_stream_reader_t object from a file."]
    #[doc = ""]
    pub fn cef_stream_reader_create_for_file(
        fileName: *const cef_string_t,
    ) -> *mut cef_stream_reader_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_stream_reader_t object from data."]
    #[doc = ""]
    pub fn cef_stream_reader_create_for_data(
        data: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> *mut cef_stream_reader_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_stream_reader_t object from a custom handler."]
    #[doc = ""]
    pub fn cef_stream_reader_create_for_handler(
        handler: *mut cef_read_handler_t,
    ) -> *mut cef_stream_reader_t;
}
#[doc = ""]
#[doc = " Structure the client can implement to provide a custom stream writer. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_write_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Write raw binary data."]
    #[doc = ""]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_write_handler_t,
            ptr: *const ::std::os::raw::c_void,
            size: size_t,
            n: size_t,
        ) -> size_t,
    >,
    #[doc = ""]
    #[doc = " Seek to the specified offset position. |whence| may be any one of"]
    #[doc = " SEEK_CUR, SEEK_END or SEEK_SET. Return zero on success and non-zero on"]
    #[doc = " failure."]
    #[doc = ""]
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_write_handler_t,
            offset: int64,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the current offset position."]
    #[doc = ""]
    pub tell:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_write_handler_t) -> int64>,
    #[doc = ""]
    #[doc = " Flush the stream."]
    #[doc = ""]
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_write_handler_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return true (1) if this handler performs work like accessing the file"]
    #[doc = " system which may block. Used as a hint for determining the thread to"]
    #[doc = " access the handler from."]
    #[doc = ""]
    pub may_block: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_write_handler_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_write_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_write_handler_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_write_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_write_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_write_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_write_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_write_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_write_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_write_handler_t),
                "::",
                stringify!(write)
            )
        );
    }
    test_field_write();
    fn test_field_seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_write_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_write_handler_t),
                "::",
                stringify!(seek)
            )
        );
    }
    test_field_seek();
    fn test_field_tell() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_write_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_write_handler_t),
                "::",
                stringify!(tell)
            )
        );
    }
    test_field_tell();
    fn test_field_flush() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_write_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_write_handler_t),
                "::",
                stringify!(flush)
            )
        );
    }
    test_field_flush();
    fn test_field_may_block() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_write_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).may_block) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_write_handler_t),
                "::",
                stringify!(may_block)
            )
        );
    }
    test_field_may_block();
}
#[doc = ""]
#[doc = " Structure the client can implement to provide a custom stream writer. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
pub type cef_write_handler_t = _cef_write_handler_t;
#[doc = ""]
#[doc = " Structure used to write data to a stream. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_stream_writer_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Write raw binary data."]
    #[doc = ""]
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_writer_t,
            ptr: *const ::std::os::raw::c_void,
            size: size_t,
            n: size_t,
        ) -> size_t,
    >,
    #[doc = ""]
    #[doc = " Seek to the specified offset position. |whence| may be any one of"]
    #[doc = " SEEK_CUR, SEEK_END or SEEK_SET. Returns zero on success and non-zero on"]
    #[doc = " failure."]
    #[doc = ""]
    pub seek: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_stream_writer_t,
            offset: int64,
            whence: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the current offset position."]
    #[doc = ""]
    pub tell:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_stream_writer_t) -> int64>,
    #[doc = ""]
    #[doc = " Flush the stream."]
    #[doc = ""]
    pub flush: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_writer_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this writer performs work like accessing the file"]
    #[doc = " system which may block. Used as a hint for determining the thread to"]
    #[doc = " access the writer from."]
    #[doc = ""]
    pub may_block: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_stream_writer_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_stream_writer_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_stream_writer_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_stream_writer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_stream_writer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_stream_writer_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_writer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_writer_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_writer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).write) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_writer_t),
                "::",
                stringify!(write)
            )
        );
    }
    test_field_write();
    fn test_field_seek() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_writer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).seek) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_writer_t),
                "::",
                stringify!(seek)
            )
        );
    }
    test_field_seek();
    fn test_field_tell() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_writer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).tell) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_writer_t),
                "::",
                stringify!(tell)
            )
        );
    }
    test_field_tell();
    fn test_field_flush() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_writer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flush) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_writer_t),
                "::",
                stringify!(flush)
            )
        );
    }
    test_field_flush();
    fn test_field_may_block() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_stream_writer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).may_block) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_stream_writer_t),
                "::",
                stringify!(may_block)
            )
        );
    }
    test_field_may_block();
}
#[doc = ""]
#[doc = " Structure used to write data to a stream. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
pub type cef_stream_writer_t = _cef_stream_writer_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_stream_writer_t object for a file."]
    #[doc = ""]
    pub fn cef_stream_writer_create_for_file(
        fileName: *const cef_string_t,
    ) -> *mut cef_stream_writer_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_stream_writer_t object for a custom handler."]
    #[doc = ""]
    pub fn cef_stream_writer_create_for_handler(
        handler: *mut cef_write_handler_t,
    ) -> *mut cef_stream_writer_t;
}
#[doc = ""]
#[doc = " Structure used to represent drag data. The functions of this structure may"]
#[doc = " be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_drag_data_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns a copy of the current object."]
    #[doc = ""]
    pub clone: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> *mut _cef_drag_data_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is read-only."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the drag data is a link."]
    #[doc = ""]
    pub is_link: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the drag data is a text or html fragment."]
    #[doc = ""]
    pub is_fragment: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the drag data is a file."]
    #[doc = ""]
    pub is_file: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the link URL that is being dragged."]
    #[doc = ""]
    pub get_link_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the title associated with the link being dragged."]
    #[doc = ""]
    pub get_link_title: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the metadata, if any, associated with the link being dragged."]
    #[doc = ""]
    pub get_link_metadata: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the plain text fragment that is being dragged."]
    #[doc = ""]
    pub get_fragment_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the text/html fragment that is being dragged."]
    #[doc = ""]
    pub get_fragment_html: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the base URL that the fragment came from. This value is used for"]
    #[doc = " resolving relative URLs and may be NULL."]
    #[doc = ""]
    pub get_fragment_base_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the name of the file being dragged out of the browser window."]
    #[doc = ""]
    pub get_file_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Write the contents of the file being dragged out of the web view into"]
    #[doc = " |writer|. Returns the number of bytes sent to |writer|. If |writer| is"]
    #[doc = " NULL this function will return the size of the file contents in bytes."]
    #[doc = " Call get_file_name() to get a suggested name for the file."]
    #[doc = ""]
    pub get_file_contents: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_data_t,
            writer: *mut _cef_stream_writer_t,
        ) -> size_t,
    >,
    #[doc = ""]
    #[doc = " Retrieve the list of file names that are being dragged into the browser"]
    #[doc = " window."]
    #[doc = ""]
    pub get_file_names: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_data_t,
            names: cef_string_list_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the link URL that is being dragged."]
    #[doc = ""]
    pub set_link_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the title associated with the link being dragged."]
    #[doc = ""]
    pub set_link_title: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, title: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the metadata associated with the link being dragged."]
    #[doc = ""]
    pub set_link_metadata: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, data: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the plain text fragment that is being dragged."]
    #[doc = ""]
    pub set_fragment_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, text: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the text/html fragment that is being dragged."]
    #[doc = ""]
    pub set_fragment_html: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, html: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the base URL that the fragment came from."]
    #[doc = ""]
    pub set_fragment_base_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t, base_url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Reset the file contents. You should do this before calling"]
    #[doc = " cef_browser_host_t::DragTargetDragEnter as the web view does not allow us"]
    #[doc = " to drag in this kind of data."]
    #[doc = ""]
    pub reset_file_contents:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_drag_data_t)>,
    #[doc = ""]
    #[doc = " Add a file that is being dragged into the webview."]
    #[doc = ""]
    pub add_file: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_data_t,
            path: *const cef_string_t,
            display_name: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Clear list of filenames."]
    #[doc = ""]
    pub clear_filenames: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_drag_data_t)>,
    #[doc = ""]
    #[doc = " Get the image representation of drag data. May return NULL if no image"]
    #[doc = " representation is available."]
    #[doc = ""]
    pub get_image: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> *mut _cef_image_t,
    >,
    #[doc = ""]
    #[doc = " Get the image hotspot (drag start location relative to image dimensions)."]
    #[doc = ""]
    pub get_image_hotspot:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> cef_point_t>,
    #[doc = ""]
    #[doc = " Returns true (1) if an image representation of drag data is available."]
    #[doc = ""]
    pub has_image: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_drag_data_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_drag_data_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_drag_data_t>(),
        248usize,
        concat!("Size of: ", stringify!(_cef_drag_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_drag_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_drag_data_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_clone() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clone) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(clone)
            )
        );
    }
    test_field_clone();
    fn test_field_is_read_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(is_read_only)
            )
        );
    }
    test_field_is_read_only();
    fn test_field_is_link() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_link) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(is_link)
            )
        );
    }
    test_field_is_link();
    fn test_field_is_fragment() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_fragment) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(is_fragment)
            )
        );
    }
    test_field_is_fragment();
    fn test_field_is_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_file) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(is_file)
            )
        );
    }
    test_field_is_file();
    fn test_field_get_link_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_link_url) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(get_link_url)
            )
        );
    }
    test_field_get_link_url();
    fn test_field_get_link_title() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_link_title) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(get_link_title)
            )
        );
    }
    test_field_get_link_title();
    fn test_field_get_link_metadata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_link_metadata) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(get_link_metadata)
            )
        );
    }
    test_field_get_link_metadata();
    fn test_field_get_fragment_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_fragment_text) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(get_fragment_text)
            )
        );
    }
    test_field_get_fragment_text();
    fn test_field_get_fragment_html() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_fragment_html) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(get_fragment_html)
            )
        );
    }
    test_field_get_fragment_html();
    fn test_field_get_fragment_base_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_fragment_base_url) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(get_fragment_base_url)
            )
        );
    }
    test_field_get_fragment_base_url();
    fn test_field_get_file_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_file_name) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(get_file_name)
            )
        );
    }
    test_field_get_file_name();
    fn test_field_get_file_contents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_file_contents) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(get_file_contents)
            )
        );
    }
    test_field_get_file_contents();
    fn test_field_get_file_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_file_names) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(get_file_names)
            )
        );
    }
    test_field_get_file_names();
    fn test_field_set_link_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_link_url) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(set_link_url)
            )
        );
    }
    test_field_set_link_url();
    fn test_field_set_link_title() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_link_title) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(set_link_title)
            )
        );
    }
    test_field_set_link_title();
    fn test_field_set_link_metadata() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_link_metadata) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(set_link_metadata)
            )
        );
    }
    test_field_set_link_metadata();
    fn test_field_set_fragment_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_fragment_text) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(set_fragment_text)
            )
        );
    }
    test_field_set_fragment_text();
    fn test_field_set_fragment_html() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_fragment_html) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(set_fragment_html)
            )
        );
    }
    test_field_set_fragment_html();
    fn test_field_set_fragment_base_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_fragment_base_url) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(set_fragment_base_url)
            )
        );
    }
    test_field_set_fragment_base_url();
    fn test_field_reset_file_contents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reset_file_contents) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(reset_file_contents)
            )
        );
    }
    test_field_reset_file_contents();
    fn test_field_add_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_file) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(add_file)
            )
        );
    }
    test_field_add_file();
    fn test_field_clear_filenames() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clear_filenames) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(clear_filenames)
            )
        );
    }
    test_field_clear_filenames();
    fn test_field_get_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_image) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(get_image)
            )
        );
    }
    test_field_get_image();
    fn test_field_get_image_hotspot() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_image_hotspot) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(get_image_hotspot)
            )
        );
    }
    test_field_get_image_hotspot();
    fn test_field_has_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_image) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_data_t),
                "::",
                stringify!(has_image)
            )
        );
    }
    test_field_has_image();
}
#[doc = ""]
#[doc = " Structure used to represent drag data. The functions of this structure may"]
#[doc = " be called on any thread."]
#[doc = ""]
pub type cef_drag_data_t = _cef_drag_data_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_drag_data_t object."]
    #[doc = ""]
    pub fn cef_drag_data_create() -> *mut cef_drag_data_t;
}
#[doc = ""]
#[doc = " Structure to implement for visiting the DOM. The functions of this structure"]
#[doc = " will be called on the render process main thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_domvisitor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method executed for visiting the DOM. The document object passed to this"]
    #[doc = " function represents a snapshot of the DOM at the time this function is"]
    #[doc = " executed. DOM objects are only valid for the scope of this function. Do"]
    #[doc = " not keep references to or attempt to access any DOM objects outside the"]
    #[doc = " scope of this function."]
    #[doc = ""]
    pub visit: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domvisitor_t, document: *mut _cef_domdocument_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_domvisitor_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_domvisitor_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_domvisitor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_domvisitor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_domvisitor_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domvisitor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domvisitor_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_visit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domvisitor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visit) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domvisitor_t),
                "::",
                stringify!(visit)
            )
        );
    }
    test_field_visit();
}
#[doc = ""]
#[doc = " Structure to implement for visiting the DOM. The functions of this structure"]
#[doc = " will be called on the render process main thread."]
#[doc = ""]
pub type cef_domvisitor_t = _cef_domvisitor_t;
#[doc = ""]
#[doc = " Structure used to represent a DOM document. The functions of this structure"]
#[doc = " should only be called on the render process main thread thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_domdocument_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the document type."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_dom_document_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the root document node."]
    #[doc = ""]
    pub get_document: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the BODY node of an HTML document."]
    #[doc = ""]
    pub get_body: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the HEAD node of an HTML document."]
    #[doc = ""]
    pub get_head: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the title of an HTML document."]
    #[doc = ""]
    pub get_title: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the document element with the specified ID value."]
    #[doc = ""]
    pub get_element_by_id: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domdocument_t,
            id: *const cef_string_t,
        ) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the node that currently has keyboard focus."]
    #[doc = ""]
    pub get_focused_node: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if a portion of the document is selected."]
    #[doc = ""]
    pub has_selection: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the selection offset within the start node."]
    #[doc = ""]
    pub get_selection_start_offset: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the selection offset within the end node."]
    #[doc = ""]
    pub get_selection_end_offset: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the contents of this selection as markup."]
    #[doc = ""]
    pub get_selection_as_markup: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the contents of this selection as text."]
    #[doc = ""]
    pub get_selection_as_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the base URL for the document."]
    #[doc = ""]
    pub get_base_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domdocument_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns a complete URL based on the document base URL and the specified"]
    #[doc = " partial URL."]
    #[doc = ""]
    pub get_complete_url: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domdocument_t,
            partialURL: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_domdocument_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_domdocument_t>(),
        152usize,
        concat!("Size of: ", stringify!(_cef_domdocument_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_domdocument_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_domdocument_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_type)
            )
        );
    }
    test_field_get_type();
    fn test_field_get_document() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_document) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_document)
            )
        );
    }
    test_field_get_document();
    fn test_field_get_body() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_body) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_body)
            )
        );
    }
    test_field_get_body();
    fn test_field_get_head() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_head) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_head)
            )
        );
    }
    test_field_get_head();
    fn test_field_get_title() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_title) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_title)
            )
        );
    }
    test_field_get_title();
    fn test_field_get_element_by_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_element_by_id) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_element_by_id)
            )
        );
    }
    test_field_get_element_by_id();
    fn test_field_get_focused_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_focused_node) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_focused_node)
            )
        );
    }
    test_field_get_focused_node();
    fn test_field_has_selection() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_selection) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(has_selection)
            )
        );
    }
    test_field_has_selection();
    fn test_field_get_selection_start_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_selection_start_offset) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_selection_start_offset)
            )
        );
    }
    test_field_get_selection_start_offset();
    fn test_field_get_selection_end_offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_selection_end_offset) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_selection_end_offset)
            )
        );
    }
    test_field_get_selection_end_offset();
    fn test_field_get_selection_as_markup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_selection_as_markup) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_selection_as_markup)
            )
        );
    }
    test_field_get_selection_as_markup();
    fn test_field_get_selection_as_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_selection_as_text) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_selection_as_text)
            )
        );
    }
    test_field_get_selection_as_text();
    fn test_field_get_base_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_base_url) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_base_url)
            )
        );
    }
    test_field_get_base_url();
    fn test_field_get_complete_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domdocument_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_complete_url) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domdocument_t),
                "::",
                stringify!(get_complete_url)
            )
        );
    }
    test_field_get_complete_url();
}
#[doc = ""]
#[doc = " Structure used to represent a DOM document. The functions of this structure"]
#[doc = " should only be called on the render process main thread thread."]
#[doc = ""]
pub type cef_domdocument_t = _cef_domdocument_t;
#[doc = ""]
#[doc = " Structure used to represent a DOM node. The functions of this structure"]
#[doc = " should only be called on the render process main thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_domnode_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the type for this node."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_dom_node_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is a text node."]
    #[doc = ""]
    pub is_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is an element node."]
    #[doc = ""]
    pub is_element: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is an editable node."]
    #[doc = ""]
    pub is_editable: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is a form control element node."]
    #[doc = ""]
    pub is_form_control_element: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the type of this form control element node."]
    #[doc = ""]
    pub get_form_control_element_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same handle as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            that: *mut _cef_domnode_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the name of this node."]
    #[doc = ""]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value of this node."]
    #[doc = ""]
    pub get_value: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the value of this node. Returns true (1) on success."]
    #[doc = ""]
    pub set_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            value: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the contents of this node as markup."]
    #[doc = ""]
    pub get_as_markup: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the document associated with this node."]
    #[doc = ""]
    pub get_document: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domdocument_t,
    >,
    #[doc = ""]
    #[doc = " Returns the parent node."]
    #[doc = ""]
    pub get_parent: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the previous sibling node."]
    #[doc = ""]
    pub get_previous_sibling: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the next sibling node."]
    #[doc = ""]
    pub get_next_sibling: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this node has child nodes."]
    #[doc = ""]
    pub has_children: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return the first child node."]
    #[doc = ""]
    pub get_first_child: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the last child node."]
    #[doc = ""]
    pub get_last_child: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> *mut _cef_domnode_t,
    >,
    #[doc = ""]
    #[doc = " Returns the tag name of this element."]
    #[doc = ""]
    pub get_element_tag_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this element has attributes."]
    #[doc = ""]
    pub has_element_attributes: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this element has an attribute named |attrName|."]
    #[doc = ""]
    pub has_element_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            attrName: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the element attribute named |attrName|."]
    #[doc = ""]
    pub get_element_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            attrName: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns a map of all element attributes."]
    #[doc = ""]
    pub get_element_attributes: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t, attrMap: cef_string_map_t),
    >,
    #[doc = ""]
    #[doc = " Set the value for the element attribute named |attrName|. Returns true (1)"]
    #[doc = " on success."]
    #[doc = ""]
    pub set_element_attribute: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_domnode_t,
            attrName: *const cef_string_t,
            value: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the inner text of the element."]
    #[doc = ""]
    pub get_element_inner_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the bounds of the element in device pixels. Use"]
    #[doc = " \"window.devicePixelRatio\" to convert to/from CSS pixels."]
    #[doc = ""]
    pub get_element_bounds:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_domnode_t) -> cef_rect_t>,
}
#[test]
fn bindgen_test_layout__cef_domnode_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_domnode_t>(),
        248usize,
        concat!("Size of: ", stringify!(_cef_domnode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_domnode_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_domnode_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_type)
            )
        );
    }
    test_field_get_type();
    fn test_field_is_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_text) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(is_text)
            )
        );
    }
    test_field_is_text();
    fn test_field_is_element() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_element) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(is_element)
            )
        );
    }
    test_field_is_element();
    fn test_field_is_editable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_editable) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(is_editable)
            )
        );
    }
    test_field_is_editable();
    fn test_field_is_form_control_element() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_form_control_element) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(is_form_control_element)
            )
        );
    }
    test_field_is_form_control_element();
    fn test_field_get_form_control_element_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_form_control_element_type) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_form_control_element_type)
            )
        );
    }
    test_field_get_form_control_element_type();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_get_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_name)
            )
        );
    }
    test_field_get_name();
    fn test_field_get_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_value) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_value)
            )
        );
    }
    test_field_get_value();
    fn test_field_set_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_value) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(set_value)
            )
        );
    }
    test_field_set_value();
    fn test_field_get_as_markup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_as_markup) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_as_markup)
            )
        );
    }
    test_field_get_as_markup();
    fn test_field_get_document() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_document) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_document)
            )
        );
    }
    test_field_get_document();
    fn test_field_get_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_parent) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_parent)
            )
        );
    }
    test_field_get_parent();
    fn test_field_get_previous_sibling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_previous_sibling) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_previous_sibling)
            )
        );
    }
    test_field_get_previous_sibling();
    fn test_field_get_next_sibling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_next_sibling) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_next_sibling)
            )
        );
    }
    test_field_get_next_sibling();
    fn test_field_has_children() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_children) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(has_children)
            )
        );
    }
    test_field_has_children();
    fn test_field_get_first_child() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_first_child) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_first_child)
            )
        );
    }
    test_field_get_first_child();
    fn test_field_get_last_child() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_last_child) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_last_child)
            )
        );
    }
    test_field_get_last_child();
    fn test_field_get_element_tag_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_element_tag_name) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_element_tag_name)
            )
        );
    }
    test_field_get_element_tag_name();
    fn test_field_has_element_attributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_element_attributes) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(has_element_attributes)
            )
        );
    }
    test_field_has_element_attributes();
    fn test_field_has_element_attribute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_element_attribute) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(has_element_attribute)
            )
        );
    }
    test_field_has_element_attribute();
    fn test_field_get_element_attribute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_element_attribute) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_element_attribute)
            )
        );
    }
    test_field_get_element_attribute();
    fn test_field_get_element_attributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_element_attributes) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_element_attributes)
            )
        );
    }
    test_field_get_element_attributes();
    fn test_field_set_element_attribute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_element_attribute) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(set_element_attribute)
            )
        );
    }
    test_field_set_element_attribute();
    fn test_field_get_element_inner_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_element_inner_text) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_element_inner_text)
            )
        );
    }
    test_field_get_element_inner_text();
    fn test_field_get_element_bounds() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_domnode_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_element_bounds) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_domnode_t),
                "::",
                stringify!(get_element_bounds)
            )
        );
    }
    test_field_get_element_bounds();
}
#[doc = ""]
#[doc = " Structure used to represent a DOM node. The functions of this structure"]
#[doc = " should only be called on the render process main thread."]
#[doc = ""]
pub type cef_domnode_t = _cef_domnode_t;
#[doc = ""]
#[doc = " Structure that wraps platform-dependent share memory region mapping."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_shared_memory_region_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if the mapping is valid."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_shared_memory_region_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the size of the mapping in bytes. Returns 0 for invalid instances."]
    #[doc = ""]
    pub size: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_shared_memory_region_t) -> size_t,
    >,
    #[doc = ""]
    #[doc = " Returns the pointer to the memory. Returns nullptr for invalid instances."]
    #[doc = " The returned pointer is only valid for the life span of this object."]
    #[doc = ""]
    pub memory: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_shared_memory_region_t,
        ) -> *const ::std::os::raw::c_void,
    >,
}
#[test]
fn bindgen_test_layout__cef_shared_memory_region_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_shared_memory_region_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_shared_memory_region_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_shared_memory_region_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_shared_memory_region_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_shared_memory_region_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_shared_memory_region_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_shared_memory_region_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_shared_memory_region_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_shared_memory_region_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_shared_memory_region_t),
                "::",
                stringify!(size)
            )
        );
    }
    test_field_size();
    fn test_field_memory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_shared_memory_region_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memory) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_shared_memory_region_t),
                "::",
                stringify!(memory)
            )
        );
    }
    test_field_memory();
}
#[doc = ""]
#[doc = " Structure that wraps platform-dependent share memory region mapping."]
#[doc = ""]
pub type cef_shared_memory_region_t = _cef_shared_memory_region_t;
#[doc = ""]
#[doc = " Structure representing a message. Can be used on any process and thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_process_message_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. Do not call any other functions"]
    #[doc = " if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the values of this object are read-only. Some APIs may"]
    #[doc = " expose read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a writable copy of this object. Returns nullptr when message"]
    #[doc = " contains a shared memory region."]
    #[doc = ""]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> *mut _cef_process_message_t,
    >,
    #[doc = ""]
    #[doc = " Returns the message name."]
    #[doc = ""]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the list of arguments. Returns nullptr when message contains a"]
    #[doc = " shared memory region."]
    #[doc = ""]
    pub get_argument_list: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_process_message_t) -> *mut _cef_list_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the shared memory region. Returns nullptr when message contains an"]
    #[doc = " argument list."]
    #[doc = ""]
    pub get_shared_memory_region: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_process_message_t,
        ) -> *mut _cef_shared_memory_region_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_process_message_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_process_message_t>(),
        88usize,
        concat!("Size of: ", stringify!(_cef_process_message_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_process_message_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_process_message_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_process_message_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_process_message_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_process_message_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_process_message_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_is_read_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_process_message_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_process_message_t),
                "::",
                stringify!(is_read_only)
            )
        );
    }
    test_field_is_read_only();
    fn test_field_copy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_process_message_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_process_message_t),
                "::",
                stringify!(copy)
            )
        );
    }
    test_field_copy();
    fn test_field_get_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_process_message_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_process_message_t),
                "::",
                stringify!(get_name)
            )
        );
    }
    test_field_get_name();
    fn test_field_get_argument_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_process_message_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_argument_list) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_process_message_t),
                "::",
                stringify!(get_argument_list)
            )
        );
    }
    test_field_get_argument_list();
    fn test_field_get_shared_memory_region() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_process_message_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_shared_memory_region) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_process_message_t),
                "::",
                stringify!(get_shared_memory_region)
            )
        );
    }
    test_field_get_shared_memory_region();
}
#[doc = ""]
#[doc = " Structure representing a message. Can be used on any process and thread."]
#[doc = ""]
pub type cef_process_message_t = _cef_process_message_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_process_message_t object with the specified name."]
    #[doc = ""]
    pub fn cef_process_message_create(name: *const cef_string_t) -> *mut cef_process_message_t;
}
#[doc = ""]
#[doc = " Structure used to represent a web request. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is read-only."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Get the fully qualified URL."]
    #[doc = ""]
    pub get_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the fully qualified URL."]
    #[doc = ""]
    pub set_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Get the request function type. The value will default to POST if post data"]
    #[doc = " is provided and GET otherwise."]
    #[doc = ""]
    pub get_method: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the request function type."]
    #[doc = ""]
    pub set_method: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, method: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Set the referrer URL and policy. If non-NULL the referrer URL must be"]
    #[doc = " fully qualified with an HTTP or HTTPS scheme component. Any username,"]
    #[doc = " password or ref component will be removed."]
    #[doc = ""]
    pub set_referrer: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_t,
            referrer_url: *const cef_string_t,
            policy: cef_referrer_policy_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Get the referrer URL."]
    #[doc = ""]
    pub get_referrer_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Get the referrer policy."]
    #[doc = ""]
    pub get_referrer_policy: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_referrer_policy_t,
    >,
    #[doc = ""]
    #[doc = " Get the post data."]
    #[doc = ""]
    pub get_post_data: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> *mut _cef_post_data_t,
    >,
    #[doc = ""]
    #[doc = " Set the post data."]
    #[doc = ""]
    pub set_post_data: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, postData: *mut _cef_post_data_t),
    >,
    #[doc = ""]
    #[doc = " Get the header values. Will not include the Referer value if any."]
    #[doc = ""]
    pub get_header_map: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, headerMap: cef_string_multimap_t),
    >,
    #[doc = ""]
    #[doc = " Set the header values. If a Referer value exists in the header map it will"]
    #[doc = " be removed and ignored."]
    #[doc = ""]
    pub set_header_map: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, headerMap: cef_string_multimap_t),
    >,
    #[doc = ""]
    #[doc = " Returns the first header value for |name| or an NULL string if not found."]
    #[doc = " Will not return the Referer value if any. Use GetHeaderMap instead if"]
    #[doc = " |name| might have multiple values."]
    #[doc = ""]
    pub get_header_by_name: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_t,
            name: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the header |name| to |value|. If |overwrite| is true (1) any existing"]
    #[doc = " values will be replaced with the new value. If |overwrite| is false (0)"]
    #[doc = " any existing values will not be overwritten. The Referer value cannot be"]
    #[doc = " set using this function."]
    #[doc = ""]
    pub set_header_by_name: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_t,
            name: *const cef_string_t,
            value: *const cef_string_t,
            overwrite: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Set all values at one time."]
    #[doc = ""]
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_t,
            url: *const cef_string_t,
            method: *const cef_string_t,
            postData: *mut _cef_post_data_t,
            headerMap: cef_string_multimap_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Get the flags used in combination with cef_urlrequest_t. See"]
    #[doc = " cef_urlrequest_flags_t for supported values."]
    #[doc = ""]
    pub get_flags: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the flags used in combination with cef_urlrequest_t.  See"]
    #[doc = " cef_urlrequest_flags_t for supported values."]
    #[doc = ""]
    pub set_flags: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, flags: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Get the URL to the first party for cookies used in combination with"]
    #[doc = " cef_urlrequest_t."]
    #[doc = ""]
    pub get_first_party_for_cookies: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the URL to the first party for cookies used in combination with"]
    #[doc = " cef_urlrequest_t."]
    #[doc = ""]
    pub set_first_party_for_cookies: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t, url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Get the resource type for this request. Only available in the browser"]
    #[doc = " process."]
    #[doc = ""]
    pub get_resource_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_resource_type_t,
    >,
    #[doc = ""]
    #[doc = " Get the transition type for this request. Only available in the browser"]
    #[doc = " process and only applies to requests that represent a main frame or sub-"]
    #[doc = " frame navigation."]
    #[doc = ""]
    pub get_transition_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_t) -> cef_transition_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the globally unique identifier for this request or 0 if not"]
    #[doc = " specified. Can be used by cef_resource_request_handler_t implementations"]
    #[doc = " in the browser process to track a single request across multiple"]
    #[doc = " callbacks."]
    #[doc = ""]
    pub get_identifier:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_request_t) -> uint64>,
}
#[test]
fn bindgen_test_layout__cef_request_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_request_t>(),
        216usize,
        concat!("Size of: ", stringify!(_cef_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_request_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_request_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_read_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(is_read_only)
            )
        );
    }
    test_field_is_read_only();
    fn test_field_get_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_url) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_url)
            )
        );
    }
    test_field_get_url();
    fn test_field_set_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_url) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(set_url)
            )
        );
    }
    test_field_set_url();
    fn test_field_get_method() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_method) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_method)
            )
        );
    }
    test_field_get_method();
    fn test_field_set_method() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_method) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(set_method)
            )
        );
    }
    test_field_set_method();
    fn test_field_set_referrer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_referrer) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(set_referrer)
            )
        );
    }
    test_field_set_referrer();
    fn test_field_get_referrer_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_referrer_url) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_referrer_url)
            )
        );
    }
    test_field_get_referrer_url();
    fn test_field_get_referrer_policy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_referrer_policy) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_referrer_policy)
            )
        );
    }
    test_field_get_referrer_policy();
    fn test_field_get_post_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_post_data) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_post_data)
            )
        );
    }
    test_field_get_post_data();
    fn test_field_set_post_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_post_data) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(set_post_data)
            )
        );
    }
    test_field_set_post_data();
    fn test_field_get_header_map() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_header_map) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_header_map)
            )
        );
    }
    test_field_get_header_map();
    fn test_field_set_header_map() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_header_map) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(set_header_map)
            )
        );
    }
    test_field_set_header_map();
    fn test_field_get_header_by_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_header_by_name) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_header_by_name)
            )
        );
    }
    test_field_get_header_by_name();
    fn test_field_set_header_by_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_header_by_name) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(set_header_by_name)
            )
        );
    }
    test_field_set_header_by_name();
    fn test_field_set() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(set)
            )
        );
    }
    test_field_set();
    fn test_field_get_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_flags) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_flags)
            )
        );
    }
    test_field_get_flags();
    fn test_field_set_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_flags) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(set_flags)
            )
        );
    }
    test_field_set_flags();
    fn test_field_get_first_party_for_cookies() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_first_party_for_cookies) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_first_party_for_cookies)
            )
        );
    }
    test_field_get_first_party_for_cookies();
    fn test_field_set_first_party_for_cookies() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_first_party_for_cookies) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(set_first_party_for_cookies)
            )
        );
    }
    test_field_set_first_party_for_cookies();
    fn test_field_get_resource_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_resource_type) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_resource_type)
            )
        );
    }
    test_field_get_resource_type();
    fn test_field_get_transition_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_transition_type) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_transition_type)
            )
        );
    }
    test_field_get_transition_type();
    fn test_field_get_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_t),
                "::",
                stringify!(get_identifier)
            )
        );
    }
    test_field_get_identifier();
}
#[doc = ""]
#[doc = " Structure used to represent a web request. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
pub type cef_request_t = _cef_request_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_request_t object."]
    #[doc = ""]
    pub fn cef_request_create() -> *mut cef_request_t;
}
#[doc = ""]
#[doc = " Structure used to represent post data for a web request. The functions of"]
#[doc = " this structure may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_post_data_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is read-only."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying POST data includes elements that are"]
    #[doc = " not represented by this cef_post_data_t object (for example, multi-part"]
    #[doc = " file upload data). Modifying cef_post_data_t objects with excluded"]
    #[doc = " elements may result in the request failing."]
    #[doc = ""]
    pub has_excluded_elements: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the number of existing post data elements."]
    #[doc = ""]
    pub get_element_count:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_t) -> size_t>,
    #[doc = ""]
    #[doc = " Retrieve the post data elements."]
    #[doc = ""]
    pub get_elements: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_t,
            elementsCount: *mut size_t,
            elements: *mut *mut _cef_post_data_element_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Remove the specified post data element.  Returns true (1) if the removal"]
    #[doc = " succeeds."]
    #[doc = ""]
    pub remove_element: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_t,
            element: *mut _cef_post_data_element_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add the specified post data element.  Returns true (1) if the add"]
    #[doc = " succeeds."]
    #[doc = ""]
    pub add_element: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_t,
            element: *mut _cef_post_data_element_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Remove all existing post data elements."]
    #[doc = ""]
    pub remove_elements: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_t)>,
}
#[test]
fn bindgen_test_layout__cef_post_data_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_post_data_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_post_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_post_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_post_data_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_read_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_t),
                "::",
                stringify!(is_read_only)
            )
        );
    }
    test_field_is_read_only();
    fn test_field_has_excluded_elements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_excluded_elements) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_t),
                "::",
                stringify!(has_excluded_elements)
            )
        );
    }
    test_field_has_excluded_elements();
    fn test_field_get_element_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_element_count) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_t),
                "::",
                stringify!(get_element_count)
            )
        );
    }
    test_field_get_element_count();
    fn test_field_get_elements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_elements) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_t),
                "::",
                stringify!(get_elements)
            )
        );
    }
    test_field_get_elements();
    fn test_field_remove_element() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove_element) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_t),
                "::",
                stringify!(remove_element)
            )
        );
    }
    test_field_remove_element();
    fn test_field_add_element() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_element) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_t),
                "::",
                stringify!(add_element)
            )
        );
    }
    test_field_add_element();
    fn test_field_remove_elements() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove_elements) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_t),
                "::",
                stringify!(remove_elements)
            )
        );
    }
    test_field_remove_elements();
}
#[doc = ""]
#[doc = " Structure used to represent post data for a web request. The functions of"]
#[doc = " this structure may be called on any thread."]
#[doc = ""]
pub type cef_post_data_t = _cef_post_data_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_post_data_t object."]
    #[doc = ""]
    pub fn cef_post_data_create() -> *mut cef_post_data_t;
}
#[doc = ""]
#[doc = " Structure used to represent a single element in the request post data. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_post_data_element_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is read-only."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Remove all contents from the post data element."]
    #[doc = ""]
    pub set_to_empty:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_element_t)>,
    #[doc = ""]
    #[doc = " The post data element will represent a file."]
    #[doc = ""]
    pub set_to_file: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t, fileName: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " The post data element will represent bytes.  The bytes passed in will be"]
    #[doc = " copied."]
    #[doc = ""]
    pub set_to_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_element_t,
            size: size_t,
            bytes: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = ""]
    #[doc = " Return the type of this post data element."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> cef_postdataelement_type_t,
    >,
    #[doc = ""]
    #[doc = " Return the file name."]
    #[doc = ""]
    pub get_file: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Return the number of bytes."]
    #[doc = ""]
    pub get_bytes_count:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_post_data_element_t) -> size_t>,
    #[doc = ""]
    #[doc = " Read up to |size| bytes into |bytes| and return the number of bytes"]
    #[doc = " actually read."]
    #[doc = ""]
    pub get_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_post_data_element_t,
            size: size_t,
            bytes: *mut ::std::os::raw::c_void,
        ) -> size_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_post_data_element_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_post_data_element_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_post_data_element_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_post_data_element_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_post_data_element_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_element_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_element_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_read_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_element_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_element_t),
                "::",
                stringify!(is_read_only)
            )
        );
    }
    test_field_is_read_only();
    fn test_field_set_to_empty() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_element_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_to_empty) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_element_t),
                "::",
                stringify!(set_to_empty)
            )
        );
    }
    test_field_set_to_empty();
    fn test_field_set_to_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_element_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_to_file) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_element_t),
                "::",
                stringify!(set_to_file)
            )
        );
    }
    test_field_set_to_file();
    fn test_field_set_to_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_element_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_to_bytes) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_element_t),
                "::",
                stringify!(set_to_bytes)
            )
        );
    }
    test_field_set_to_bytes();
    fn test_field_get_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_element_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_element_t),
                "::",
                stringify!(get_type)
            )
        );
    }
    test_field_get_type();
    fn test_field_get_file() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_element_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_file) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_element_t),
                "::",
                stringify!(get_file)
            )
        );
    }
    test_field_get_file();
    fn test_field_get_bytes_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_element_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_bytes_count) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_element_t),
                "::",
                stringify!(get_bytes_count)
            )
        );
    }
    test_field_get_bytes_count();
    fn test_field_get_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_post_data_element_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_bytes) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_post_data_element_t),
                "::",
                stringify!(get_bytes)
            )
        );
    }
    test_field_get_bytes();
}
#[doc = ""]
#[doc = " Structure used to represent a single element in the request post data. The"]
#[doc = " functions of this structure may be called on any thread."]
#[doc = ""]
pub type cef_post_data_element_t = _cef_post_data_element_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_post_data_element_t object."]
    #[doc = ""]
    pub fn cef_post_data_element_create() -> *mut cef_post_data_element_t;
}
#[doc = ""]
#[doc = " Implement this structure to receive string values asynchronously."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_string_visitor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed."]
    #[doc = ""]
    pub visit: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_string_visitor_t, string: *const cef_string_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_string_visitor_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_string_visitor_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_string_visitor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_string_visitor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_string_visitor_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_string_visitor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_string_visitor_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_visit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_string_visitor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visit) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_string_visitor_t),
                "::",
                stringify!(visit)
            )
        );
    }
    test_field_visit();
}
#[doc = ""]
#[doc = " Implement this structure to receive string values asynchronously."]
#[doc = ""]
pub type cef_string_visitor_t = _cef_string_visitor_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_urlrequest_client_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_urlrequest_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " Structure used to represent a frame in the browser window. When used in the"]
#[doc = " browser process the functions of this structure may be called on any thread"]
#[doc = " unless otherwise indicated in the comments. When used in the render process"]
#[doc = " the functions of this structure may only be called on the main thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_frame_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " True if this object is currently attached to a valid frame."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Execute undo in this frame."]
    #[doc = ""]
    pub undo: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute redo in this frame."]
    #[doc = ""]
    pub redo: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute cut in this frame."]
    #[doc = ""]
    pub cut: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute copy in this frame."]
    #[doc = ""]
    pub copy: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute paste in this frame."]
    #[doc = ""]
    pub paste: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute delete in this frame."]
    #[doc = ""]
    pub del: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Execute select all in this frame."]
    #[doc = ""]
    pub select_all: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Save this frame's HTML source to a temporary file and open it in the"]
    #[doc = " default text viewing application. This function can only be called from"]
    #[doc = " the browser process."]
    #[doc = ""]
    pub view_source: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t)>,
    #[doc = ""]
    #[doc = " Retrieve this frame's HTML source as a string sent to the specified"]
    #[doc = " visitor."]
    #[doc = ""]
    pub get_source: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, visitor: *mut _cef_string_visitor_t),
    >,
    #[doc = ""]
    #[doc = " Retrieve this frame's display text as a string sent to the specified"]
    #[doc = " visitor."]
    #[doc = ""]
    pub get_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, visitor: *mut _cef_string_visitor_t),
    >,
    #[doc = ""]
    #[doc = " Load the request represented by the |request| object."]
    #[doc = ""]
    #[doc = " WARNING: This function will fail with \"bad IPC message\" reason"]
    #[doc = " INVALID_INITIATOR_ORIGIN (213) unless you first navigate to the request"]
    #[doc = " origin using some other mechanism (LoadURL, link click, etc)."]
    #[doc = ""]
    pub load_request: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, request: *mut _cef_request_t),
    >,
    #[doc = ""]
    #[doc = " Load the specified |url|."]
    #[doc = ""]
    pub load_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Execute a string of JavaScript code in this frame. The |script_url|"]
    #[doc = " parameter is the URL where the script in question can be found, if any."]
    #[doc = " The renderer may request this URL to show the developer the source of the"]
    #[doc = " error.  The |start_line| parameter is the base line number to use for"]
    #[doc = " error reporting."]
    #[doc = ""]
    pub execute_java_script: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_t,
            code: *const cef_string_t,
            script_url: *const cef_string_t,
            start_line: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is the main (top-level) frame."]
    #[doc = ""]
    pub is_main: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is the focused frame."]
    #[doc = ""]
    pub is_focused: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the name for this frame. If the frame has an assigned name (for"]
    #[doc = " example, set via the iframe \"name\" attribute) then that value will be"]
    #[doc = " returned. Otherwise a unique name will be constructed based on the frame"]
    #[doc = " parent hierarchy. The main (top-level) frame will always have an NULL name"]
    #[doc = " value."]
    #[doc = ""]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the globally unique identifier for this frame or < 0 if the"]
    #[doc = " underlying frame does not yet exist."]
    #[doc = ""]
    pub get_identifier:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t) -> int64>,
    #[doc = ""]
    #[doc = " Returns the parent of this frame or NULL if this is the main (top-level)"]
    #[doc = " frame."]
    #[doc = ""]
    pub get_parent:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_frame_t) -> *mut _cef_frame_t>,
    #[doc = ""]
    #[doc = " Returns the URL currently loaded in this frame."]
    #[doc = ""]
    pub get_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the browser that this frame belongs to."]
    #[doc = ""]
    pub get_browser: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> *mut _cef_browser_t,
    >,
    #[doc = ""]
    #[doc = " Get the V8 context associated with the frame. This function can only be"]
    #[doc = " called from the render process."]
    #[doc = ""]
    pub get_v8context: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t) -> *mut _cef_v8context_t,
    >,
    #[doc = ""]
    #[doc = " Visit the DOM document. This function can only be called from the render"]
    #[doc = " process."]
    #[doc = ""]
    pub visit_dom: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_frame_t, visitor: *mut _cef_domvisitor_t),
    >,
    #[doc = ""]
    #[doc = " Create a new URL request that will be treated as originating from this"]
    #[doc = " frame and the associated browser. This request may be intercepted by the"]
    #[doc = " client via cef_resource_request_handler_t or cef_scheme_handler_factory_t."]
    #[doc = " Use cef_urlrequest_t::Create instead if you do not want the request to"]
    #[doc = " have this association, in which case it may be handled differently (see"]
    #[doc = " documentation on that function). Requests may originate from both the"]
    #[doc = " browser process and the render process."]
    #[doc = ""]
    #[doc = " For requests originating from the browser process:"]
    #[doc = "   - POST data may only contain a single element of type PDE_TYPE_FILE or"]
    #[doc = "     PDE_TYPE_BYTES."]
    #[doc = ""]
    #[doc = " For requests originating from the render process:"]
    #[doc = "   - POST data may only contain a single element of type PDE_TYPE_BYTES."]
    #[doc = "   - If the response contains Content-Disposition or Mime-Type header"]
    #[doc = "     values that would not normally be rendered then the response may"]
    #[doc = "     receive special handling inside the browser (for example, via the"]
    #[doc = "     file download code path instead of the URL request code path)."]
    #[doc = ""]
    #[doc = " The |request| object will be marked as read-only after calling this"]
    #[doc = " function."]
    #[doc = ""]
    pub create_urlrequest: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            client: *mut _cef_urlrequest_client_t,
        ) -> *mut _cef_urlrequest_t,
    >,
    #[doc = ""]
    #[doc = " Send a message to the specified |target_process|. Ownership of the message"]
    #[doc = " contents will be transferred and the |message| reference will be"]
    #[doc = " invalidated. Message delivery is not guaranteed in all cases (for example,"]
    #[doc = " if the browser is closing, navigating, or if the target process crashes)."]
    #[doc = " Send an ACK message back from the target process if confirmation is"]
    #[doc = " required."]
    #[doc = ""]
    pub send_process_message: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_t,
            target_process: cef_process_id_t,
            message: *mut _cef_process_message_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_frame_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_frame_t>(),
        240usize,
        concat!("Size of: ", stringify!(_cef_frame_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_frame_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_frame_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_undo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).undo) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(undo)
            )
        );
    }
    test_field_undo();
    fn test_field_redo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).redo) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(redo)
            )
        );
    }
    test_field_redo();
    fn test_field_cut() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cut) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(cut)
            )
        );
    }
    test_field_cut();
    fn test_field_copy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(copy)
            )
        );
    }
    test_field_copy();
    fn test_field_paste() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).paste) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(paste)
            )
        );
    }
    test_field_paste();
    fn test_field_del() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).del) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(del)
            )
        );
    }
    test_field_del();
    fn test_field_select_all() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).select_all) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(select_all)
            )
        );
    }
    test_field_select_all();
    fn test_field_view_source() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).view_source) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(view_source)
            )
        );
    }
    test_field_view_source();
    fn test_field_get_source() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_source) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(get_source)
            )
        );
    }
    test_field_get_source();
    fn test_field_get_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_text) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(get_text)
            )
        );
    }
    test_field_get_text();
    fn test_field_load_request() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).load_request) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(load_request)
            )
        );
    }
    test_field_load_request();
    fn test_field_load_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).load_url) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(load_url)
            )
        );
    }
    test_field_load_url();
    fn test_field_execute_java_script() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).execute_java_script) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(execute_java_script)
            )
        );
    }
    test_field_execute_java_script();
    fn test_field_is_main() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_main) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(is_main)
            )
        );
    }
    test_field_is_main();
    fn test_field_is_focused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_focused) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(is_focused)
            )
        );
    }
    test_field_is_focused();
    fn test_field_get_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(get_name)
            )
        );
    }
    test_field_get_name();
    fn test_field_get_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(get_identifier)
            )
        );
    }
    test_field_get_identifier();
    fn test_field_get_parent() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_parent) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(get_parent)
            )
        );
    }
    test_field_get_parent();
    fn test_field_get_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_url) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(get_url)
            )
        );
    }
    test_field_get_url();
    fn test_field_get_browser() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_browser) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(get_browser)
            )
        );
    }
    test_field_get_browser();
    fn test_field_get_v8context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_v8context) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(get_v8context)
            )
        );
    }
    test_field_get_v8context();
    fn test_field_visit_dom() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visit_dom) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(visit_dom)
            )
        );
    }
    test_field_visit_dom();
    fn test_field_create_urlrequest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).create_urlrequest) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(create_urlrequest)
            )
        );
    }
    test_field_create_urlrequest();
    fn test_field_send_process_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send_process_message) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_t),
                "::",
                stringify!(send_process_message)
            )
        );
    }
    test_field_send_process_message();
}
#[doc = ""]
#[doc = " Structure used to represent a frame in the browser window. When used in the"]
#[doc = " browser process the functions of this structure may be called on any thread"]
#[doc = " unless otherwise indicated in the comments. When used in the render process"]
#[doc = " the functions of this structure may only be called on the main thread."]
#[doc = ""]
pub type cef_frame_t = _cef_frame_t;
#[doc = ""]
#[doc = " Structure representing the issuer or subject field of an X.509 certificate."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_x509cert_principal_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns a name that can be used to represent the issuer. It tries in this"]
    #[doc = " order: Common Name (CN), Organization Name (O) and Organizational Unit"]
    #[doc = " Name (OU) and returns the first non-NULL one found."]
    #[doc = ""]
    pub get_display_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the common name."]
    #[doc = ""]
    pub get_common_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the locality name."]
    #[doc = ""]
    pub get_locality_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the state or province name."]
    #[doc = ""]
    pub get_state_or_province_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the country name."]
    #[doc = ""]
    pub get_country_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Retrieve the list of street addresses."]
    #[doc = ""]
    pub get_street_addresses: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, addresses: cef_string_list_t),
    >,
    #[doc = ""]
    #[doc = " Retrieve the list of organization names."]
    #[doc = ""]
    pub get_organization_names: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, names: cef_string_list_t),
    >,
    #[doc = ""]
    #[doc = " Retrieve the list of organization unit names."]
    #[doc = ""]
    pub get_organization_unit_names: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, names: cef_string_list_t),
    >,
    #[doc = ""]
    #[doc = " Retrieve the list of domain components."]
    #[doc = ""]
    pub get_domain_components: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509cert_principal_t, components: cef_string_list_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_x509cert_principal_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_x509cert_principal_t>(),
        112usize,
        concat!("Size of: ", stringify!(_cef_x509cert_principal_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_x509cert_principal_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_x509cert_principal_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509cert_principal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509cert_principal_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_display_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509cert_principal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_display_name) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509cert_principal_t),
                "::",
                stringify!(get_display_name)
            )
        );
    }
    test_field_get_display_name();
    fn test_field_get_common_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509cert_principal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_common_name) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509cert_principal_t),
                "::",
                stringify!(get_common_name)
            )
        );
    }
    test_field_get_common_name();
    fn test_field_get_locality_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509cert_principal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_locality_name) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509cert_principal_t),
                "::",
                stringify!(get_locality_name)
            )
        );
    }
    test_field_get_locality_name();
    fn test_field_get_state_or_province_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509cert_principal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_state_or_province_name) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509cert_principal_t),
                "::",
                stringify!(get_state_or_province_name)
            )
        );
    }
    test_field_get_state_or_province_name();
    fn test_field_get_country_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509cert_principal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_country_name) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509cert_principal_t),
                "::",
                stringify!(get_country_name)
            )
        );
    }
    test_field_get_country_name();
    fn test_field_get_street_addresses() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509cert_principal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_street_addresses) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509cert_principal_t),
                "::",
                stringify!(get_street_addresses)
            )
        );
    }
    test_field_get_street_addresses();
    fn test_field_get_organization_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509cert_principal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_organization_names) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509cert_principal_t),
                "::",
                stringify!(get_organization_names)
            )
        );
    }
    test_field_get_organization_names();
    fn test_field_get_organization_unit_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509cert_principal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_organization_unit_names) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509cert_principal_t),
                "::",
                stringify!(get_organization_unit_names)
            )
        );
    }
    test_field_get_organization_unit_names();
    fn test_field_get_domain_components() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509cert_principal_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_domain_components) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509cert_principal_t),
                "::",
                stringify!(get_domain_components)
            )
        );
    }
    test_field_get_domain_components();
}
#[doc = ""]
#[doc = " Structure representing the issuer or subject field of an X.509 certificate."]
#[doc = ""]
pub type cef_x509cert_principal_t = _cef_x509cert_principal_t;
#[doc = ""]
#[doc = " Structure representing a X.509 certificate."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_x509certificate_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the subject of the X.509 certificate. For HTTPS server"]
    #[doc = " certificates this represents the web server.  The common name of the"]
    #[doc = " subject should match the host name of the web server."]
    #[doc = ""]
    pub get_subject: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_x509cert_principal_t,
    >,
    #[doc = ""]
    #[doc = " Returns the issuer of the X.509 certificate."]
    #[doc = ""]
    pub get_issuer: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_x509cert_principal_t,
    >,
    #[doc = ""]
    #[doc = " Returns the DER encoded serial number for the X.509 certificate. The value"]
    #[doc = " possibly includes a leading 00 byte."]
    #[doc = ""]
    pub get_serial_number: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the date before which the X.509 certificate is invalid."]
    #[doc = " CefBaseTime.GetTimeT() will return 0 if no date was specified."]
    #[doc = ""]
    pub get_valid_start: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> cef_basetime_t,
    >,
    #[doc = ""]
    #[doc = " Returns the date after which the X.509 certificate is invalid."]
    #[doc = " CefBaseTime.GetTimeT() will return 0 if no date was specified."]
    #[doc = ""]
    pub get_valid_expiry: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> cef_basetime_t,
    >,
    #[doc = ""]
    #[doc = " Returns the DER encoded data for the X.509 certificate."]
    #[doc = ""]
    pub get_derencoded: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the PEM encoded data for the X.509 certificate."]
    #[doc = ""]
    pub get_pemencoded: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> *mut _cef_binary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the number of certificates in the issuer chain. If 0, the"]
    #[doc = " certificate is self-signed."]
    #[doc = ""]
    pub get_issuer_chain_size:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_x509certificate_t) -> size_t>,
    #[doc = ""]
    #[doc = " Returns the DER encoded data for the certificate issuer chain. If we"]
    #[doc = " failed to encode a certificate in the chain it is still present in the"]
    #[doc = " array but is an NULL string."]
    #[doc = ""]
    pub get_derencoded_issuer_chain: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_x509certificate_t,
            chainCount: *mut size_t,
            chain: *mut *mut _cef_binary_value_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns the PEM encoded data for the certificate issuer chain. If we"]
    #[doc = " failed to encode a certificate in the chain it is still present in the"]
    #[doc = " array but is an NULL string."]
    #[doc = ""]
    pub get_pemencoded_issuer_chain: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_x509certificate_t,
            chainCount: *mut size_t,
            chain: *mut *mut _cef_binary_value_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_x509certificate_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_x509certificate_t>(),
        120usize,
        concat!("Size of: ", stringify!(_cef_x509certificate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_x509certificate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_x509certificate_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509certificate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509certificate_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_subject() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509certificate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_subject) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509certificate_t),
                "::",
                stringify!(get_subject)
            )
        );
    }
    test_field_get_subject();
    fn test_field_get_issuer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509certificate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_issuer) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509certificate_t),
                "::",
                stringify!(get_issuer)
            )
        );
    }
    test_field_get_issuer();
    fn test_field_get_serial_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509certificate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_serial_number) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509certificate_t),
                "::",
                stringify!(get_serial_number)
            )
        );
    }
    test_field_get_serial_number();
    fn test_field_get_valid_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509certificate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_valid_start) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509certificate_t),
                "::",
                stringify!(get_valid_start)
            )
        );
    }
    test_field_get_valid_start();
    fn test_field_get_valid_expiry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509certificate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_valid_expiry) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509certificate_t),
                "::",
                stringify!(get_valid_expiry)
            )
        );
    }
    test_field_get_valid_expiry();
    fn test_field_get_derencoded() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509certificate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_derencoded) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509certificate_t),
                "::",
                stringify!(get_derencoded)
            )
        );
    }
    test_field_get_derencoded();
    fn test_field_get_pemencoded() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509certificate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_pemencoded) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509certificate_t),
                "::",
                stringify!(get_pemencoded)
            )
        );
    }
    test_field_get_pemencoded();
    fn test_field_get_issuer_chain_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509certificate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_issuer_chain_size) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509certificate_t),
                "::",
                stringify!(get_issuer_chain_size)
            )
        );
    }
    test_field_get_issuer_chain_size();
    fn test_field_get_derencoded_issuer_chain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509certificate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_derencoded_issuer_chain) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509certificate_t),
                "::",
                stringify!(get_derencoded_issuer_chain)
            )
        );
    }
    test_field_get_derencoded_issuer_chain();
    fn test_field_get_pemencoded_issuer_chain() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_x509certificate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_pemencoded_issuer_chain) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_x509certificate_t),
                "::",
                stringify!(get_pemencoded_issuer_chain)
            )
        );
    }
    test_field_get_pemencoded_issuer_chain();
}
#[doc = ""]
#[doc = " Structure representing a X.509 certificate."]
#[doc = ""]
pub type cef_x509certificate_t = _cef_x509certificate_t;
#[doc = ""]
#[doc = " Structure representing the SSL information for a navigation entry."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_sslstatus_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if the status is related to a secure SSL/TLS connection."]
    #[doc = ""]
    pub is_secure_connection: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a bitmask containing any and all problems verifying the server"]
    #[doc = " certificate."]
    #[doc = ""]
    pub get_cert_status: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> cef_cert_status_t,
    >,
    #[doc = ""]
    #[doc = " Returns the SSL version used for the SSL connection."]
    #[doc = ""]
    pub get_sslversion: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> cef_ssl_version_t,
    >,
    #[doc = ""]
    #[doc = " Returns a bitmask containing the page security content status."]
    #[doc = ""]
    pub get_content_status: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> cef_ssl_content_status_t,
    >,
    #[doc = ""]
    #[doc = " Returns the X.509 certificate."]
    #[doc = ""]
    pub get_x509certificate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslstatus_t) -> *mut _cef_x509certificate_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_sslstatus_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_sslstatus_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_sslstatus_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_sslstatus_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_sslstatus_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_sslstatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_sslstatus_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_secure_connection() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_sslstatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_secure_connection) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_sslstatus_t),
                "::",
                stringify!(is_secure_connection)
            )
        );
    }
    test_field_is_secure_connection();
    fn test_field_get_cert_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_sslstatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_cert_status) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_sslstatus_t),
                "::",
                stringify!(get_cert_status)
            )
        );
    }
    test_field_get_cert_status();
    fn test_field_get_sslversion() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_sslstatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_sslversion) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_sslstatus_t),
                "::",
                stringify!(get_sslversion)
            )
        );
    }
    test_field_get_sslversion();
    fn test_field_get_content_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_sslstatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_content_status) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_sslstatus_t),
                "::",
                stringify!(get_content_status)
            )
        );
    }
    test_field_get_content_status();
    fn test_field_get_x509certificate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_sslstatus_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_x509certificate) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_sslstatus_t),
                "::",
                stringify!(get_x509certificate)
            )
        );
    }
    test_field_get_x509certificate();
}
#[doc = ""]
#[doc = " Structure representing the SSL information for a navigation entry."]
#[doc = ""]
pub type cef_sslstatus_t = _cef_sslstatus_t;
#[doc = ""]
#[doc = " Structure used to represent an entry in navigation history."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_navigation_entry_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. Do not call any other functions"]
    #[doc = " if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the actual URL of the page. For some pages this may be data: URL"]
    #[doc = " or similar. Use get_display_url() to return a display-friendly version."]
    #[doc = ""]
    pub get_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns a display-friendly version of the URL."]
    #[doc = ""]
    pub get_display_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the original URL that was entered by the user before any"]
    #[doc = " redirects."]
    #[doc = ""]
    pub get_original_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the title set by the page. This value may be NULL."]
    #[doc = ""]
    pub get_title: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the transition type which indicates what the user did to move to"]
    #[doc = " this page from the previous page."]
    #[doc = ""]
    pub get_transition_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_transition_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this navigation includes post data."]
    #[doc = ""]
    pub has_post_data: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the time for the last known successful navigation completion. A"]
    #[doc = " navigation may be completed more than once if the page is reloaded. May be"]
    #[doc = " 0 if the navigation has not yet completed."]
    #[doc = ""]
    pub get_completion_time: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> cef_basetime_t,
    >,
    #[doc = ""]
    #[doc = " Returns the HTTP status code for the last known successful navigation"]
    #[doc = " response. May be 0 if the response has not yet been received or if the"]
    #[doc = " navigation has not yet completed."]
    #[doc = ""]
    pub get_http_status_code: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the SSL information for this navigation entry."]
    #[doc = ""]
    pub get_sslstatus: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_navigation_entry_t) -> *mut _cef_sslstatus_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_navigation_entry_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_navigation_entry_t>(),
        120usize,
        concat!("Size of: ", stringify!(_cef_navigation_entry_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_navigation_entry_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_navigation_entry_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_get_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_url) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_t),
                "::",
                stringify!(get_url)
            )
        );
    }
    test_field_get_url();
    fn test_field_get_display_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_display_url) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_t),
                "::",
                stringify!(get_display_url)
            )
        );
    }
    test_field_get_display_url();
    fn test_field_get_original_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_original_url) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_t),
                "::",
                stringify!(get_original_url)
            )
        );
    }
    test_field_get_original_url();
    fn test_field_get_title() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_title) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_t),
                "::",
                stringify!(get_title)
            )
        );
    }
    test_field_get_title();
    fn test_field_get_transition_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_transition_type) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_t),
                "::",
                stringify!(get_transition_type)
            )
        );
    }
    test_field_get_transition_type();
    fn test_field_has_post_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_post_data) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_t),
                "::",
                stringify!(has_post_data)
            )
        );
    }
    test_field_has_post_data();
    fn test_field_get_completion_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_completion_time) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_t),
                "::",
                stringify!(get_completion_time)
            )
        );
    }
    test_field_get_completion_time();
    fn test_field_get_http_status_code() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_http_status_code) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_t),
                "::",
                stringify!(get_http_status_code)
            )
        );
    }
    test_field_get_http_status_code();
    fn test_field_get_sslstatus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_sslstatus) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_t),
                "::",
                stringify!(get_sslstatus)
            )
        );
    }
    test_field_get_sslstatus();
}
#[doc = ""]
#[doc = " Structure used to represent an entry in navigation history."]
#[doc = ""]
pub type cef_navigation_entry_t = _cef_navigation_entry_t;
#[doc = ""]
#[doc = " Generic callback structure used for managing the lifespan of a registration."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_registration_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
}
#[test]
fn bindgen_test_layout__cef_registration_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_registration_t>(),
        40usize,
        concat!("Size of: ", stringify!(_cef_registration_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_registration_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_registration_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_registration_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_registration_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
}
#[doc = ""]
#[doc = " Generic callback structure used for managing the lifespan of a registration."]
#[doc = ""]
pub type cef_registration_t = _cef_registration_t;
#[doc = ""]
#[doc = " Generic callback structure used for asynchronous continuation."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue processing."]
    #[doc = ""]
    pub cont: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_callback_t)>,
    #[doc = ""]
    #[doc = " Cancel processing."]
    #[doc = ""]
    pub cancel: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
    fn test_field_cancel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_callback_t),
                "::",
                stringify!(cancel)
            )
        );
    }
    test_field_cancel();
}
#[doc = ""]
#[doc = " Generic callback structure used for asynchronous continuation."]
#[doc = ""]
pub type cef_callback_t = _cef_callback_t;
#[doc = ""]
#[doc = " Generic callback structure used for asynchronous completion."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_completion_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called once the task is complete."]
    #[doc = ""]
    pub on_complete:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_completion_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_completion_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_completion_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_completion_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_completion_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_completion_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_completion_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_completion_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_complete() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_completion_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_complete) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_completion_callback_t),
                "::",
                stringify!(on_complete)
            )
        );
    }
    test_field_on_complete();
}
#[doc = ""]
#[doc = " Generic callback structure used for asynchronous completion."]
#[doc = ""]
pub type cef_completion_callback_t = _cef_completion_callback_t;
#[doc = ""]
#[doc = " Structure used for managing cookies. The functions of this structure may be"]
#[doc = " called on any thread unless otherwise indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cookie_manager_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Visit all cookies on the UI thread. The returned cookies are ordered by"]
    #[doc = " longest path, then by earliest creation date. Returns false (0) if cookies"]
    #[doc = " cannot be accessed."]
    #[doc = ""]
    pub visit_all_cookies: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            visitor: *mut _cef_cookie_visitor_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Visit a subset of cookies on the UI thread. The results are filtered by"]
    #[doc = " the given url scheme, host, domain and path. If |includeHttpOnly| is true"]
    #[doc = " (1) HTTP-only cookies will also be included in the results. The returned"]
    #[doc = " cookies are ordered by longest path, then by earliest creation date."]
    #[doc = " Returns false (0) if cookies cannot be accessed."]
    #[doc = ""]
    pub visit_url_cookies: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            url: *const cef_string_t,
            includeHttpOnly: ::std::os::raw::c_int,
            visitor: *mut _cef_cookie_visitor_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets a cookie given a valid URL and explicit user-provided cookie"]
    #[doc = " attributes. This function expects each attribute to be well-formed. It"]
    #[doc = " will check for disallowed characters (e.g. the ';' character is disallowed"]
    #[doc = " within the cookie value attribute) and fail without setting the cookie if"]
    #[doc = " such characters are found. If |callback| is non-NULL it will be executed"]
    #[doc = " asnychronously on the UI thread after the cookie has been set. Returns"]
    #[doc = " false (0) if an invalid URL is specified or if cookies cannot be accessed."]
    #[doc = ""]
    pub set_cookie: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            url: *const cef_string_t,
            cookie: *const _cef_cookie_t,
            callback: *mut _cef_set_cookie_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Delete all cookies that match the specified parameters. If both |url| and"]
    #[doc = " |cookie_name| values are specified all host and domain cookies matching"]
    #[doc = " both will be deleted. If only |url| is specified all host cookies (but not"]
    #[doc = " domain cookies) irrespective of path will be deleted. If |url| is NULL all"]
    #[doc = " cookies for all hosts and domains will be deleted. If |callback| is non-"]
    #[doc = " NULL it will be executed asnychronously on the UI thread after the cookies"]
    #[doc = " have been deleted. Returns false (0) if a non-NULL invalid URL is"]
    #[doc = " specified or if cookies cannot be accessed. Cookies can alternately be"]
    #[doc = " deleted using the Visit*Cookies() functions."]
    #[doc = ""]
    pub delete_cookies: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            url: *const cef_string_t,
            cookie_name: *const cef_string_t,
            callback: *mut _cef_delete_cookies_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Flush the backing store (if any) to disk. If |callback| is non-NULL it"]
    #[doc = " will be executed asnychronously on the UI thread after the flush is"]
    #[doc = " complete. Returns false (0) if cookies cannot be accessed."]
    #[doc = ""]
    pub flush_store: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_manager_t,
            callback: *mut _cef_completion_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_cookie_manager_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_cookie_manager_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_cookie_manager_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_cookie_manager_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_cookie_manager_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_manager_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_manager_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_visit_all_cookies() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_manager_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visit_all_cookies) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_manager_t),
                "::",
                stringify!(visit_all_cookies)
            )
        );
    }
    test_field_visit_all_cookies();
    fn test_field_visit_url_cookies() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_manager_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visit_url_cookies) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_manager_t),
                "::",
                stringify!(visit_url_cookies)
            )
        );
    }
    test_field_visit_url_cookies();
    fn test_field_set_cookie() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_manager_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_cookie) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_manager_t),
                "::",
                stringify!(set_cookie)
            )
        );
    }
    test_field_set_cookie();
    fn test_field_delete_cookies() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_manager_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).delete_cookies) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_manager_t),
                "::",
                stringify!(delete_cookies)
            )
        );
    }
    test_field_delete_cookies();
    fn test_field_flush_store() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_manager_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).flush_store) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_manager_t),
                "::",
                stringify!(flush_store)
            )
        );
    }
    test_field_flush_store();
}
#[doc = ""]
#[doc = " Structure used for managing cookies. The functions of this structure may be"]
#[doc = " called on any thread unless otherwise indicated."]
#[doc = ""]
pub type cef_cookie_manager_t = _cef_cookie_manager_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns the global cookie manager. By default data will be stored at"]
    #[doc = " cef_settings_t.cache_path if specified or in memory otherwise. If |callback|"]
    #[doc = " is non-NULL it will be executed asnychronously on the UI thread after the"]
    #[doc = " manager's storage has been initialized. Using this function is equivalent to"]
    #[doc = " calling cef_request_context_t::cef_request_context_get_global_context()->Get"]
    #[doc = " DefaultCookieManager()."]
    #[doc = ""]
    pub fn cef_cookie_manager_get_global_manager(
        callback: *mut _cef_completion_callback_t,
    ) -> *mut cef_cookie_manager_t;
}
#[doc = ""]
#[doc = " Structure to implement for visiting cookie values. The functions of this"]
#[doc = " structure will always be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cookie_visitor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called once for each cookie. |count| is the 0-based"]
    #[doc = " index for the current cookie. |total| is the total number of cookies. Set"]
    #[doc = " |deleteCookie| to true (1) to delete the cookie currently being visited."]
    #[doc = " Return false (0) to stop visiting cookies. This function may never be"]
    #[doc = " called if no cookies are found."]
    #[doc = ""]
    pub visit: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_visitor_t,
            cookie: *const _cef_cookie_t,
            count: ::std::os::raw::c_int,
            total: ::std::os::raw::c_int,
            deleteCookie: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_cookie_visitor_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_cookie_visitor_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_cookie_visitor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_cookie_visitor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_cookie_visitor_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_visitor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_visitor_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_visit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_visitor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visit) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_visitor_t),
                "::",
                stringify!(visit)
            )
        );
    }
    test_field_visit();
}
#[doc = ""]
#[doc = " Structure to implement for visiting cookie values. The functions of this"]
#[doc = " structure will always be called on the UI thread."]
#[doc = ""]
pub type cef_cookie_visitor_t = _cef_cookie_visitor_t;
#[doc = ""]
#[doc = " Structure to implement to be notified of asynchronous completion via"]
#[doc = " cef_cookie_manager_t::set_cookie()."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_set_cookie_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called upon completion. |success| will be true (1) if"]
    #[doc = " the cookie was set successfully."]
    #[doc = ""]
    pub on_complete: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_set_cookie_callback_t,
            success: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_set_cookie_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_set_cookie_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_set_cookie_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_set_cookie_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_set_cookie_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_set_cookie_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_set_cookie_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_complete() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_set_cookie_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_complete) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_set_cookie_callback_t),
                "::",
                stringify!(on_complete)
            )
        );
    }
    test_field_on_complete();
}
#[doc = ""]
#[doc = " Structure to implement to be notified of asynchronous completion via"]
#[doc = " cef_cookie_manager_t::set_cookie()."]
#[doc = ""]
pub type cef_set_cookie_callback_t = _cef_set_cookie_callback_t;
#[doc = ""]
#[doc = " Structure to implement to be notified of asynchronous completion via"]
#[doc = " cef_cookie_manager_t::delete_cookies()."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_delete_cookies_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be called upon completion. |num_deleted| will be the"]
    #[doc = " number of cookies that were deleted."]
    #[doc = ""]
    pub on_complete: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_delete_cookies_callback_t,
            num_deleted: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_delete_cookies_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_delete_cookies_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_delete_cookies_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_delete_cookies_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_delete_cookies_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_delete_cookies_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_delete_cookies_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_complete() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_delete_cookies_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_complete) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_delete_cookies_callback_t),
                "::",
                stringify!(on_complete)
            )
        );
    }
    test_field_on_complete();
}
#[doc = ""]
#[doc = " Structure to implement to be notified of asynchronous completion via"]
#[doc = " cef_cookie_manager_t::delete_cookies()."]
#[doc = ""]
pub type cef_delete_cookies_callback_t = _cef_delete_cookies_callback_t;
#[doc = ""]
#[doc = " Object representing an extension. Methods may be called on any thread unless"]
#[doc = " otherwise indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_extension_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the unique extension identifier. This is calculated based on the"]
    #[doc = " extension public key, if available, or on the extension path. See"]
    #[doc = " https://developer.chrome.com/extensions/manifest/key for details."]
    #[doc = ""]
    pub get_identifier: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the absolute path to the extension directory on disk. This value"]
    #[doc = " will be prefixed with PK_DIR_RESOURCES if a relative path was passed to"]
    #[doc = " cef_request_context_t::LoadExtension."]
    #[doc = ""]
    pub get_path: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the extension manifest contents as a cef_dictionary_value_t"]
    #[doc = " object. See https://developer.chrome.com/extensions/manifest for details."]
    #[doc = ""]
    pub get_manifest: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is the same extension as |that| object."]
    #[doc = " Extensions are considered the same if identifier, path and loader context"]
    #[doc = " match."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_t,
            that: *mut _cef_extension_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the handler for this extension. Will return NULL for internal"]
    #[doc = " extensions or if no handler was passed to"]
    #[doc = " cef_request_context_t::LoadExtension."]
    #[doc = ""]
    pub get_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> *mut _cef_extension_handler_t,
    >,
    #[doc = ""]
    #[doc = " Returns the request context that loaded this extension. Will return NULL"]
    #[doc = " for internal extensions or if the extension has been unloaded. See the"]
    #[doc = " cef_request_context_t::LoadExtension documentation for more information"]
    #[doc = " about loader contexts. Must be called on the browser process UI thread."]
    #[doc = ""]
    pub get_loader_context: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> *mut _cef_request_context_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this extension is currently loaded. Must be called on"]
    #[doc = " the browser process UI thread."]
    #[doc = ""]
    pub is_loaded: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Unload this extension if it is not an internal extension and is currently"]
    #[doc = " loaded. Will result in a call to"]
    #[doc = " cef_extension_handler_t::OnExtensionUnloaded on success."]
    #[doc = ""]
    pub unload: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_extension_t)>,
}
#[test]
fn bindgen_test_layout__cef_extension_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_extension_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_extension_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_extension_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_extension_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_t),
                "::",
                stringify!(get_identifier)
            )
        );
    }
    test_field_get_identifier();
    fn test_field_get_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_path) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_t),
                "::",
                stringify!(get_path)
            )
        );
    }
    test_field_get_path();
    fn test_field_get_manifest() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_manifest) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_t),
                "::",
                stringify!(get_manifest)
            )
        );
    }
    test_field_get_manifest();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_get_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_handler) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_t),
                "::",
                stringify!(get_handler)
            )
        );
    }
    test_field_get_handler();
    fn test_field_get_loader_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_loader_context) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_t),
                "::",
                stringify!(get_loader_context)
            )
        );
    }
    test_field_get_loader_context();
    fn test_field_is_loaded() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_loaded) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_t),
                "::",
                stringify!(is_loaded)
            )
        );
    }
    test_field_is_loaded();
    fn test_field_unload() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unload) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_t),
                "::",
                stringify!(unload)
            )
        );
    }
    test_field_unload();
}
#[doc = ""]
#[doc = " Object representing an extension. Methods may be called on any thread unless"]
#[doc = " otherwise indicated."]
#[doc = ""]
pub type cef_extension_t = _cef_extension_t;
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of"]
#[doc = " cef_extension_handler_t::GetExtensionResource."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_get_extension_resource_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue the request. Read the resource contents from |stream|."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_get_extension_resource_callback_t,
            stream: *mut _cef_stream_reader_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel the request."]
    #[doc = ""]
    pub cancel: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_get_extension_resource_callback_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_get_extension_resource_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_get_extension_resource_callback_t>(),
        56usize,
        concat!(
            "Size of: ",
            stringify!(_cef_get_extension_resource_callback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_get_extension_resource_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_get_extension_resource_callback_t)
        )
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_cef_get_extension_resource_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_get_extension_resource_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_cef_get_extension_resource_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_get_extension_resource_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
    fn test_field_cancel() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_cef_get_extension_resource_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_get_extension_resource_callback_t),
                "::",
                stringify!(cancel)
            )
        );
    }
    test_field_cancel();
}
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of"]
#[doc = " cef_extension_handler_t::GetExtensionResource."]
#[doc = ""]
pub type cef_get_extension_resource_callback_t = _cef_get_extension_resource_callback_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser extensions. The"]
#[doc = " functions of this structure will be called on the UI thread. See"]
#[doc = " cef_request_context_t::LoadExtension for information about extension"]
#[doc = " loading."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_extension_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called if the cef_request_context_t::LoadExtension request fails. |result|"]
    #[doc = " will be the error code."]
    #[doc = ""]
    pub on_extension_load_failed: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_extension_handler_t, result: cef_errorcode_t),
    >,
    #[doc = ""]
    #[doc = " Called if the cef_request_context_t::LoadExtension request succeeds."]
    #[doc = " |extension| is the loaded extension."]
    #[doc = ""]
    pub on_extension_loaded: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called after the cef_extension_t::Unload request has completed."]
    #[doc = ""]
    pub on_extension_unloaded: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when an extension needs a browser to host a background script"]
    #[doc = " specified via the \"background\" manifest key. The browser will have no"]
    #[doc = " visible window and cannot be displayed. |extension| is the extension that"]
    #[doc = " is loading the background script. |url| is an internally generated"]
    #[doc = " reference to an HTML page that will be used to load the background script"]
    #[doc = " via a \"<script>\" src attribute. To allow creation of the browser"]
    #[doc = " optionally modify |client| and |settings| and return false (0). To cancel"]
    #[doc = " creation of the browser (and consequently cancel load of the background"]
    #[doc = " script) return true (1). Successful creation will be indicated by a call"]
    #[doc = " to cef_life_span_handler_t::OnAfterCreated, and"]
    #[doc = " cef_browser_host_t::IsBackgroundHost will return true (1) for the"]
    #[doc = " resulting browser. See https://developer.chrome.com/extensions/event_pages"]
    #[doc = " for more information about extension background script usage."]
    #[doc = ""]
    pub on_before_background_browser: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
            url: *const cef_string_t,
            client: *mut *mut _cef_client_t,
            settings: *mut _cef_browser_settings_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when an extension API (e.g. chrome.tabs.create) requests creation"]
    #[doc = " of a new browser. |extension| and |browser| are the source of the API"]
    #[doc = " call. |active_browser| may optionally be specified via the windowId"]
    #[doc = " property or returned via the get_active_browser() callback and provides"]
    #[doc = " the default |client| and |settings| values for the new browser. |index| is"]
    #[doc = " the position value optionally specified via the index property. |url| is"]
    #[doc = " the URL that will be loaded in the browser. |active| is true (1) if the"]
    #[doc = " new browser should be active when opened.  To allow creation of the"]
    #[doc = " browser optionally modify |windowInfo|, |client| and |settings| and return"]
    #[doc = " false (0). To cancel creation of the browser return true (1). Successful"]
    #[doc = " creation will be indicated by a call to"]
    #[doc = " cef_life_span_handler_t::OnAfterCreated. Any modifications to |windowInfo|"]
    #[doc = " will be ignored if |active_browser| is wrapped in a cef_browser_view_t."]
    #[doc = ""]
    pub on_before_browser: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
            browser: *mut _cef_browser_t,
            active_browser: *mut _cef_browser_t,
            index: ::std::os::raw::c_int,
            url: *const cef_string_t,
            active: ::std::os::raw::c_int,
            windowInfo: *mut _cef_window_info_t,
            client: *mut *mut _cef_client_t,
            settings: *mut _cef_browser_settings_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when no tabId is specified to an extension API call that accepts a"]
    #[doc = " tabId parameter (e.g. chrome.tabs.*). |extension| and |browser| are the"]
    #[doc = " source of the API call. Return the browser that will be acted on by the"]
    #[doc = " API call or return NULL to act on |browser|. The returned browser must"]
    #[doc = " share the same cef_request_context_t as |browser|. Incognito browsers"]
    #[doc = " should not be considered unless the source extension has incognito access"]
    #[doc = " enabled, in which case |include_incognito| will be true (1)."]
    #[doc = ""]
    pub get_active_browser: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
            browser: *mut _cef_browser_t,
            include_incognito: ::std::os::raw::c_int,
        ) -> *mut _cef_browser_t,
    >,
    #[doc = ""]
    #[doc = " Called when the tabId associated with |target_browser| is specified to an"]
    #[doc = " extension API call that accepts a tabId parameter (e.g. chrome.tabs.*)."]
    #[doc = " |extension| and |browser| are the source of the API call. Return true (1)"]
    #[doc = " to allow access of false (0) to deny access. Access to incognito browsers"]
    #[doc = " should not be allowed unless the source extension has incognito access"]
    #[doc = " enabled, in which case |include_incognito| will be true (1)."]
    #[doc = ""]
    pub can_access_browser: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
            browser: *mut _cef_browser_t,
            include_incognito: ::std::os::raw::c_int,
            target_browser: *mut _cef_browser_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to retrieve an extension resource that would normally be loaded"]
    #[doc = " from disk (e.g. if a file parameter is specified to"]
    #[doc = " chrome.tabs.executeScript). |extension| and |browser| are the source of"]
    #[doc = " the resource request. |file| is the requested relative file path. To"]
    #[doc = " handle the resource request return true (1) and execute |callback| either"]
    #[doc = " synchronously or asynchronously. For the default behavior which reads the"]
    #[doc = " resource from the extension directory on disk return false (0)."]
    #[doc = " Localization substitutions will not be applied to resources handled via"]
    #[doc = " this function."]
    #[doc = ""]
    pub get_extension_resource: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_extension_handler_t,
            extension: *mut _cef_extension_t,
            browser: *mut _cef_browser_t,
            file: *const cef_string_t,
            callback: *mut _cef_get_extension_resource_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_extension_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_extension_handler_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_extension_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_extension_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_extension_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_extension_load_failed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_extension_load_failed) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_handler_t),
                "::",
                stringify!(on_extension_load_failed)
            )
        );
    }
    test_field_on_extension_load_failed();
    fn test_field_on_extension_loaded() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_extension_loaded) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_handler_t),
                "::",
                stringify!(on_extension_loaded)
            )
        );
    }
    test_field_on_extension_loaded();
    fn test_field_on_extension_unloaded() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_extension_unloaded) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_handler_t),
                "::",
                stringify!(on_extension_unloaded)
            )
        );
    }
    test_field_on_extension_unloaded();
    fn test_field_on_before_background_browser() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_before_background_browser) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_handler_t),
                "::",
                stringify!(on_before_background_browser)
            )
        );
    }
    test_field_on_before_background_browser();
    fn test_field_on_before_browser() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_before_browser) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_handler_t),
                "::",
                stringify!(on_before_browser)
            )
        );
    }
    test_field_on_before_browser();
    fn test_field_get_active_browser() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_active_browser) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_handler_t),
                "::",
                stringify!(get_active_browser)
            )
        );
    }
    test_field_get_active_browser();
    fn test_field_can_access_browser() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).can_access_browser) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_handler_t),
                "::",
                stringify!(can_access_browser)
            )
        );
    }
    test_field_can_access_browser();
    fn test_field_get_extension_resource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_extension_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_extension_resource) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_extension_handler_t),
                "::",
                stringify!(get_extension_resource)
            )
        );
    }
    test_field_get_extension_resource();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser extensions. The"]
#[doc = " functions of this structure will be called on the UI thread. See"]
#[doc = " cef_request_context_t::LoadExtension for information about extension"]
#[doc = " loading."]
#[doc = ""]
pub type cef_extension_handler_t = _cef_extension_handler_t;
#[doc = ""]
#[doc = " Supports discovery of and communication with media devices on the local"]
#[doc = " network via the Cast and DIAL protocols. The functions of this structure may"]
#[doc = " be called on any browser process thread unless otherwise indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_router_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Add an observer for MediaRouter events. The observer will remain"]
    #[doc = " registered until the returned Registration object is destroyed."]
    #[doc = ""]
    pub add_observer: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_router_t,
            observer: *mut _cef_media_observer_t,
        ) -> *mut _cef_registration_t,
    >,
    #[doc = ""]
    #[doc = " Returns a MediaSource object for the specified media source URN. Supported"]
    #[doc = " URN schemes include \"cast:\" and \"dial:\", and will be already known by the"]
    #[doc = " client application (e.g. \"cast:<appId>?clientId=<clientId>\")."]
    #[doc = ""]
    pub get_source: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_router_t,
            urn: *const cef_string_t,
        ) -> *mut _cef_media_source_t,
    >,
    #[doc = ""]
    #[doc = " Trigger an asynchronous call to cef_media_observer_t::OnSinks on all"]
    #[doc = " registered observers."]
    #[doc = ""]
    pub notify_current_sinks:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_media_router_t)>,
    #[doc = ""]
    #[doc = " Create a new route between |source| and |sink|. Source and sink must be"]
    #[doc = " valid, compatible (as reported by cef_media_sink_t::IsCompatibleWith), and"]
    #[doc = " a route between them must not already exist. |callback| will be executed"]
    #[doc = " on success or failure. If route creation succeeds it will also trigger an"]
    #[doc = " asynchronous call to cef_media_observer_t::OnRoutes on all registered"]
    #[doc = " observers."]
    #[doc = ""]
    pub create_route: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_router_t,
            source: *mut _cef_media_source_t,
            sink: *mut _cef_media_sink_t,
            callback: *mut _cef_media_route_create_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Trigger an asynchronous call to cef_media_observer_t::OnRoutes on all"]
    #[doc = " registered observers."]
    #[doc = ""]
    pub notify_current_routes:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_media_router_t)>,
}
#[test]
fn bindgen_test_layout__cef_media_router_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_media_router_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_media_router_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_media_router_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_router_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_router_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_router_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_add_observer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_router_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_observer) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_router_t),
                "::",
                stringify!(add_observer)
            )
        );
    }
    test_field_add_observer();
    fn test_field_get_source() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_router_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_source) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_router_t),
                "::",
                stringify!(get_source)
            )
        );
    }
    test_field_get_source();
    fn test_field_notify_current_sinks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_router_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notify_current_sinks) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_router_t),
                "::",
                stringify!(notify_current_sinks)
            )
        );
    }
    test_field_notify_current_sinks();
    fn test_field_create_route() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_router_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).create_route) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_router_t),
                "::",
                stringify!(create_route)
            )
        );
    }
    test_field_create_route();
    fn test_field_notify_current_routes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_router_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notify_current_routes) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_router_t),
                "::",
                stringify!(notify_current_routes)
            )
        );
    }
    test_field_notify_current_routes();
}
#[doc = ""]
#[doc = " Supports discovery of and communication with media devices on the local"]
#[doc = " network via the Cast and DIAL protocols. The functions of this structure may"]
#[doc = " be called on any browser process thread unless otherwise indicated."]
#[doc = ""]
pub type cef_media_router_t = _cef_media_router_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns the MediaRouter object associated with the global request context."]
    #[doc = " If |callback| is non-NULL it will be executed asnychronously on the UI"]
    #[doc = " thread after the manager's storage has been initialized. Equivalent to"]
    #[doc = " calling cef_request_context_t::cef_request_context_get_global_context()->get"]
    #[doc = " _media_router()."]
    #[doc = ""]
    pub fn cef_media_router_get_global(
        callback: *mut _cef_completion_callback_t,
    ) -> *mut cef_media_router_t;
}
#[doc = ""]
#[doc = " Implemented by the client to observe MediaRouter events and registered via"]
#[doc = " cef_media_router_t::AddObserver. The functions of this structure will be"]
#[doc = " called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_observer_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " The list of available media sinks has changed or"]
    #[doc = " cef_media_router_t::NotifyCurrentSinks was called."]
    #[doc = ""]
    pub on_sinks: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_observer_t,
            sinksCount: size_t,
            sinks: *const *mut _cef_media_sink_t,
        ),
    >,
    #[doc = ""]
    #[doc = " The list of available media routes has changed or"]
    #[doc = " cef_media_router_t::NotifyCurrentRoutes was called."]
    #[doc = ""]
    pub on_routes: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_observer_t,
            routesCount: size_t,
            routes: *const *mut _cef_media_route_t,
        ),
    >,
    #[doc = ""]
    #[doc = " The connection state of |route| has changed."]
    #[doc = ""]
    pub on_route_state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_observer_t,
            route: *mut _cef_media_route_t,
            state: cef_media_route_connection_state_t,
        ),
    >,
    #[doc = ""]
    #[doc = " A message was recieved over |route|. |message| is only valid for the scope"]
    #[doc = " of this callback and should be copied if necessary."]
    #[doc = ""]
    pub on_route_message_received: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_observer_t,
            route: *mut _cef_media_route_t,
            message: *const ::std::os::raw::c_void,
            message_size: size_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_media_observer_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_media_observer_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_media_observer_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_media_observer_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_observer_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_observer_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_sinks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_sinks) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_observer_t),
                "::",
                stringify!(on_sinks)
            )
        );
    }
    test_field_on_sinks();
    fn test_field_on_routes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_routes) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_observer_t),
                "::",
                stringify!(on_routes)
            )
        );
    }
    test_field_on_routes();
    fn test_field_on_route_state_changed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_route_state_changed) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_observer_t),
                "::",
                stringify!(on_route_state_changed)
            )
        );
    }
    test_field_on_route_state_changed();
    fn test_field_on_route_message_received() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_observer_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_route_message_received) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_observer_t),
                "::",
                stringify!(on_route_message_received)
            )
        );
    }
    test_field_on_route_message_received();
}
#[doc = ""]
#[doc = " Implemented by the client to observe MediaRouter events and registered via"]
#[doc = " cef_media_router_t::AddObserver. The functions of this structure will be"]
#[doc = " called on the browser process UI thread."]
#[doc = ""]
pub type cef_media_observer_t = _cef_media_observer_t;
#[doc = ""]
#[doc = " Represents the route between a media source and sink. Instances of this"]
#[doc = " object are created via cef_media_router_t::CreateRoute and retrieved via"]
#[doc = " cef_media_observer_t::OnRoutes. Contains the status and metadata of a"]
#[doc = " routing operation. The functions of this structure may be called on any"]
#[doc = " browser process thread unless otherwise indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_route_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the ID for this route."]
    #[doc = ""]
    pub get_id: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_route_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the source associated with this route."]
    #[doc = ""]
    pub get_source: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_route_t) -> *mut _cef_media_source_t,
    >,
    #[doc = ""]
    #[doc = " Returns the sink associated with this route."]
    #[doc = ""]
    pub get_sink: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_route_t) -> *mut _cef_media_sink_t,
    >,
    #[doc = ""]
    #[doc = " Send a message over this route. |message| will be copied if necessary."]
    #[doc = ""]
    pub send_route_message: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_route_t,
            message: *const ::std::os::raw::c_void,
            message_size: size_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Terminate this route. Will result in an asynchronous call to"]
    #[doc = " cef_media_observer_t::OnRoutes on all registered observers."]
    #[doc = ""]
    pub terminate: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_media_route_t)>,
}
#[test]
fn bindgen_test_layout__cef_media_route_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_media_route_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_media_route_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_media_route_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_route_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_route_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_route_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_route_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_route_t),
                "::",
                stringify!(get_id)
            )
        );
    }
    test_field_get_id();
    fn test_field_get_source() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_route_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_source) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_route_t),
                "::",
                stringify!(get_source)
            )
        );
    }
    test_field_get_source();
    fn test_field_get_sink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_route_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_sink) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_route_t),
                "::",
                stringify!(get_sink)
            )
        );
    }
    test_field_get_sink();
    fn test_field_send_route_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_route_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send_route_message) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_route_t),
                "::",
                stringify!(send_route_message)
            )
        );
    }
    test_field_send_route_message();
    fn test_field_terminate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_route_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).terminate) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_route_t),
                "::",
                stringify!(terminate)
            )
        );
    }
    test_field_terminate();
}
#[doc = ""]
#[doc = " Represents the route between a media source and sink. Instances of this"]
#[doc = " object are created via cef_media_router_t::CreateRoute and retrieved via"]
#[doc = " cef_media_observer_t::OnRoutes. Contains the status and metadata of a"]
#[doc = " routing operation. The functions of this structure may be called on any"]
#[doc = " browser process thread unless otherwise indicated."]
#[doc = ""]
pub type cef_media_route_t = _cef_media_route_t;
#[doc = ""]
#[doc = " Callback structure for cef_media_router_t::CreateRoute. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_route_create_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed when the route creation has finished."]
    #[doc = " |result| will be CEF_MRCR_OK if the route creation succeeded. |error| will"]
    #[doc = " be a description of the error if the route creation failed. |route| is the"]
    #[doc = " resulting route, or NULL if the route creation failed."]
    #[doc = ""]
    pub on_media_route_create_finished: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_route_create_callback_t,
            result: cef_media_route_create_result_t,
            error: *const cef_string_t,
            route: *mut _cef_media_route_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_media_route_create_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_media_route_create_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_media_route_create_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_media_route_create_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_media_route_create_callback_t)
        )
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_cef_media_route_create_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_route_create_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_media_route_create_finished() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_cef_media_route_create_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_media_route_create_finished) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_route_create_callback_t),
                "::",
                stringify!(on_media_route_create_finished)
            )
        );
    }
    test_field_on_media_route_create_finished();
}
#[doc = ""]
#[doc = " Callback structure for cef_media_router_t::CreateRoute. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
pub type cef_media_route_create_callback_t = _cef_media_route_create_callback_t;
#[doc = ""]
#[doc = " Represents a sink to which media can be routed. Instances of this object are"]
#[doc = " retrieved via cef_media_observer_t::OnSinks. The functions of this structure"]
#[doc = " may be called on any browser process thread unless otherwise indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_sink_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the ID for this sink."]
    #[doc = ""]
    pub get_id: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the name of this sink."]
    #[doc = ""]
    pub get_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the description of this sink."]
    #[doc = ""]
    pub get_description: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the icon type for this sink."]
    #[doc = ""]
    pub get_icon_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> cef_media_sink_icon_type_t,
    >,
    #[doc = ""]
    #[doc = " Asynchronously retrieves device info."]
    #[doc = ""]
    pub get_device_info: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_sink_t,
            callback: *mut _cef_media_sink_device_info_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this sink accepts content via Cast."]
    #[doc = ""]
    pub is_cast_sink: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this sink accepts content via DIAL."]
    #[doc = ""]
    pub is_dial_sink: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_sink_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this sink is compatible with |source|."]
    #[doc = ""]
    pub is_compatible_with: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_sink_t,
            source: *mut _cef_media_source_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_media_sink_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_media_sink_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_media_sink_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_media_sink_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_sink_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_t),
                "::",
                stringify!(get_id)
            )
        );
    }
    test_field_get_id();
    fn test_field_get_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_name) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_t),
                "::",
                stringify!(get_name)
            )
        );
    }
    test_field_get_name();
    fn test_field_get_description() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_description) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_t),
                "::",
                stringify!(get_description)
            )
        );
    }
    test_field_get_description();
    fn test_field_get_icon_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_icon_type) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_t),
                "::",
                stringify!(get_icon_type)
            )
        );
    }
    test_field_get_icon_type();
    fn test_field_get_device_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_device_info) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_t),
                "::",
                stringify!(get_device_info)
            )
        );
    }
    test_field_get_device_info();
    fn test_field_is_cast_sink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_cast_sink) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_t),
                "::",
                stringify!(is_cast_sink)
            )
        );
    }
    test_field_is_cast_sink();
    fn test_field_is_dial_sink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_dial_sink) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_t),
                "::",
                stringify!(is_dial_sink)
            )
        );
    }
    test_field_is_dial_sink();
    fn test_field_is_compatible_with() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_sink_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_compatible_with) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_t),
                "::",
                stringify!(is_compatible_with)
            )
        );
    }
    test_field_is_compatible_with();
}
#[doc = ""]
#[doc = " Represents a sink to which media can be routed. Instances of this object are"]
#[doc = " retrieved via cef_media_observer_t::OnSinks. The functions of this structure"]
#[doc = " may be called on any browser process thread unless otherwise indicated."]
#[doc = ""]
pub type cef_media_sink_t = _cef_media_sink_t;
#[doc = ""]
#[doc = " Callback structure for cef_media_sink_t::GetDeviceInfo. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_sink_device_info_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed asyncronously once device information has"]
    #[doc = " been retrieved."]
    #[doc = ""]
    pub on_media_sink_device_info: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_media_sink_device_info_callback_t,
            device_info: *const _cef_media_sink_device_info_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_media_sink_device_info_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_media_sink_device_info_callback_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_cef_media_sink_device_info_callback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_media_sink_device_info_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_media_sink_device_info_callback_t)
        )
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_cef_media_sink_device_info_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_device_info_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_media_sink_device_info() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_cef_media_sink_device_info_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_media_sink_device_info) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_sink_device_info_callback_t),
                "::",
                stringify!(on_media_sink_device_info)
            )
        );
    }
    test_field_on_media_sink_device_info();
}
#[doc = ""]
#[doc = " Callback structure for cef_media_sink_t::GetDeviceInfo. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
pub type cef_media_sink_device_info_callback_t = _cef_media_sink_device_info_callback_t;
#[doc = ""]
#[doc = " Represents a source from which media can be routed. Instances of this object"]
#[doc = " are retrieved via cef_media_router_t::GetSource. The functions of this"]
#[doc = " structure may be called on any browser process thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_source_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the ID (media source URN or URL) for this source."]
    #[doc = ""]
    pub get_id: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_source_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this source outputs its content via Cast."]
    #[doc = ""]
    pub is_cast_source: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_source_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this source outputs its content via DIAL."]
    #[doc = ""]
    pub is_dial_source: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_source_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_media_source_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_media_source_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_media_source_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_media_source_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_source_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_source_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_source_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_source_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_source_t),
                "::",
                stringify!(get_id)
            )
        );
    }
    test_field_get_id();
    fn test_field_is_cast_source() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_source_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_cast_source) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_source_t),
                "::",
                stringify!(is_cast_source)
            )
        );
    }
    test_field_is_cast_source();
    fn test_field_is_dial_source() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_source_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_dial_source) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_source_t),
                "::",
                stringify!(is_dial_source)
            )
        );
    }
    test_field_is_dial_source();
}
#[doc = ""]
#[doc = " Represents a source from which media can be routed. Instances of this object"]
#[doc = " are retrieved via cef_media_router_t::GetSource. The functions of this"]
#[doc = " structure may be called on any browser process thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
pub type cef_media_source_t = _cef_media_source_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_context_handler_t {
    _unused: [u8; 0],
}
#[doc = ""]
#[doc = " Callback structure for cef_request_context_t::ResolveHost."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resolve_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called on the UI thread after the ResolveHost request has completed."]
    #[doc = " |result| will be the result code. |resolved_ips| will be the list of"]
    #[doc = " resolved IP addresses or NULL if the resolution failed."]
    #[doc = ""]
    pub on_resolve_completed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resolve_callback_t,
            result: cef_errorcode_t,
            resolved_ips: cef_string_list_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_resolve_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_resolve_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_resolve_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_resolve_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resolve_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resolve_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resolve_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_resolve_completed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resolve_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_resolve_completed) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resolve_callback_t),
                "::",
                stringify!(on_resolve_completed)
            )
        );
    }
    test_field_on_resolve_completed();
}
#[doc = ""]
#[doc = " Callback structure for cef_request_context_t::ResolveHost."]
#[doc = ""]
pub type cef_resolve_callback_t = _cef_resolve_callback_t;
#[doc = ""]
#[doc = " A request context provides request handling for a set of related browser or"]
#[doc = " URL request objects. A request context can be specified when creating a new"]
#[doc = " browser via the cef_browser_host_t static factory functions or when creating"]
#[doc = " a new URL request via the cef_urlrequest_t static factory functions. Browser"]
#[doc = " objects with different request contexts will never be hosted in the same"]
#[doc = " render process. Browser objects with the same request context may or may not"]
#[doc = " be hosted in the same render process depending on the process model. Browser"]
#[doc = " objects created indirectly via the JavaScript window.open function or"]
#[doc = " targeted links will share the same render process and the same request"]
#[doc = " context as the source browser. When running in single-process mode there is"]
#[doc = " only a single render process (the main process) and so all browsers created"]
#[doc = " in single-process mode will share the same request context. This will be the"]
#[doc = " first request context passed into a cef_browser_host_t static factory"]
#[doc = " function and all other request context objects will be ignored."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_context_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same context as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            other: *mut _cef_request_context_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is sharing the same storage as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_sharing_with: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            other: *mut _cef_request_context_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is the global context. The global context"]
    #[doc = " is used by default when creating a browser or URL request with a NULL"]
    #[doc = " context argument."]
    #[doc = ""]
    pub is_global: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_context_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the handler for this context if any."]
    #[doc = ""]
    pub get_handler: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
        ) -> *mut _cef_request_context_handler_t,
    >,
    #[doc = ""]
    #[doc = " Returns the cache path for this object. If NULL an \"incognito mode\" in-"]
    #[doc = " memory cache is being used."]
    #[doc = ""]
    pub get_cache_path: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_context_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the cookie manager for this object. If |callback| is non-NULL it"]
    #[doc = " will be executed asnychronously on the UI thread after the manager's"]
    #[doc = " storage has been initialized."]
    #[doc = ""]
    pub get_cookie_manager: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ) -> *mut _cef_cookie_manager_t,
    >,
    #[doc = ""]
    #[doc = " Register a scheme handler factory for the specified |scheme_name| and"]
    #[doc = " optional |domain_name|. An NULL |domain_name| value for a standard scheme"]
    #[doc = " will cause the factory to match all domain names. The |domain_name| value"]
    #[doc = " will be ignored for non-standard schemes. If |scheme_name| is a built-in"]
    #[doc = " scheme and no handler is returned by |factory| then the built-in scheme"]
    #[doc = " handler factory will be called. If |scheme_name| is a custom scheme then"]
    #[doc = " you must also implement the cef_app_t::on_register_custom_schemes()"]
    #[doc = " function in all processes. This function may be called multiple times to"]
    #[doc = " change or remove the factory that matches the specified |scheme_name| and"]
    #[doc = " optional |domain_name|. Returns false (0) if an error occurs. This"]
    #[doc = " function may be called on any thread in the browser process."]
    #[doc = ""]
    pub register_scheme_handler_factory: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            scheme_name: *const cef_string_t,
            domain_name: *const cef_string_t,
            factory: *mut _cef_scheme_handler_factory_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Clear all registered scheme handler factories. Returns false (0) on error."]
    #[doc = " This function may be called on any thread in the browser process."]
    #[doc = ""]
    pub clear_scheme_handler_factories: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_context_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if a preference with the specified |name| exists. This"]
    #[doc = " function must be called on the browser process UI thread."]
    #[doc = ""]
    pub has_preference: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value for the preference with the specified |name|. Returns"]
    #[doc = " NULL if the preference does not exist. The returned object contains a copy"]
    #[doc = " of the underlying preference value and modifications to the returned"]
    #[doc = " object will not modify the underlying preference value. This function must"]
    #[doc = " be called on the browser process UI thread."]
    #[doc = ""]
    pub get_preference: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
        ) -> *mut _cef_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns all preferences as a dictionary. If |include_defaults| is true (1)"]
    #[doc = " then preferences currently at their default value will be included. The"]
    #[doc = " returned object contains a copy of the underlying preference values and"]
    #[doc = " modifications to the returned object will not modify the underlying"]
    #[doc = " preference values. This function must be called on the browser process UI"]
    #[doc = " thread."]
    #[doc = ""]
    pub get_all_preferences: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            include_defaults: ::std::os::raw::c_int,
        ) -> *mut _cef_dictionary_value_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the preference with the specified |name| can be"]
    #[doc = " modified using SetPreference. As one example preferences set via the"]
    #[doc = " command-line usually cannot be modified. This function must be called on"]
    #[doc = " the browser process UI thread."]
    #[doc = ""]
    pub can_set_preference: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the |value| associated with preference |name|. Returns true (1) if the"]
    #[doc = " value is set successfully and false (0) otherwise. If |value| is NULL the"]
    #[doc = " preference will be restored to its default value. If setting the"]
    #[doc = " preference fails then |error| will be populated with a detailed"]
    #[doc = " description of the problem. This function must be called on the browser"]
    #[doc = " process UI thread."]
    #[doc = ""]
    pub set_preference: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            name: *const cef_string_t,
            value: *mut _cef_value_t,
            error: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Clears all certificate exceptions that were added as part of handling"]
    #[doc = " cef_request_handler_t::on_certificate_error(). If you call this it is"]
    #[doc = " recommended that you also call close_all_connections() or you risk not"]
    #[doc = " being prompted again for server certificates if you reconnect quickly. If"]
    #[doc = " |callback| is non-NULL it will be executed on the UI thread after"]
    #[doc = " completion."]
    #[doc = ""]
    pub clear_certificate_exceptions: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Clears all HTTP authentication credentials that were added as part of"]
    #[doc = " handling GetAuthCredentials. If |callback| is non-NULL it will be executed"]
    #[doc = " on the UI thread after completion."]
    #[doc = ""]
    pub clear_http_auth_credentials: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Clears all active and idle connections that Chromium currently has. This"]
    #[doc = " is only recommended if you have released all other CEF objects but don't"]
    #[doc = " yet want to call cef_shutdown(). If |callback| is non-NULL it will be"]
    #[doc = " executed on the UI thread after completion."]
    #[doc = ""]
    pub close_all_connections: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Attempts to resolve |origin| to a list of associated IP addresses."]
    #[doc = " |callback| will be executed on the UI thread after completion."]
    #[doc = ""]
    pub resolve_host: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            origin: *const cef_string_t,
            callback: *mut _cef_resolve_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Load an extension."]
    #[doc = ""]
    #[doc = " If extension resources will be read from disk using the default load"]
    #[doc = " implementation then |root_directory| should be the absolute path to the"]
    #[doc = " extension resources directory and |manifest| should be NULL. If extension"]
    #[doc = " resources will be provided by the client (e.g. via cef_request_handler_t"]
    #[doc = " and/or cef_extension_handler_t) then |root_directory| should be a path"]
    #[doc = " component unique to the extension (if not absolute this will be internally"]
    #[doc = " prefixed with the PK_DIR_RESOURCES path) and |manifest| should contain the"]
    #[doc = " contents that would otherwise be read from the \"manifest.json\" file on"]
    #[doc = " disk."]
    #[doc = ""]
    #[doc = " The loaded extension will be accessible in all contexts sharing the same"]
    #[doc = " storage (HasExtension returns true (1)). However, only the context on"]
    #[doc = " which this function was called is considered the loader (DidLoadExtension"]
    #[doc = " returns true (1)) and only the loader will receive"]
    #[doc = " cef_request_context_handler_t callbacks for the extension."]
    #[doc = ""]
    #[doc = " cef_extension_handler_t::OnExtensionLoaded will be called on load success"]
    #[doc = " or cef_extension_handler_t::OnExtensionLoadFailed will be called on load"]
    #[doc = " failure."]
    #[doc = ""]
    #[doc = " If the extension specifies a background script via the \"background\""]
    #[doc = " manifest key then cef_extension_handler_t::OnBeforeBackgroundBrowser will"]
    #[doc = " be called to create the background browser. See that function for"]
    #[doc = " additional information about background scripts."]
    #[doc = ""]
    #[doc = " For visible extension views the client application should evaluate the"]
    #[doc = " manifest to determine the correct extension URL to load and then pass that"]
    #[doc = " URL to the cef_browser_host_t::CreateBrowser* function after the extension"]
    #[doc = " has loaded. For example, the client can look for the \"browser_action\""]
    #[doc = " manifest key as documented at"]
    #[doc = " https://developer.chrome.com/extensions/browserAction. Extension URLs take"]
    #[doc = " the form \"chrome-extension://<extension_id>/<path>\"."]
    #[doc = ""]
    #[doc = " Browsers that host extensions differ from normal browsers as follows:"]
    #[doc = "  - Can access chrome.* JavaScript APIs if allowed by the manifest. Visit"]
    #[doc = "    chrome://extensions-support for the list of extension APIs currently"]
    #[doc = "    supported by CEF."]
    #[doc = "  - Main frame navigation to non-extension content is blocked."]
    #[doc = "  - Pinch-zooming is disabled."]
    #[doc = "  - CefBrowserHost::GetExtension returns the hosted extension."]
    #[doc = "  - CefBrowserHost::IsBackgroundHost returns true for background hosts."]
    #[doc = ""]
    #[doc = " See https://developer.chrome.com/extensions for extension implementation"]
    #[doc = " and usage documentation."]
    #[doc = ""]
    pub load_extension: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            root_directory: *const cef_string_t,
            manifest: *mut _cef_dictionary_value_t,
            handler: *mut _cef_extension_handler_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this context was used to load the extension identified"]
    #[doc = " by |extension_id|. Other contexts sharing the same storage will also have"]
    #[doc = " access to the extension (see HasExtension). This function must be called"]
    #[doc = " on the browser process UI thread."]
    #[doc = ""]
    pub did_load_extension: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            extension_id: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this context has access to the extension identified by"]
    #[doc = " |extension_id|. This may not be the context that was used to load the"]
    #[doc = " extension (see DidLoadExtension). This function must be called on the"]
    #[doc = " browser process UI thread."]
    #[doc = ""]
    pub has_extension: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            extension_id: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Retrieve the list of all extensions that this context has access to (see"]
    #[doc = " HasExtension). |extension_ids| will be populated with the list of"]
    #[doc = " extension ID values. Returns true (1) on success. This function must be"]
    #[doc = " called on the browser process UI thread."]
    #[doc = ""]
    pub get_extensions: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            extension_ids: cef_string_list_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the extension matching |extension_id| or NULL if no matching"]
    #[doc = " extension is accessible in this context (see HasExtension). This function"]
    #[doc = " must be called on the browser process UI thread."]
    #[doc = ""]
    pub get_extension: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            extension_id: *const cef_string_t,
        ) -> *mut _cef_extension_t,
    >,
    #[doc = ""]
    #[doc = " Returns the MediaRouter object associated with this context.  If"]
    #[doc = " |callback| is non-NULL it will be executed asnychronously on the UI thread"]
    #[doc = " after the manager's context has been initialized."]
    #[doc = ""]
    pub get_media_router: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_context_t,
            callback: *mut _cef_completion_callback_t,
        ) -> *mut _cef_media_router_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_request_context_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_request_context_t>(),
        224usize,
        concat!("Size of: ", stringify!(_cef_request_context_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_request_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_request_context_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_is_sharing_with() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_sharing_with) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(is_sharing_with)
            )
        );
    }
    test_field_is_sharing_with();
    fn test_field_is_global() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_global) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(is_global)
            )
        );
    }
    test_field_is_global();
    fn test_field_get_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_handler) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(get_handler)
            )
        );
    }
    test_field_get_handler();
    fn test_field_get_cache_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_cache_path) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(get_cache_path)
            )
        );
    }
    test_field_get_cache_path();
    fn test_field_get_cookie_manager() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_cookie_manager) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(get_cookie_manager)
            )
        );
    }
    test_field_get_cookie_manager();
    fn test_field_register_scheme_handler_factory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).register_scheme_handler_factory) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(register_scheme_handler_factory)
            )
        );
    }
    test_field_register_scheme_handler_factory();
    fn test_field_clear_scheme_handler_factories() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clear_scheme_handler_factories) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(clear_scheme_handler_factories)
            )
        );
    }
    test_field_clear_scheme_handler_factories();
    fn test_field_has_preference() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_preference) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(has_preference)
            )
        );
    }
    test_field_has_preference();
    fn test_field_get_preference() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_preference) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(get_preference)
            )
        );
    }
    test_field_get_preference();
    fn test_field_get_all_preferences() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_all_preferences) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(get_all_preferences)
            )
        );
    }
    test_field_get_all_preferences();
    fn test_field_can_set_preference() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).can_set_preference) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(can_set_preference)
            )
        );
    }
    test_field_can_set_preference();
    fn test_field_set_preference() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_preference) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(set_preference)
            )
        );
    }
    test_field_set_preference();
    fn test_field_clear_certificate_exceptions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clear_certificate_exceptions) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(clear_certificate_exceptions)
            )
        );
    }
    test_field_clear_certificate_exceptions();
    fn test_field_clear_http_auth_credentials() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clear_http_auth_credentials) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(clear_http_auth_credentials)
            )
        );
    }
    test_field_clear_http_auth_credentials();
    fn test_field_close_all_connections() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).close_all_connections) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(close_all_connections)
            )
        );
    }
    test_field_close_all_connections();
    fn test_field_resolve_host() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resolve_host) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(resolve_host)
            )
        );
    }
    test_field_resolve_host();
    fn test_field_load_extension() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).load_extension) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(load_extension)
            )
        );
    }
    test_field_load_extension();
    fn test_field_did_load_extension() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).did_load_extension) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(did_load_extension)
            )
        );
    }
    test_field_did_load_extension();
    fn test_field_has_extension() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_extension) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(has_extension)
            )
        );
    }
    test_field_has_extension();
    fn test_field_get_extensions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_extensions) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(get_extensions)
            )
        );
    }
    test_field_get_extensions();
    fn test_field_get_extension() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_extension) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(get_extension)
            )
        );
    }
    test_field_get_extension();
    fn test_field_get_media_router() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_media_router) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_context_t),
                "::",
                stringify!(get_media_router)
            )
        );
    }
    test_field_get_media_router();
}
#[doc = ""]
#[doc = " A request context provides request handling for a set of related browser or"]
#[doc = " URL request objects. A request context can be specified when creating a new"]
#[doc = " browser via the cef_browser_host_t static factory functions or when creating"]
#[doc = " a new URL request via the cef_urlrequest_t static factory functions. Browser"]
#[doc = " objects with different request contexts will never be hosted in the same"]
#[doc = " render process. Browser objects with the same request context may or may not"]
#[doc = " be hosted in the same render process depending on the process model. Browser"]
#[doc = " objects created indirectly via the JavaScript window.open function or"]
#[doc = " targeted links will share the same render process and the same request"]
#[doc = " context as the source browser. When running in single-process mode there is"]
#[doc = " only a single render process (the main process) and so all browsers created"]
#[doc = " in single-process mode will share the same request context. This will be the"]
#[doc = " first request context passed into a cef_browser_host_t static factory"]
#[doc = " function and all other request context objects will be ignored."]
#[doc = ""]
pub type cef_request_context_t = _cef_request_context_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns the global context object."]
    #[doc = ""]
    pub fn cef_request_context_get_global_context() -> *mut cef_request_context_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new context object with the specified |settings| and optional"]
    #[doc = " |handler|."]
    #[doc = ""]
    pub fn cef_request_context_create_context(
        settings: *const _cef_request_context_settings_t,
        handler: *mut _cef_request_context_handler_t,
    ) -> *mut cef_request_context_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Creates a new context object that shares storage with |other| and uses an"]
    #[doc = " optional |handler|."]
    #[doc = ""]
    pub fn cef_create_context_shared(
        other: *mut cef_request_context_t,
        handler: *mut _cef_request_context_handler_t,
    ) -> *mut cef_request_context_t;
}
#[doc = ""]
#[doc = " Structure used to represent a browser. When used in the browser process the"]
#[doc = " functions of this structure may be called on any thread unless otherwise"]
#[doc = " indicated in the comments. When used in the render process the functions of"]
#[doc = " this structure may only be called on the main thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_browser_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " True if this object is currently valid. This will return false (0) after"]
    #[doc = " cef_life_span_handler_t::OnBeforeClose is called."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the browser host object. This function can only be called in the"]
    #[doc = " browser process."]
    #[doc = ""]
    pub get_host: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> *mut _cef_browser_host_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the browser can navigate backwards."]
    #[doc = ""]
    pub can_go_back: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Navigate backwards."]
    #[doc = ""]
    pub go_back: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = ""]
    #[doc = " Returns true (1) if the browser can navigate forwards."]
    #[doc = ""]
    pub can_go_forward: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Navigate forwards."]
    #[doc = ""]
    pub go_forward: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = ""]
    #[doc = " Returns true (1) if the browser is currently loading."]
    #[doc = ""]
    pub is_loading: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Reload the current page."]
    #[doc = ""]
    pub reload: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = ""]
    #[doc = " Reload the current page ignoring any cached data."]
    #[doc = ""]
    pub reload_ignore_cache:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = ""]
    #[doc = " Stop loading the page."]
    #[doc = ""]
    pub stop_load: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t)>,
    #[doc = ""]
    #[doc = " Returns the globally unique identifier for this browser. This value is"]
    #[doc = " also used as the tabId for extension APIs."]
    #[doc = ""]
    pub get_identifier: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same handle as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_t,
            that: *mut _cef_browser_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the browser is a popup."]
    #[doc = ""]
    pub is_popup: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if a document has been loaded in the browser."]
    #[doc = ""]
    pub has_document: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the main (top-level) frame for the browser. In the browser process"]
    #[doc = " this will return a valid object until after"]
    #[doc = " cef_life_span_handler_t::OnBeforeClose is called. In the renderer process"]
    #[doc = " this will return NULL if the main frame is hosted in a different renderer"]
    #[doc = " process (e.g. for cross-origin sub-frames). The main frame object will"]
    #[doc = " change during cross-origin navigation or re-navigation after renderer"]
    #[doc = " process termination (due to crashes, etc)."]
    #[doc = ""]
    pub get_main_frame: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> *mut _cef_frame_t,
    >,
    #[doc = ""]
    #[doc = " Returns the focused frame for the browser."]
    #[doc = ""]
    pub get_focused_frame: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t) -> *mut _cef_frame_t,
    >,
    #[doc = ""]
    #[doc = " Returns the frame with the specified identifier, or NULL if not found."]
    #[doc = ""]
    pub get_frame_byident: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t, identifier: int64) -> *mut _cef_frame_t,
    >,
    #[doc = ""]
    #[doc = " Returns the frame with the specified name, or NULL if not found."]
    #[doc = ""]
    pub get_frame: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_t,
            name: *const cef_string_t,
        ) -> *mut _cef_frame_t,
    >,
    #[doc = ""]
    #[doc = " Returns the number of frames that currently exist."]
    #[doc = ""]
    pub get_frame_count:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_t) -> size_t>,
    #[doc = ""]
    #[doc = " Returns the identifiers of all existing frames."]
    #[doc = ""]
    pub get_frame_identifiers: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_t,
            identifiersCount: *mut size_t,
            identifiers: *mut int64,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns the names of all existing frames."]
    #[doc = ""]
    pub get_frame_names: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_t, names: cef_string_list_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_browser_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_browser_t>(),
        208usize,
        concat!("Size of: ", stringify!(_cef_browser_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_browser_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_browser_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_get_host() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_host) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(get_host)
            )
        );
    }
    test_field_get_host();
    fn test_field_can_go_back() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).can_go_back) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(can_go_back)
            )
        );
    }
    test_field_can_go_back();
    fn test_field_go_back() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).go_back) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(go_back)
            )
        );
    }
    test_field_go_back();
    fn test_field_can_go_forward() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).can_go_forward) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(can_go_forward)
            )
        );
    }
    test_field_can_go_forward();
    fn test_field_go_forward() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).go_forward) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(go_forward)
            )
        );
    }
    test_field_go_forward();
    fn test_field_is_loading() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_loading) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(is_loading)
            )
        );
    }
    test_field_is_loading();
    fn test_field_reload() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reload) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(reload)
            )
        );
    }
    test_field_reload();
    fn test_field_reload_ignore_cache() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reload_ignore_cache) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(reload_ignore_cache)
            )
        );
    }
    test_field_reload_ignore_cache();
    fn test_field_stop_load() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stop_load) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(stop_load)
            )
        );
    }
    test_field_stop_load();
    fn test_field_get_identifier() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_identifier) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(get_identifier)
            )
        );
    }
    test_field_get_identifier();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_is_popup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_popup) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(is_popup)
            )
        );
    }
    test_field_is_popup();
    fn test_field_has_document() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_document) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(has_document)
            )
        );
    }
    test_field_has_document();
    fn test_field_get_main_frame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_main_frame) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(get_main_frame)
            )
        );
    }
    test_field_get_main_frame();
    fn test_field_get_focused_frame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_focused_frame) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(get_focused_frame)
            )
        );
    }
    test_field_get_focused_frame();
    fn test_field_get_frame_byident() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_frame_byident) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(get_frame_byident)
            )
        );
    }
    test_field_get_frame_byident();
    fn test_field_get_frame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_frame) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(get_frame)
            )
        );
    }
    test_field_get_frame();
    fn test_field_get_frame_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_frame_count) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(get_frame_count)
            )
        );
    }
    test_field_get_frame_count();
    fn test_field_get_frame_identifiers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_frame_identifiers) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(get_frame_identifiers)
            )
        );
    }
    test_field_get_frame_identifiers();
    fn test_field_get_frame_names() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_frame_names) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_t),
                "::",
                stringify!(get_frame_names)
            )
        );
    }
    test_field_get_frame_names();
}
#[doc = ""]
#[doc = " Structure used to represent a browser. When used in the browser process the"]
#[doc = " functions of this structure may be called on any thread unless otherwise"]
#[doc = " indicated in the comments. When used in the render process the functions of"]
#[doc = " this structure may only be called on the main thread."]
#[doc = ""]
pub type cef_browser_t = _cef_browser_t;
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::RunFileDialog. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_run_file_dialog_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called asynchronously after the file dialog is dismissed. |file_paths|"]
    #[doc = " will be a single value or a list of values depending on the dialog mode."]
    #[doc = " If the selection was cancelled |file_paths| will be NULL."]
    #[doc = ""]
    pub on_file_dialog_dismissed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_run_file_dialog_callback_t,
            file_paths: cef_string_list_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_run_file_dialog_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_run_file_dialog_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_run_file_dialog_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_run_file_dialog_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_run_file_dialog_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_run_file_dialog_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_run_file_dialog_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_file_dialog_dismissed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_run_file_dialog_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_file_dialog_dismissed) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_run_file_dialog_callback_t),
                "::",
                stringify!(on_file_dialog_dismissed)
            )
        );
    }
    test_field_on_file_dialog_dismissed();
}
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::RunFileDialog. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
pub type cef_run_file_dialog_callback_t = _cef_run_file_dialog_callback_t;
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::GetNavigationEntries. The"]
#[doc = " functions of this structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_navigation_entry_visitor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed. Do not keep a reference to |entry| outside"]
    #[doc = " of this callback. Return true (1) to continue visiting entries or false"]
    #[doc = " (0) to stop. |current| is true (1) if this entry is the currently loaded"]
    #[doc = " navigation entry. |index| is the 0-based index of this entry and |total|"]
    #[doc = " is the total number of entries."]
    #[doc = ""]
    pub visit: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_navigation_entry_visitor_t,
            entry: *mut _cef_navigation_entry_t,
            current: ::std::os::raw::c_int,
            index: ::std::os::raw::c_int,
            total: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_navigation_entry_visitor_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_navigation_entry_visitor_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_navigation_entry_visitor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_navigation_entry_visitor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_navigation_entry_visitor_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_visitor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_visitor_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_visit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_navigation_entry_visitor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).visit) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_navigation_entry_visitor_t),
                "::",
                stringify!(visit)
            )
        );
    }
    test_field_visit();
}
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::GetNavigationEntries. The"]
#[doc = " functions of this structure will be called on the browser process UI thread."]
#[doc = ""]
pub type cef_navigation_entry_visitor_t = _cef_navigation_entry_visitor_t;
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::PrintToPDF. The functions of this"]
#[doc = " structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_pdf_print_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed when the PDF printing has completed. |path|"]
    #[doc = " is the output path. |ok| will be true (1) if the printing completed"]
    #[doc = " successfully or false (0) otherwise."]
    #[doc = ""]
    pub on_pdf_print_finished: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_pdf_print_callback_t,
            path: *const cef_string_t,
            ok: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_pdf_print_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_pdf_print_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_pdf_print_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_pdf_print_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_pdf_print_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_pdf_print_finished() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_pdf_print_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_pdf_print_finished) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_pdf_print_callback_t),
                "::",
                stringify!(on_pdf_print_finished)
            )
        );
    }
    test_field_on_pdf_print_finished();
}
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::PrintToPDF. The functions of this"]
#[doc = " structure will be called on the browser process UI thread."]
#[doc = ""]
pub type cef_pdf_print_callback_t = _cef_pdf_print_callback_t;
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::DownloadImage. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_image_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed when the image download has completed."]
    #[doc = " |image_url| is the URL that was downloaded and |http_status_code| is the"]
    #[doc = " resulting HTTP status code. |image| is the resulting image, possibly at"]
    #[doc = " multiple scale factors, or NULL if the download failed."]
    #[doc = ""]
    pub on_download_image_finished: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_download_image_callback_t,
            image_url: *const cef_string_t,
            http_status_code: ::std::os::raw::c_int,
            image: *mut _cef_image_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_download_image_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_download_image_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_download_image_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_download_image_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_download_image_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_image_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_image_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_download_image_finished() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_image_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_download_image_finished) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_image_callback_t),
                "::",
                stringify!(on_download_image_finished)
            )
        );
    }
    test_field_on_download_image_finished();
}
#[doc = ""]
#[doc = " Callback structure for cef_browser_host_t::DownloadImage. The functions of"]
#[doc = " this structure will be called on the browser process UI thread."]
#[doc = ""]
pub type cef_download_image_callback_t = _cef_download_image_callback_t;
#[doc = ""]
#[doc = " Structure used to represent the browser process aspects of a browser. The"]
#[doc = " functions of this structure can only be called in the browser process. They"]
#[doc = " may be called on any thread in that process unless otherwise indicated in"]
#[doc = " the comments."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_browser_host_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the hosted browser object."]
    #[doc = ""]
    pub get_browser: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_browser_t,
    >,
    #[doc = ""]
    #[doc = " Request that the browser close. The JavaScript 'onbeforeunload' event will"]
    #[doc = " be fired. If |force_close| is false (0) the event handler, if any, will be"]
    #[doc = " allowed to prompt the user and the user can optionally cancel the close."]
    #[doc = " If |force_close| is true (1) the prompt will not be displayed and the"]
    #[doc = " close will proceed. Results in a call to"]
    #[doc = " cef_life_span_handler_t::do_close() if the event handler allows the close"]
    #[doc = " or if |force_close| is true (1). See cef_life_span_handler_t::do_close()"]
    #[doc = " documentation for additional usage information."]
    #[doc = ""]
    pub close_browser: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, force_close: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Helper for closing a browser. Call this function from the top-level window"]
    #[doc = " close handler (if any). Internally this calls CloseBrowser(false (0)) if"]
    #[doc = " the close has not yet been initiated. This function returns false (0)"]
    #[doc = " while the close is pending and true (1) after the close has completed. See"]
    #[doc = " close_browser() and cef_life_span_handler_t::do_close() documentation for"]
    #[doc = " additional usage information. This function must be called on the browser"]
    #[doc = " process UI thread."]
    #[doc = ""]
    pub try_close_browser: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set whether the browser is focused."]
    #[doc = ""]
    pub set_focus: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, focus: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Retrieve the window handle (if any) for this browser. If this browser is"]
    #[doc = " wrapped in a cef_browser_view_t this function should be called on the"]
    #[doc = " browser process UI thread and it will return the handle for the top-level"]
    #[doc = " native window."]
    #[doc = ""]
    pub get_window_handle: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_ulong,
    >,
    #[doc = ""]
    #[doc = " Retrieve the window handle (if any) of the browser that opened this"]
    #[doc = " browser. Will return NULL for non-popup browsers or if this browser is"]
    #[doc = " wrapped in a cef_browser_view_t. This function can be used in combination"]
    #[doc = " with custom handling of modal windows."]
    #[doc = ""]
    pub get_opener_window_handle: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_ulong,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this browser is wrapped in a cef_browser_view_t."]
    #[doc = ""]
    pub has_view: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the client for this browser."]
    #[doc = ""]
    pub get_client: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_client_t,
    >,
    #[doc = ""]
    #[doc = " Returns the request context for this browser."]
    #[doc = ""]
    pub get_request_context: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_request_context_t,
    >,
    #[doc = ""]
    #[doc = " Get the current zoom level. The default zoom level is 0.0. This function"]
    #[doc = " can only be called on the UI thread."]
    #[doc = ""]
    pub get_zoom_level:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> f64>,
    #[doc = ""]
    #[doc = " Change the zoom level to the specified value. Specify 0.0 to reset the"]
    #[doc = " zoom level. If called on the UI thread the change will be applied"]
    #[doc = " immediately. Otherwise, the change will be applied asynchronously on the"]
    #[doc = " UI thread."]
    #[doc = ""]
    pub set_zoom_level: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, zoomLevel: f64),
    >,
    #[doc = ""]
    #[doc = " Call to run a file chooser dialog. Only a single file chooser dialog may"]
    #[doc = " be pending at any given time. |mode| represents the type of dialog to"]
    #[doc = " display. |title| to the title to be used for the dialog and may be NULL to"]
    #[doc = " show the default title (\"Open\" or \"Save\" depending on the mode)."]
    #[doc = " |default_file_path| is the path with optional directory and/or file name"]
    #[doc = " component that will be initially selected in the dialog. |accept_filters|"]
    #[doc = " are used to restrict the selectable file types and may any combination of"]
    #[doc = " (a) valid lower-cased MIME types (e.g. \"text/*\" or \"image/*\"), (b)"]
    #[doc = " individual file extensions (e.g. \".txt\" or \".png\"), or (c) combined"]
    #[doc = " description and file extension delimited using \"|\" and \";\" (e.g. \"Image"]
    #[doc = " Types|.png;.gif;.jpg\"). |callback| will be executed after the dialog is"]
    #[doc = " dismissed or immediately if another dialog is already pending. The dialog"]
    #[doc = " will be initiated asynchronously on the UI thread."]
    #[doc = ""]
    pub run_file_dialog: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            mode: cef_file_dialog_mode_t,
            title: *const cef_string_t,
            default_file_path: *const cef_string_t,
            accept_filters: cef_string_list_t,
            callback: *mut _cef_run_file_dialog_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Download the file at |url| using cef_download_handler_t."]
    #[doc = ""]
    pub start_download: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, url: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Download |image_url| and execute |callback| on completion with the images"]
    #[doc = " received from the renderer. If |is_favicon| is true (1) then cookies are"]
    #[doc = " not sent and not accepted during download. Images with density independent"]
    #[doc = " pixel (DIP) sizes larger than |max_image_size| are filtered out from the"]
    #[doc = " image results. Versions of the image at different scale factors may be"]
    #[doc = " downloaded up to the maximum scale factor supported by the system. If"]
    #[doc = " there are no image results <= |max_image_size| then the smallest image is"]
    #[doc = " resized to |max_image_size| and is the only result. A |max_image_size| of"]
    #[doc = " 0 means unlimited. If |bypass_cache| is true (1) then |image_url| is"]
    #[doc = " requested from the server even if it is present in the browser cache."]
    #[doc = ""]
    pub download_image: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            image_url: *const cef_string_t,
            is_favicon: ::std::os::raw::c_int,
            max_image_size: uint32,
            bypass_cache: ::std::os::raw::c_int,
            callback: *mut _cef_download_image_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Print the current browser contents."]
    #[doc = ""]
    pub print: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Print the current browser contents to the PDF file specified by |path| and"]
    #[doc = " execute |callback| on completion. The caller is responsible for deleting"]
    #[doc = " |path| when done. For PDF printing to work on Linux you must implement the"]
    #[doc = " cef_print_handler_t::GetPdfPaperSize function."]
    #[doc = ""]
    pub print_to_pdf: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            path: *const cef_string_t,
            settings: *const _cef_pdf_print_settings_t,
            callback: *mut _cef_pdf_print_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Search for |searchText|. |forward| indicates whether to search forward or"]
    #[doc = " backward within the page. |matchCase| indicates whether the search should"]
    #[doc = " be case-sensitive. |findNext| indicates whether this is the first request"]
    #[doc = " or a follow-up. The search will be restarted if |searchText| or"]
    #[doc = " |matchCase| change. The search will be stopped if |searchText| is NULL."]
    #[doc = " The cef_find_handler_t instance, if any, returned via"]
    #[doc = " cef_client_t::GetFindHandler will be called to report find results."]
    #[doc = ""]
    pub find: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            searchText: *const cef_string_t,
            forward: ::std::os::raw::c_int,
            matchCase: ::std::os::raw::c_int,
            findNext: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel all searches that are currently going on."]
    #[doc = ""]
    pub stop_finding: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            clearSelection: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Open developer tools (DevTools) in its own browser. The DevTools browser"]
    #[doc = " will remain associated with this browser. If the DevTools browser is"]
    #[doc = " already open then it will be focused, in which case the |windowInfo|,"]
    #[doc = " |client| and |settings| parameters will be ignored. If"]
    #[doc = " |inspect_element_at| is non-NULL then the element at the specified (x,y)"]
    #[doc = " location will be inspected. The |windowInfo| parameter will be ignored if"]
    #[doc = " this browser is wrapped in a cef_browser_view_t."]
    #[doc = ""]
    pub show_dev_tools: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            windowInfo: *const _cef_window_info_t,
            client: *mut _cef_client_t,
            settings: *const _cef_browser_settings_t,
            inspect_element_at: *const cef_point_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Explicitly close the associated DevTools browser, if any."]
    #[doc = ""]
    pub close_dev_tools:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Returns true (1) if this browser currently has an associated DevTools"]
    #[doc = " browser. Must be called on the browser process UI thread."]
    #[doc = ""]
    pub has_dev_tools: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Send a function call message over the DevTools protocol. |message| must be"]
    #[doc = " a UTF8-encoded JSON dictionary that contains \"id\" (int), \"function\""]
    #[doc = " (string) and \"params\" (dictionary, optional) values. See the DevTools"]
    #[doc = " protocol documentation at https://chromedevtools.github.io/devtools-"]
    #[doc = " protocol/ for details of supported functions and the expected \"params\""]
    #[doc = " dictionary contents. |message| will be copied if necessary. This function"]
    #[doc = " will return true (1) if called on the UI thread and the message was"]
    #[doc = " successfully submitted for validation, otherwise false (0). Validation"]
    #[doc = " will be applied asynchronously and any messages that fail due to"]
    #[doc = " formatting errors or missing parameters may be discarded without"]
    #[doc = " notification. Prefer ExecuteDevToolsMethod if a more structured approach"]
    #[doc = " to message formatting is desired."]
    #[doc = ""]
    #[doc = " Every valid function call will result in an asynchronous function result"]
    #[doc = " or error message that references the sent message \"id\". Event messages are"]
    #[doc = " received while notifications are enabled (for example, between function"]
    #[doc = " calls for \"Page.enable\" and \"Page.disable\"). All received messages will be"]
    #[doc = " delivered to the observer(s) registered with AddDevToolsMessageObserver."]
    #[doc = " See cef_dev_tools_message_observer_t::OnDevToolsMessage documentation for"]
    #[doc = " details of received message contents."]
    #[doc = ""]
    #[doc = " Usage of the SendDevToolsMessage, ExecuteDevToolsMethod and"]
    #[doc = " AddDevToolsMessageObserver functions does not require an active DevTools"]
    #[doc = " front-end or remote-debugging session. Other active DevTools sessions will"]
    #[doc = " continue to function independently. However, any modification of global"]
    #[doc = " browser state by one session may not be reflected in the UI of other"]
    #[doc = " sessions."]
    #[doc = ""]
    #[doc = " Communication with the DevTools front-end (when displayed) can be logged"]
    #[doc = " for development purposes by passing the `--devtools-protocol-log-"]
    #[doc = " file=<path>` command-line flag."]
    #[doc = ""]
    pub send_dev_tools_message: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            message: *const ::std::os::raw::c_void,
            message_size: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Execute a function call over the DevTools protocol. This is a more"]
    #[doc = " structured version of SendDevToolsMessage. |message_id| is an incremental"]
    #[doc = " number that uniquely identifies the message (pass 0 to have the next"]
    #[doc = " number assigned automatically based on previous values). |function| is the"]
    #[doc = " function name. |params| are the function parameters, which may be NULL."]
    #[doc = " See the DevTools protocol documentation (linked above) for details of"]
    #[doc = " supported functions and the expected |params| dictionary contents. This"]
    #[doc = " function will return the assigned message ID if called on the UI thread"]
    #[doc = " and the message was successfully submitted for validation, otherwise 0."]
    #[doc = " See the SendDevToolsMessage documentation for additional usage"]
    #[doc = " information."]
    #[doc = ""]
    pub execute_dev_tools_method: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            message_id: ::std::os::raw::c_int,
            method: *const cef_string_t,
            params: *mut _cef_dictionary_value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add an observer for DevTools protocol messages (function results and"]
    #[doc = " events). The observer will remain registered until the returned"]
    #[doc = " Registration object is destroyed. See the SendDevToolsMessage"]
    #[doc = " documentation for additional usage information."]
    #[doc = ""]
    pub add_dev_tools_message_observer: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            observer: *mut _cef_dev_tools_message_observer_t,
        ) -> *mut _cef_registration_t,
    >,
    #[doc = ""]
    #[doc = " Retrieve a snapshot of current navigation entries as values sent to the"]
    #[doc = " specified visitor. If |current_only| is true (1) only the current"]
    #[doc = " navigation entry will be sent, otherwise all navigation entries will be"]
    #[doc = " sent."]
    #[doc = ""]
    pub get_navigation_entries: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            visitor: *mut _cef_navigation_entry_visitor_t,
            current_only: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " If a misspelled word is currently selected in an editable node calling"]
    #[doc = " this function will replace it with the specified |word|."]
    #[doc = ""]
    pub replace_misspelling: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, word: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Add the specified |word| to the spelling dictionary."]
    #[doc = ""]
    pub add_word_to_dictionary: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, word: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if window rendering is disabled."]
    #[doc = ""]
    pub is_window_rendering_disabled: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Notify the browser that the widget has been resized. The browser will"]
    #[doc = " first call cef_render_handler_t::GetViewRect to get the new size and then"]
    #[doc = " call cef_render_handler_t::OnPaint asynchronously with the updated"]
    #[doc = " regions. This function is only used when window rendering is disabled."]
    #[doc = ""]
    pub was_resized: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Notify the browser that it has been hidden or shown. Layouting and"]
    #[doc = " cef_render_handler_t::OnPaint notification will stop when the browser is"]
    #[doc = " hidden. This function is only used when window rendering is disabled."]
    #[doc = ""]
    pub was_hidden: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, hidden: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Send a notification to the browser that the screen info has changed. The"]
    #[doc = " browser will then call cef_render_handler_t::GetScreenInfo to update the"]
    #[doc = " screen information with the new values. This simulates moving the webview"]
    #[doc = " window from one display to another, or changing the properties of the"]
    #[doc = " current display. This function is only used when window rendering is"]
    #[doc = " disabled."]
    #[doc = ""]
    pub notify_screen_info_changed:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Invalidate the view. The browser will call cef_render_handler_t::OnPaint"]
    #[doc = " asynchronously. This function is only used when window rendering is"]
    #[doc = " disabled."]
    #[doc = ""]
    pub invalidate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, type_: cef_paint_element_type_t),
    >,
    #[doc = ""]
    #[doc = " Issue a BeginFrame request to Chromium.  Only valid when"]
    #[doc = " cef_window_tInfo::external_begin_frame_enabled is set to true (1)."]
    #[doc = ""]
    pub send_external_begin_frame:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Send a key event to the browser."]
    #[doc = ""]
    pub send_key_event: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, event: *const cef_key_event_t),
    >,
    #[doc = ""]
    #[doc = " Send a mouse click event to the browser. The |x| and |y| coordinates are"]
    #[doc = " relative to the upper-left corner of the view."]
    #[doc = ""]
    pub send_mouse_click_event: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const cef_mouse_event_t,
            type_: cef_mouse_button_type_t,
            mouseUp: ::std::os::raw::c_int,
            clickCount: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Send a mouse move event to the browser. The |x| and |y| coordinates are"]
    #[doc = " relative to the upper-left corner of the view."]
    #[doc = ""]
    pub send_mouse_move_event: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const cef_mouse_event_t,
            mouseLeave: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Send a mouse wheel event to the browser. The |x| and |y| coordinates are"]
    #[doc = " relative to the upper-left corner of the view. The |deltaX| and |deltaY|"]
    #[doc = " values represent the movement delta in the X and Y directions"]
    #[doc = " respectively. In order to scroll inside select popups with window"]
    #[doc = " rendering disabled cef_render_handler_t::GetScreenPoint should be"]
    #[doc = " implemented properly."]
    #[doc = ""]
    pub send_mouse_wheel_event: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const cef_mouse_event_t,
            deltaX: ::std::os::raw::c_int,
            deltaY: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Send a touch event to the browser for a windowless browser."]
    #[doc = ""]
    pub send_touch_event: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, event: *const cef_touch_event_t),
    >,
    #[doc = ""]
    #[doc = " Send a capture lost event to the browser."]
    #[doc = ""]
    pub send_capture_lost_event:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Notify the browser that the window hosting it is about to be moved or"]
    #[doc = " resized. This function is only used on Windows and Linux."]
    #[doc = ""]
    pub notify_move_or_resize_started:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Returns the maximum rate in frames per second (fps) that"]
    #[doc = " cef_render_handler_t::OnPaint will be called for a windowless browser. The"]
    #[doc = " actual fps may be lower if the browser cannot generate frames at the"]
    #[doc = " requested rate. The minimum value is 1 and the maximum value is 60"]
    #[doc = " (default 30). This function can only be called on the UI thread."]
    #[doc = ""]
    pub get_windowless_frame_rate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the maximum rate in frames per second (fps) that"]
    #[doc = " cef_render_handler_t:: OnPaint will be called for a windowless browser."]
    #[doc = " The actual fps may be lower if the browser cannot generate frames at the"]
    #[doc = " requested rate. The minimum value is 1 and the maximum value is 60"]
    #[doc = " (default 30). Can also be set at browser creation via"]
    #[doc = " cef_browser_tSettings.windowless_frame_rate."]
    #[doc = ""]
    pub set_windowless_frame_rate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, frame_rate: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Begins a new composition or updates the existing composition. Blink has a"]
    #[doc = " special node (a composition node) that allows the input function to change"]
    #[doc = " text without affecting other DOM nodes. |text| is the optional text that"]
    #[doc = " will be inserted into the composition node. |underlines| is an optional"]
    #[doc = " set of ranges that will be underlined in the resulting text."]
    #[doc = " |replacement_range| is an optional range of the existing text that will be"]
    #[doc = " replaced. |selection_range| is an optional range of the resulting text"]
    #[doc = " that will be selected after insertion or replacement. The"]
    #[doc = " |replacement_range| value is only used on OS X."]
    #[doc = ""]
    #[doc = " This function may be called multiple times as the composition changes."]
    #[doc = " When the client is done making changes the composition should either be"]
    #[doc = " canceled or completed. To cancel the composition call"]
    #[doc = " ImeCancelComposition. To complete the composition call either"]
    #[doc = " ImeCommitText or ImeFinishComposingText. Completion is usually signaled"]
    #[doc = " when:"]
    #[doc = ""]
    #[doc = " 1. The client receives a WM_IME_COMPOSITION message with a GCS_RESULTSTR"]
    #[doc = "    flag (on Windows), or;"]
    #[doc = " 2. The client receives a \"commit\" signal of GtkIMContext (on Linux), or;"]
    #[doc = " 3. insertText of NSTextInput is called (on Mac)."]
    #[doc = ""]
    #[doc = " This function is only used when window rendering is disabled."]
    #[doc = ""]
    pub ime_set_composition: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            text: *const cef_string_t,
            underlinesCount: size_t,
            underlines: *const cef_composition_underline_t,
            replacement_range: *const cef_range_t,
            selection_range: *const cef_range_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Completes the existing composition by optionally inserting the specified"]
    #[doc = " |text| into the composition node. |replacement_range| is an optional range"]
    #[doc = " of the existing text that will be replaced. |relative_cursor_pos| is where"]
    #[doc = " the cursor will be positioned relative to the current cursor position. See"]
    #[doc = " comments on ImeSetComposition for usage. The |replacement_range| and"]
    #[doc = " |relative_cursor_pos| values are only used on OS X. This function is only"]
    #[doc = " used when window rendering is disabled."]
    #[doc = ""]
    pub ime_commit_text: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            text: *const cef_string_t,
            replacement_range: *const cef_range_t,
            relative_cursor_pos: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Completes the existing composition by applying the current composition"]
    #[doc = " node contents. If |keep_selection| is false (0) the current selection, if"]
    #[doc = " any, will be discarded. See comments on ImeSetComposition for usage. This"]
    #[doc = " function is only used when window rendering is disabled."]
    #[doc = ""]
    pub ime_finish_composing_text: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            keep_selection: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancels the existing composition and discards the composition node"]
    #[doc = " contents without applying them. See comments on ImeSetComposition for"]
    #[doc = " usage. This function is only used when window rendering is disabled."]
    #[doc = ""]
    pub ime_cancel_composition:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Call this function when the user drags the mouse into the web view (before"]
    #[doc = " calling DragTargetDragOver/DragTargetLeave/DragTargetDrop). |drag_data|"]
    #[doc = " should not contain file contents as this type of data is not allowed to be"]
    #[doc = " dragged into the web view. File contents can be removed using"]
    #[doc = " cef_drag_data_t::ResetFileContents (for example, if |drag_data| comes from"]
    #[doc = " cef_render_handler_t::StartDragging). This function is only used when"]
    #[doc = " window rendering is disabled."]
    #[doc = ""]
    pub drag_target_drag_enter: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            drag_data: *mut _cef_drag_data_t,
            event: *const cef_mouse_event_t,
            allowed_ops: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Call this function each time the mouse is moved across the web view during"]
    #[doc = " a drag operation (after calling DragTargetDragEnter and before calling"]
    #[doc = " DragTargetDragLeave/DragTargetDrop). This function is only used when"]
    #[doc = " window rendering is disabled."]
    #[doc = ""]
    pub drag_target_drag_over: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            event: *const cef_mouse_event_t,
            allowed_ops: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Call this function when the user drags the mouse out of the web view"]
    #[doc = " (after calling DragTargetDragEnter). This function is only used when"]
    #[doc = " window rendering is disabled."]
    #[doc = ""]
    pub drag_target_drag_leave:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Call this function when the user completes the drag operation by dropping"]
    #[doc = " the object onto the web view (after calling DragTargetDragEnter). The"]
    #[doc = " object being dropped is |drag_data|, given as an argument to the previous"]
    #[doc = " DragTargetDragEnter call. This function is only used when window rendering"]
    #[doc = " is disabled."]
    #[doc = ""]
    pub drag_target_drop: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, event: *const cef_mouse_event_t),
    >,
    #[doc = ""]
    #[doc = " Call this function when the drag operation started by a"]
    #[doc = " cef_render_handler_t::StartDragging call has ended either in a drop or by"]
    #[doc = " being cancelled. |x| and |y| are mouse coordinates relative to the upper-"]
    #[doc = " left corner of the view. If the web view is both the drag source and the"]
    #[doc = " drag target then all DragTarget* functions should be called before"]
    #[doc = " DragSource* mthods. This function is only used when window rendering is"]
    #[doc = " disabled."]
    #[doc = ""]
    pub drag_source_ended_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
            op: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Call this function when the drag operation started by a"]
    #[doc = " cef_render_handler_t::StartDragging call has completed. This function may"]
    #[doc = " be called immediately without first calling DragSourceEndedAt to cancel a"]
    #[doc = " drag operation. If the web view is both the drag source and the drag"]
    #[doc = " target then all DragTarget* functions should be called before DragSource*"]
    #[doc = " mthods. This function is only used when window rendering is disabled."]
    #[doc = ""]
    pub drag_source_system_drag_ended:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_host_t)>,
    #[doc = ""]
    #[doc = " Returns the current visible navigation entry for this browser. This"]
    #[doc = " function can only be called on the UI thread."]
    #[doc = ""]
    pub get_visible_navigation_entry: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_navigation_entry_t,
    >,
    #[doc = ""]
    #[doc = " Set accessibility state for all frames. |accessibility_state| may be"]
    #[doc = " default, enabled or disabled. If |accessibility_state| is STATE_DEFAULT"]
    #[doc = " then accessibility will be disabled by default and the state may be"]
    #[doc = " further controlled with the \"force-renderer-accessibility\" and \"disable-"]
    #[doc = " renderer-accessibility\" command-line switches. If |accessibility_state| is"]
    #[doc = " STATE_ENABLED then accessibility will be enabled. If |accessibility_state|"]
    #[doc = " is STATE_DISABLED then accessibility will be completely disabled."]
    #[doc = ""]
    #[doc = " For windowed browsers accessibility will be enabled in Complete mode"]
    #[doc = " (which corresponds to kAccessibilityModeComplete in Chromium). In this"]
    #[doc = " mode all platform accessibility objects will be created and managed by"]
    #[doc = " Chromium's internal implementation. The client needs only to detect the"]
    #[doc = " screen reader and call this function appropriately. For example, on macOS"]
    #[doc = " the client can handle the @\"AXEnhancedUserStructure\" accessibility"]
    #[doc = " attribute to detect VoiceOver state changes and on Windows the client can"]
    #[doc = " handle WM_GETOBJECT with OBJID_CLIENT to detect accessibility readers."]
    #[doc = ""]
    #[doc = " For windowless browsers accessibility will be enabled in TreeOnly mode"]
    #[doc = " (which corresponds to kAccessibilityModeWebContentsOnly in Chromium). In"]
    #[doc = " this mode renderer accessibility is enabled, the full tree is computed,"]
    #[doc = " and events are passed to CefAccessibiltyHandler, but platform"]
    #[doc = " accessibility objects are not created. The client may implement platform"]
    #[doc = " accessibility objects using CefAccessibiltyHandler callbacks if desired."]
    #[doc = ""]
    pub set_accessibility_state: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, accessibility_state: cef_state_t),
    >,
    #[doc = ""]
    #[doc = " Enable notifications of auto resize via"]
    #[doc = " cef_display_handler_t::OnAutoResize. Notifications are disabled by"]
    #[doc = " default. |min_size| and |max_size| define the range of allowed sizes."]
    #[doc = ""]
    pub set_auto_resize_enabled: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_host_t,
            enabled: ::std::os::raw::c_int,
            min_size: *const cef_size_t,
            max_size: *const cef_size_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns the extension hosted in this browser or NULL if no extension is"]
    #[doc = " hosted. See cef_request_context_t::LoadExtension for details."]
    #[doc = ""]
    pub get_extension: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> *mut _cef_extension_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this browser is hosting an extension background"]
    #[doc = " script. Background hosts do not have a window and are not displayable. See"]
    #[doc = " cef_request_context_t::LoadExtension for details."]
    #[doc = ""]
    pub is_background_host: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set whether the browser's audio is muted."]
    #[doc = ""]
    pub set_audio_muted: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t, mute: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the browser's audio is muted.  This function can only"]
    #[doc = " be called on the UI thread."]
    #[doc = ""]
    pub is_audio_muted: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_host_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_browser_host_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_browser_host_t>(),
        512usize,
        concat!("Size of: ", stringify!(_cef_browser_host_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_browser_host_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_browser_host_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_browser() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_browser) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(get_browser)
            )
        );
    }
    test_field_get_browser();
    fn test_field_close_browser() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).close_browser) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(close_browser)
            )
        );
    }
    test_field_close_browser();
    fn test_field_try_close_browser() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).try_close_browser) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(try_close_browser)
            )
        );
    }
    test_field_try_close_browser();
    fn test_field_set_focus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_focus) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(set_focus)
            )
        );
    }
    test_field_set_focus();
    fn test_field_get_window_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_window_handle) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(get_window_handle)
            )
        );
    }
    test_field_get_window_handle();
    fn test_field_get_opener_window_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_opener_window_handle) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(get_opener_window_handle)
            )
        );
    }
    test_field_get_opener_window_handle();
    fn test_field_has_view() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_view) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(has_view)
            )
        );
    }
    test_field_has_view();
    fn test_field_get_client() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_client) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(get_client)
            )
        );
    }
    test_field_get_client();
    fn test_field_get_request_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_request_context) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(get_request_context)
            )
        );
    }
    test_field_get_request_context();
    fn test_field_get_zoom_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_zoom_level) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(get_zoom_level)
            )
        );
    }
    test_field_get_zoom_level();
    fn test_field_set_zoom_level() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_zoom_level) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(set_zoom_level)
            )
        );
    }
    test_field_set_zoom_level();
    fn test_field_run_file_dialog() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).run_file_dialog) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(run_file_dialog)
            )
        );
    }
    test_field_run_file_dialog();
    fn test_field_start_download() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start_download) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(start_download)
            )
        );
    }
    test_field_start_download();
    fn test_field_download_image() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).download_image) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(download_image)
            )
        );
    }
    test_field_download_image();
    fn test_field_print() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).print) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(print)
            )
        );
    }
    test_field_print();
    fn test_field_print_to_pdf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).print_to_pdf) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(print_to_pdf)
            )
        );
    }
    test_field_print_to_pdf();
    fn test_field_find() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).find) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(find)
            )
        );
    }
    test_field_find();
    fn test_field_stop_finding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).stop_finding) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(stop_finding)
            )
        );
    }
    test_field_stop_finding();
    fn test_field_show_dev_tools() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).show_dev_tools) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(show_dev_tools)
            )
        );
    }
    test_field_show_dev_tools();
    fn test_field_close_dev_tools() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).close_dev_tools) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(close_dev_tools)
            )
        );
    }
    test_field_close_dev_tools();
    fn test_field_has_dev_tools() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_dev_tools) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(has_dev_tools)
            )
        );
    }
    test_field_has_dev_tools();
    fn test_field_send_dev_tools_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send_dev_tools_message) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(send_dev_tools_message)
            )
        );
    }
    test_field_send_dev_tools_message();
    fn test_field_execute_dev_tools_method() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).execute_dev_tools_method) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(execute_dev_tools_method)
            )
        );
    }
    test_field_execute_dev_tools_method();
    fn test_field_add_dev_tools_message_observer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_dev_tools_message_observer) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(add_dev_tools_message_observer)
            )
        );
    }
    test_field_add_dev_tools_message_observer();
    fn test_field_get_navigation_entries() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_navigation_entries) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(get_navigation_entries)
            )
        );
    }
    test_field_get_navigation_entries();
    fn test_field_replace_misspelling() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).replace_misspelling) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(replace_misspelling)
            )
        );
    }
    test_field_replace_misspelling();
    fn test_field_add_word_to_dictionary() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_word_to_dictionary) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(add_word_to_dictionary)
            )
        );
    }
    test_field_add_word_to_dictionary();
    fn test_field_is_window_rendering_disabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_window_rendering_disabled) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(is_window_rendering_disabled)
            )
        );
    }
    test_field_is_window_rendering_disabled();
    fn test_field_was_resized() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).was_resized) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(was_resized)
            )
        );
    }
    test_field_was_resized();
    fn test_field_was_hidden() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).was_hidden) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(was_hidden)
            )
        );
    }
    test_field_was_hidden();
    fn test_field_notify_screen_info_changed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notify_screen_info_changed) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(notify_screen_info_changed)
            )
        );
    }
    test_field_notify_screen_info_changed();
    fn test_field_invalidate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).invalidate) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(invalidate)
            )
        );
    }
    test_field_invalidate();
    fn test_field_send_external_begin_frame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send_external_begin_frame) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(send_external_begin_frame)
            )
        );
    }
    test_field_send_external_begin_frame();
    fn test_field_send_key_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send_key_event) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(send_key_event)
            )
        );
    }
    test_field_send_key_event();
    fn test_field_send_mouse_click_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send_mouse_click_event) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(send_mouse_click_event)
            )
        );
    }
    test_field_send_mouse_click_event();
    fn test_field_send_mouse_move_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send_mouse_move_event) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(send_mouse_move_event)
            )
        );
    }
    test_field_send_mouse_move_event();
    fn test_field_send_mouse_wheel_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send_mouse_wheel_event) as usize - ptr as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(send_mouse_wheel_event)
            )
        );
    }
    test_field_send_mouse_wheel_event();
    fn test_field_send_touch_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send_touch_event) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(send_touch_event)
            )
        );
    }
    test_field_send_touch_event();
    fn test_field_send_capture_lost_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).send_capture_lost_event) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(send_capture_lost_event)
            )
        );
    }
    test_field_send_capture_lost_event();
    fn test_field_notify_move_or_resize_started() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).notify_move_or_resize_started) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(notify_move_or_resize_started)
            )
        );
    }
    test_field_notify_move_or_resize_started();
    fn test_field_get_windowless_frame_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_windowless_frame_rate) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(get_windowless_frame_rate)
            )
        );
    }
    test_field_get_windowless_frame_rate();
    fn test_field_set_windowless_frame_rate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_windowless_frame_rate) as usize - ptr as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(set_windowless_frame_rate)
            )
        );
    }
    test_field_set_windowless_frame_rate();
    fn test_field_ime_set_composition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ime_set_composition) as usize - ptr as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(ime_set_composition)
            )
        );
    }
    test_field_ime_set_composition();
    fn test_field_ime_commit_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ime_commit_text) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(ime_commit_text)
            )
        );
    }
    test_field_ime_commit_text();
    fn test_field_ime_finish_composing_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ime_finish_composing_text) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(ime_finish_composing_text)
            )
        );
    }
    test_field_ime_finish_composing_text();
    fn test_field_ime_cancel_composition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ime_cancel_composition) as usize - ptr as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(ime_cancel_composition)
            )
        );
    }
    test_field_ime_cancel_composition();
    fn test_field_drag_target_drag_enter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drag_target_drag_enter) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(drag_target_drag_enter)
            )
        );
    }
    test_field_drag_target_drag_enter();
    fn test_field_drag_target_drag_over() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drag_target_drag_over) as usize - ptr as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(drag_target_drag_over)
            )
        );
    }
    test_field_drag_target_drag_over();
    fn test_field_drag_target_drag_leave() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drag_target_drag_leave) as usize - ptr as usize
            },
            424usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(drag_target_drag_leave)
            )
        );
    }
    test_field_drag_target_drag_leave();
    fn test_field_drag_target_drop() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drag_target_drop) as usize - ptr as usize
            },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(drag_target_drop)
            )
        );
    }
    test_field_drag_target_drop();
    fn test_field_drag_source_ended_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drag_source_ended_at) as usize - ptr as usize
            },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(drag_source_ended_at)
            )
        );
    }
    test_field_drag_source_ended_at();
    fn test_field_drag_source_system_drag_ended() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).drag_source_system_drag_ended) as usize - ptr as usize
            },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(drag_source_system_drag_ended)
            )
        );
    }
    test_field_drag_source_system_drag_ended();
    fn test_field_get_visible_navigation_entry() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_visible_navigation_entry) as usize - ptr as usize
            },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(get_visible_navigation_entry)
            )
        );
    }
    test_field_get_visible_navigation_entry();
    fn test_field_set_accessibility_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_accessibility_state) as usize - ptr as usize
            },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(set_accessibility_state)
            )
        );
    }
    test_field_set_accessibility_state();
    fn test_field_set_auto_resize_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_auto_resize_enabled) as usize - ptr as usize
            },
            472usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(set_auto_resize_enabled)
            )
        );
    }
    test_field_set_auto_resize_enabled();
    fn test_field_get_extension() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_extension) as usize - ptr as usize
            },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(get_extension)
            )
        );
    }
    test_field_get_extension();
    fn test_field_is_background_host() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_background_host) as usize - ptr as usize
            },
            488usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(is_background_host)
            )
        );
    }
    test_field_is_background_host();
    fn test_field_set_audio_muted() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_audio_muted) as usize - ptr as usize
            },
            496usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(set_audio_muted)
            )
        );
    }
    test_field_set_audio_muted();
    fn test_field_is_audio_muted() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_host_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_audio_muted) as usize - ptr as usize
            },
            504usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_host_t),
                "::",
                stringify!(is_audio_muted)
            )
        );
    }
    test_field_is_audio_muted();
}
#[doc = ""]
#[doc = " Structure used to represent the browser process aspects of a browser. The"]
#[doc = " functions of this structure can only be called in the browser process. They"]
#[doc = " may be called on any thread in that process unless otherwise indicated in"]
#[doc = " the comments."]
#[doc = ""]
pub type cef_browser_host_t = _cef_browser_host_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new browser using the window parameters specified by |windowInfo|."]
    #[doc = " All values will be copied internally and the actual window (if any) will be"]
    #[doc = " created on the UI thread. If |request_context| is NULL the global request"]
    #[doc = " context will be used. This function can be called on any browser process"]
    #[doc = " thread and will not block. The optional |extra_info| parameter provides an"]
    #[doc = " opportunity to specify extra information specific to the created browser"]
    #[doc = " that will be passed to cef_render_process_handler_t::on_browser_created() in"]
    #[doc = " the render process."]
    #[doc = ""]
    pub fn cef_browser_host_create_browser(
        windowInfo: *const cef_window_info_t,
        client: *mut _cef_client_t,
        url: *const cef_string_t,
        settings: *const _cef_browser_settings_t,
        extra_info: *mut _cef_dictionary_value_t,
        request_context: *mut _cef_request_context_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new browser using the window parameters specified by |windowInfo|."]
    #[doc = " If |request_context| is NULL the global request context will be used. This"]
    #[doc = " function can only be called on the browser process UI thread. The optional"]
    #[doc = " |extra_info| parameter provides an opportunity to specify extra information"]
    #[doc = " specific to the created browser that will be passed to"]
    #[doc = " cef_render_process_handler_t::on_browser_created() in the render process."]
    #[doc = ""]
    pub fn cef_browser_host_create_browser_sync(
        windowInfo: *const cef_window_info_t,
        client: *mut _cef_client_t,
        url: *const cef_string_t,
        settings: *const _cef_browser_settings_t,
        extra_info: *mut _cef_dictionary_value_t,
        request_context: *mut _cef_request_context_t,
    ) -> *mut cef_browser_t;
}
#[doc = ""]
#[doc = " Implement this structure to handle audio events."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_audio_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called on the UI thread to allow configuration of audio stream parameters."]
    #[doc = " Return true (1) to proceed with audio stream capture, or false (0) to"]
    #[doc = " cancel it. All members of |params| can optionally be configured here, but"]
    #[doc = " they are also pre-filled with some sensible defaults."]
    #[doc = ""]
    pub get_audio_parameters: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_audio_handler_t,
            browser: *mut _cef_browser_t,
            params: *mut cef_audio_parameters_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on a browser audio capture thread when the browser starts streaming"]
    #[doc = " audio. OnAudioStreamStopped will always be called after"]
    #[doc = " OnAudioStreamStarted; both functions may be called multiple times for the"]
    #[doc = " same browser. |params| contains the audio parameters like sample rate and"]
    #[doc = " channel layout. |channels| is the number of channels."]
    #[doc = ""]
    pub on_audio_stream_started: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_audio_handler_t,
            browser: *mut _cef_browser_t,
            params: *const cef_audio_parameters_t,
            channels: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on the audio stream thread when a PCM packet is received for the"]
    #[doc = " stream. |data| is an array representing the raw PCM data as a floating"]
    #[doc = " point type, i.e. 4-byte value(s). |frames| is the number of frames in the"]
    #[doc = " PCM packet. |pts| is the presentation timestamp (in milliseconds since the"]
    #[doc = " Unix Epoch) and represents the time at which the decompressed packet"]
    #[doc = " should be presented to the user. Based on |frames| and the"]
    #[doc = " |channel_layout| value passed to OnAudioStreamStarted you can calculate"]
    #[doc = " the size of the |data| array in bytes."]
    #[doc = ""]
    pub on_audio_stream_packet: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_audio_handler_t,
            browser: *mut _cef_browser_t,
            data: *mut *const f32,
            frames: ::std::os::raw::c_int,
            pts: int64,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on the UI thread when the stream has stopped. OnAudioSteamStopped"]
    #[doc = " will always be called after OnAudioStreamStarted; both functions may be"]
    #[doc = " called multiple times for the same stream."]
    #[doc = ""]
    pub on_audio_stream_stopped: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_audio_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = ""]
    #[doc = " Called on the UI or audio stream thread when an error occurred. During the"]
    #[doc = " stream creation phase this callback will be called on the UI thread while"]
    #[doc = " in the capturing phase it will be called on the audio stream thread. The"]
    #[doc = " stream will be stopped immediately."]
    #[doc = ""]
    pub on_audio_stream_error: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_audio_handler_t,
            browser: *mut _cef_browser_t,
            message: *const cef_string_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_audio_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_audio_handler_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_audio_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_audio_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_audio_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_audio_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_audio_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_audio_parameters() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_audio_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_audio_parameters) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_audio_handler_t),
                "::",
                stringify!(get_audio_parameters)
            )
        );
    }
    test_field_get_audio_parameters();
    fn test_field_on_audio_stream_started() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_audio_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_audio_stream_started) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_audio_handler_t),
                "::",
                stringify!(on_audio_stream_started)
            )
        );
    }
    test_field_on_audio_stream_started();
    fn test_field_on_audio_stream_packet() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_audio_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_audio_stream_packet) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_audio_handler_t),
                "::",
                stringify!(on_audio_stream_packet)
            )
        );
    }
    test_field_on_audio_stream_packet();
    fn test_field_on_audio_stream_stopped() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_audio_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_audio_stream_stopped) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_audio_handler_t),
                "::",
                stringify!(on_audio_stream_stopped)
            )
        );
    }
    test_field_on_audio_stream_stopped();
    fn test_field_on_audio_stream_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_audio_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_audio_stream_error) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_audio_handler_t),
                "::",
                stringify!(on_audio_stream_error)
            )
        );
    }
    test_field_on_audio_stream_error();
}
#[doc = ""]
#[doc = " Implement this structure to handle audio events."]
#[doc = ""]
pub type cef_audio_handler_t = _cef_audio_handler_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to commands. The functions"]
#[doc = " of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_command_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called to execute a Chrome command triggered via menu selection or"]
    #[doc = " keyboard shortcut. Values for |command_id| can be found in the"]
    #[doc = " cef_command_ids.h file. |disposition| provides information about the"]
    #[doc = " intended command target. Return true (1) if the command was handled or"]
    #[doc = " false (0) for the default implementation. For context menu commands this"]
    #[doc = " will be called after cef_context_menu_handler_t::OnContextMenuCommand."]
    #[doc = " Only used with the Chrome runtime."]
    #[doc = ""]
    pub on_chrome_command: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_handler_t,
            browser: *mut _cef_browser_t,
            command_id: ::std::os::raw::c_int,
            disposition: cef_window_open_disposition_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_command_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_command_handler_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_command_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_command_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_command_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_chrome_command() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_chrome_command) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_handler_t),
                "::",
                stringify!(on_chrome_command)
            )
        );
    }
    test_field_on_chrome_command();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to commands. The functions"]
#[doc = " of this structure will be called on the UI thread."]
#[doc = ""]
pub type cef_command_handler_t = _cef_command_handler_t;
#[doc = ""]
#[doc = " Implement this structure to handle menu model events. The functions of this"]
#[doc = " structure will be called on the browser process UI thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_menu_model_delegate_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Perform the action associated with the specified |command_id| and optional"]
    #[doc = " |event_flags|."]
    #[doc = ""]
    pub execute_command: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            event_flags: cef_event_flags_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the user moves the mouse outside the menu and over the owning"]
    #[doc = " window."]
    #[doc = ""]
    pub mouse_outside_menu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            screen_point: *const cef_point_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on unhandled open submenu keyboard commands. |is_rtl| will be true"]
    #[doc = " (1) if the menu is displaying a right-to-left language."]
    #[doc = ""]
    pub unhandled_open_submenu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            is_rtl: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on unhandled close submenu keyboard commands. |is_rtl| will be true"]
    #[doc = " (1) if the menu is displaying a right-to-left language."]
    #[doc = ""]
    pub unhandled_close_submenu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            is_rtl: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " The menu is about to show."]
    #[doc = ""]
    pub menu_will_show: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
        ),
    >,
    #[doc = ""]
    #[doc = " The menu has closed."]
    #[doc = ""]
    pub menu_closed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Optionally modify a menu item label. Return true (1) if |label| was"]
    #[doc = " modified."]
    #[doc = ""]
    pub format_label: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_delegate_t,
            menu_model: *mut _cef_menu_model_t,
            label: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_menu_model_delegate_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_menu_model_delegate_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_menu_model_delegate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_menu_model_delegate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_menu_model_delegate_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_delegate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_delegate_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_execute_command() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_delegate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).execute_command) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_delegate_t),
                "::",
                stringify!(execute_command)
            )
        );
    }
    test_field_execute_command();
    fn test_field_mouse_outside_menu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_delegate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).mouse_outside_menu) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_delegate_t),
                "::",
                stringify!(mouse_outside_menu)
            )
        );
    }
    test_field_mouse_outside_menu();
    fn test_field_unhandled_open_submenu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_delegate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unhandled_open_submenu) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_delegate_t),
                "::",
                stringify!(unhandled_open_submenu)
            )
        );
    }
    test_field_unhandled_open_submenu();
    fn test_field_unhandled_close_submenu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_delegate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unhandled_close_submenu) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_delegate_t),
                "::",
                stringify!(unhandled_close_submenu)
            )
        );
    }
    test_field_unhandled_close_submenu();
    fn test_field_menu_will_show() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_delegate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).menu_will_show) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_delegate_t),
                "::",
                stringify!(menu_will_show)
            )
        );
    }
    test_field_menu_will_show();
    fn test_field_menu_closed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_delegate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).menu_closed) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_delegate_t),
                "::",
                stringify!(menu_closed)
            )
        );
    }
    test_field_menu_closed();
    fn test_field_format_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_delegate_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).format_label) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_delegate_t),
                "::",
                stringify!(format_label)
            )
        );
    }
    test_field_format_label();
}
#[doc = ""]
#[doc = " Implement this structure to handle menu model events. The functions of this"]
#[doc = " structure will be called on the browser process UI thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
pub type cef_menu_model_delegate_t = _cef_menu_model_delegate_t;
#[doc = ""]
#[doc = " Supports creation and modification of menus. See cef_menu_id_t for the"]
#[doc = " command ids that have default implementations. All user-defined command ids"]
#[doc = " should be between MENU_ID_USER_FIRST and MENU_ID_USER_LAST. The functions of"]
#[doc = " this structure can only be accessed on the browser process the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_menu_model_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this menu is a submenu."]
    #[doc = ""]
    pub is_sub_menu: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Clears the menu. Returns true (1) on success."]
    #[doc = ""]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the number of items in this menu."]
    #[doc = ""]
    pub get_count:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> size_t>,
    #[doc = ""]
    #[doc = " Add a separator to the menu. Returns true (1) on success."]
    #[doc = ""]
    pub add_separator: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add an item to the menu. Returns true (1) on success."]
    #[doc = ""]
    pub add_item: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add a check item to the menu. Returns true (1) on success."]
    #[doc = ""]
    pub add_check_item: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add a radio item to the menu. Only a single item with the specified"]
    #[doc = " |group_id| can be checked at a time. Returns true (1) on success."]
    #[doc = ""]
    pub add_radio_item: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
            group_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Add a sub-menu to the menu. The new sub-menu is returned."]
    #[doc = ""]
    pub add_sub_menu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = ""]
    #[doc = " Insert a separator in the menu at the specified |index|. Returns true (1)"]
    #[doc = " on success."]
    #[doc = ""]
    pub insert_separator_at: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Insert an item in the menu at the specified |index|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub insert_item_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Insert a check item in the menu at the specified |index|. Returns true (1)"]
    #[doc = " on success."]
    #[doc = ""]
    pub insert_check_item_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Insert a radio item in the menu at the specified |index|. Only a single"]
    #[doc = " item with the specified |group_id| can be checked at a time. Returns true"]
    #[doc = " (1) on success."]
    #[doc = ""]
    pub insert_radio_item_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
            group_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Insert a sub-menu in the menu at the specified |index|. The new sub-menu"]
    #[doc = " is returned."]
    #[doc = ""]
    pub insert_sub_menu_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = ""]
    #[doc = " Removes the item with the specified |command_id|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub remove: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Removes the item at the specified |index|. Returns true (1) on success."]
    #[doc = ""]
    pub remove_at: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the index associated with the specified |command_id| or -1 if not"]
    #[doc = " found due to the command id not existing in the menu."]
    #[doc = ""]
    pub get_index_of: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the command id at the specified |index| or -1 if not found due to"]
    #[doc = " invalid range or the index being a separator."]
    #[doc = ""]
    pub get_command_id_at: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the command id at the specified |index|. Returns true (1) on success."]
    #[doc = ""]
    pub set_command_id_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the label for the specified |command_id| or NULL if not found."]
    #[doc = ""]
    pub get_label: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the label at the specified |index| or NULL if not found due to"]
    #[doc = " invalid range or the index being a separator."]
    #[doc = ""]
    pub get_label_at: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t, index: size_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Sets the label for the specified |command_id|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub set_label: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the label at the specified |index|. Returns true (1) on success."]
    #[doc = ""]
    pub set_label_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            label: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the item type for the specified |command_id|."]
    #[doc = ""]
    pub get_type: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> cef_menu_item_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the item type at the specified |index|."]
    #[doc = ""]
    pub get_type_at: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t, index: size_t) -> cef_menu_item_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns the group id for the specified |command_id| or -1 if invalid."]
    #[doc = ""]
    pub get_group_id: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the group id at the specified |index| or -1 if invalid."]
    #[doc = ""]
    pub get_group_id_at: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the group id for the specified |command_id|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub set_group_id: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            group_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the group id at the specified |index|. Returns true (1) on success."]
    #[doc = ""]
    pub set_group_id_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            group_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the submenu for the specified |command_id| or NULL if invalid."]
    #[doc = ""]
    pub get_sub_menu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = ""]
    #[doc = " Returns the submenu at the specified |index| or NULL if invalid."]
    #[doc = ""]
    pub get_sub_menu_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
        ) -> *mut _cef_menu_model_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |command_id| is visible."]
    #[doc = ""]
    pub is_visible: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |index| is visible."]
    #[doc = ""]
    pub is_visible_at: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Change the visibility of the specified |command_id|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub set_visible: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            visible: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Change the visibility at the specified |index|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub set_visible_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            visible: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |command_id| is enabled."]
    #[doc = ""]
    pub is_enabled: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |index| is enabled."]
    #[doc = ""]
    pub is_enabled_at: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Change the enabled status of the specified |command_id|. Returns true (1)"]
    #[doc = " on success."]
    #[doc = ""]
    pub set_enabled: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            enabled: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Change the enabled status at the specified |index|. Returns true (1) on"]
    #[doc = " success."]
    #[doc = ""]
    pub set_enabled_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            enabled: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |command_id| is checked. Only applies to"]
    #[doc = " check and radio items."]
    #[doc = ""]
    pub is_checked: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |index| is checked. Only applies to"]
    #[doc = " check and radio items."]
    #[doc = ""]
    pub is_checked_at: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Check the specified |command_id|. Only applies to check and radio items."]
    #[doc = " Returns true (1) on success."]
    #[doc = ""]
    pub set_checked: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            checked: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Check the specified |index|. Only applies to check and radio items."]
    #[doc = " Returns true (1) on success."]
    #[doc = ""]
    pub set_checked_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            checked: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |command_id| has a keyboard accelerator"]
    #[doc = " assigned."]
    #[doc = ""]
    pub has_accelerator: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the specified |index| has a keyboard accelerator"]
    #[doc = " assigned."]
    #[doc = ""]
    pub has_accelerator_at: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the keyboard accelerator for the specified |command_id|. |key_code|"]
    #[doc = " can be any virtual key or character value. Returns true (1) on success."]
    #[doc = ""]
    pub set_accelerator: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            key_code: ::std::os::raw::c_int,
            shift_pressed: ::std::os::raw::c_int,
            ctrl_pressed: ::std::os::raw::c_int,
            alt_pressed: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the keyboard accelerator at the specified |index|. |key_code| can be"]
    #[doc = " any virtual key or character value. Returns true (1) on success."]
    #[doc = ""]
    pub set_accelerator_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            key_code: ::std::os::raw::c_int,
            shift_pressed: ::std::os::raw::c_int,
            ctrl_pressed: ::std::os::raw::c_int,
            alt_pressed: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Remove the keyboard accelerator for the specified |command_id|. Returns"]
    #[doc = " true (1) on success."]
    #[doc = ""]
    pub remove_accelerator: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Remove the keyboard accelerator at the specified |index|. Returns true (1)"]
    #[doc = " on success."]
    #[doc = ""]
    pub remove_accelerator_at: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_menu_model_t, index: size_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Retrieves the keyboard accelerator for the specified |command_id|. Returns"]
    #[doc = " true (1) on success."]
    #[doc = ""]
    pub get_accelerator: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            key_code: *mut ::std::os::raw::c_int,
            shift_pressed: *mut ::std::os::raw::c_int,
            ctrl_pressed: *mut ::std::os::raw::c_int,
            alt_pressed: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Retrieves the keyboard accelerator for the specified |index|. Returns true"]
    #[doc = " (1) on success."]
    #[doc = ""]
    pub get_accelerator_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: size_t,
            key_code: *mut ::std::os::raw::c_int,
            shift_pressed: *mut ::std::os::raw::c_int,
            ctrl_pressed: *mut ::std::os::raw::c_int,
            alt_pressed: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the explicit color for |command_id| and |color_type| to |color|."]
    #[doc = " Specify a |color| value of 0 to remove the explicit color. If no explicit"]
    #[doc = " color or default color is set for |color_type| then the system color will"]
    #[doc = " be used. Returns true (1) on success."]
    #[doc = ""]
    pub set_color: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            color_type: cef_menu_color_type_t,
            color: cef_color_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the explicit color for |command_id| and |index| to |color|. Specify a"]
    #[doc = " |color| value of 0 to remove the explicit color. Specify an |index| value"]
    #[doc = " of -1 to set the default color for items that do not have an explicit"]
    #[doc = " color set. If no explicit color or default color is set for |color_type|"]
    #[doc = " then the system color will be used. Returns true (1) on success."]
    #[doc = ""]
    pub set_color_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            color_type: cef_menu_color_type_t,
            color: cef_color_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns in |color| the color that was explicitly set for |command_id| and"]
    #[doc = " |color_type|. If a color was not set then 0 will be returned in |color|."]
    #[doc = " Returns true (1) on success."]
    #[doc = ""]
    pub get_color: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            color_type: cef_menu_color_type_t,
            color: *mut cef_color_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns in |color| the color that was explicitly set for |command_id| and"]
    #[doc = " |color_type|. Specify an |index| value of -1 to return the default color"]
    #[doc = " in |color|. If a color was not set then 0 will be returned in |color|."]
    #[doc = " Returns true (1) on success."]
    #[doc = ""]
    pub get_color_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            color_type: cef_menu_color_type_t,
            color: *mut cef_color_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the font list for the specified |command_id|. If |font_list| is NULL"]
    #[doc = " the system font will be used. Returns true (1) on success. The format is"]
    #[doc = " \"<FONT_FAMILY_LIST>,[STYLES] <SIZE>\", where: - FONT_FAMILY_LIST is a"]
    #[doc = " comma-separated list of font family names, - STYLES is an optional space-"]
    #[doc = " separated list of style names"]
    #[doc = "   (case-sensitive \"Bold\" and \"Italic\" are supported), and"]
    #[doc = " - SIZE is an integer font size in pixels with the suffix \"px\"."]
    #[doc = ""]
    #[doc = " Here are examples of valid font description strings: - \"Arial, Helvetica,"]
    #[doc = " Bold Italic 14px\" - \"Arial, 14px\""]
    #[doc = ""]
    pub set_font_list: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            command_id: ::std::os::raw::c_int,
            font_list: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the font list for the specified |index|. Specify an |index| value of"]
    #[doc = " -1 to set the default font. If |font_list| is NULL the system font will be"]
    #[doc = " used. Returns true (1) on success. The format is"]
    #[doc = " \"<FONT_FAMILY_LIST>,[STYLES] <SIZE>\", where: - FONT_FAMILY_LIST is a"]
    #[doc = " comma-separated list of font family names, - STYLES is an optional space-"]
    #[doc = " separated list of style names"]
    #[doc = "   (case-sensitive \"Bold\" and \"Italic\" are supported), and"]
    #[doc = " - SIZE is an integer font size in pixels with the suffix \"px\"."]
    #[doc = ""]
    #[doc = " Here are examples of valid font description strings: - \"Arial, Helvetica,"]
    #[doc = " Bold Italic 14px\" - \"Arial, 14px\""]
    #[doc = ""]
    pub set_font_list_at: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_menu_model_t,
            index: ::std::os::raw::c_int,
            font_list: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_menu_model_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_menu_model_t>(),
        488usize,
        concat!("Size of: ", stringify!(_cef_menu_model_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_menu_model_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_menu_model_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_sub_menu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_sub_menu) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(is_sub_menu)
            )
        );
    }
    test_field_is_sub_menu();
    fn test_field_clear() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clear) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(clear)
            )
        );
    }
    test_field_clear();
    fn test_field_get_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_count) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_count)
            )
        );
    }
    test_field_get_count();
    fn test_field_add_separator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_separator) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(add_separator)
            )
        );
    }
    test_field_add_separator();
    fn test_field_add_item() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_item) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(add_item)
            )
        );
    }
    test_field_add_item();
    fn test_field_add_check_item() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_check_item) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(add_check_item)
            )
        );
    }
    test_field_add_check_item();
    fn test_field_add_radio_item() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_radio_item) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(add_radio_item)
            )
        );
    }
    test_field_add_radio_item();
    fn test_field_add_sub_menu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_sub_menu) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(add_sub_menu)
            )
        );
    }
    test_field_add_sub_menu();
    fn test_field_insert_separator_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).insert_separator_at) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(insert_separator_at)
            )
        );
    }
    test_field_insert_separator_at();
    fn test_field_insert_item_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).insert_item_at) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(insert_item_at)
            )
        );
    }
    test_field_insert_item_at();
    fn test_field_insert_check_item_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).insert_check_item_at) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(insert_check_item_at)
            )
        );
    }
    test_field_insert_check_item_at();
    fn test_field_insert_radio_item_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).insert_radio_item_at) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(insert_radio_item_at)
            )
        );
    }
    test_field_insert_radio_item_at();
    fn test_field_insert_sub_menu_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).insert_sub_menu_at) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(insert_sub_menu_at)
            )
        );
    }
    test_field_insert_sub_menu_at();
    fn test_field_remove() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(remove)
            )
        );
    }
    test_field_remove();
    fn test_field_remove_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove_at) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(remove_at)
            )
        );
    }
    test_field_remove_at();
    fn test_field_get_index_of() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_index_of) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_index_of)
            )
        );
    }
    test_field_get_index_of();
    fn test_field_get_command_id_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_command_id_at) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_command_id_at)
            )
        );
    }
    test_field_get_command_id_at();
    fn test_field_set_command_id_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_command_id_at) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_command_id_at)
            )
        );
    }
    test_field_set_command_id_at();
    fn test_field_get_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_label) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_label)
            )
        );
    }
    test_field_get_label();
    fn test_field_get_label_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_label_at) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_label_at)
            )
        );
    }
    test_field_get_label_at();
    fn test_field_set_label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_label) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_label)
            )
        );
    }
    test_field_set_label();
    fn test_field_set_label_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_label_at) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_label_at)
            )
        );
    }
    test_field_set_label_at();
    fn test_field_get_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_type) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_type)
            )
        );
    }
    test_field_get_type();
    fn test_field_get_type_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_type_at) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_type_at)
            )
        );
    }
    test_field_get_type_at();
    fn test_field_get_group_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_group_id) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_group_id)
            )
        );
    }
    test_field_get_group_id();
    fn test_field_get_group_id_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_group_id_at) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_group_id_at)
            )
        );
    }
    test_field_get_group_id_at();
    fn test_field_set_group_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_group_id) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_group_id)
            )
        );
    }
    test_field_set_group_id();
    fn test_field_set_group_id_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_group_id_at) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_group_id_at)
            )
        );
    }
    test_field_set_group_id_at();
    fn test_field_get_sub_menu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_sub_menu) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_sub_menu)
            )
        );
    }
    test_field_get_sub_menu();
    fn test_field_get_sub_menu_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_sub_menu_at) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_sub_menu_at)
            )
        );
    }
    test_field_get_sub_menu_at();
    fn test_field_is_visible() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_visible) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(is_visible)
            )
        );
    }
    test_field_is_visible();
    fn test_field_is_visible_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_visible_at) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(is_visible_at)
            )
        );
    }
    test_field_is_visible_at();
    fn test_field_set_visible() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_visible) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_visible)
            )
        );
    }
    test_field_set_visible();
    fn test_field_set_visible_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_visible_at) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_visible_at)
            )
        );
    }
    test_field_set_visible_at();
    fn test_field_is_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_enabled) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(is_enabled)
            )
        );
    }
    test_field_is_enabled();
    fn test_field_is_enabled_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_enabled_at) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(is_enabled_at)
            )
        );
    }
    test_field_is_enabled_at();
    fn test_field_set_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_enabled) as usize - ptr as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_enabled)
            )
        );
    }
    test_field_set_enabled();
    fn test_field_set_enabled_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_enabled_at) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_enabled_at)
            )
        );
    }
    test_field_set_enabled_at();
    fn test_field_is_checked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_checked) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(is_checked)
            )
        );
    }
    test_field_is_checked();
    fn test_field_is_checked_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_checked_at) as usize - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(is_checked_at)
            )
        );
    }
    test_field_is_checked_at();
    fn test_field_set_checked() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_checked) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_checked)
            )
        );
    }
    test_field_set_checked();
    fn test_field_set_checked_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_checked_at) as usize - ptr as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_checked_at)
            )
        );
    }
    test_field_set_checked_at();
    fn test_field_has_accelerator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_accelerator) as usize - ptr as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(has_accelerator)
            )
        );
    }
    test_field_has_accelerator();
    fn test_field_has_accelerator_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_accelerator_at) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(has_accelerator_at)
            )
        );
    }
    test_field_has_accelerator_at();
    fn test_field_set_accelerator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_accelerator) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_accelerator)
            )
        );
    }
    test_field_set_accelerator();
    fn test_field_set_accelerator_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_accelerator_at) as usize - ptr as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_accelerator_at)
            )
        );
    }
    test_field_set_accelerator_at();
    fn test_field_remove_accelerator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove_accelerator) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(remove_accelerator)
            )
        );
    }
    test_field_remove_accelerator();
    fn test_field_remove_accelerator_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).remove_accelerator_at) as usize - ptr as usize
            },
            416usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(remove_accelerator_at)
            )
        );
    }
    test_field_remove_accelerator_at();
    fn test_field_get_accelerator() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_accelerator) as usize - ptr as usize
            },
            424usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_accelerator)
            )
        );
    }
    test_field_get_accelerator();
    fn test_field_get_accelerator_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_accelerator_at) as usize - ptr as usize
            },
            432usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_accelerator_at)
            )
        );
    }
    test_field_get_accelerator_at();
    fn test_field_set_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_color) as usize - ptr as usize
            },
            440usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_color)
            )
        );
    }
    test_field_set_color();
    fn test_field_set_color_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_color_at) as usize - ptr as usize
            },
            448usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_color_at)
            )
        );
    }
    test_field_set_color_at();
    fn test_field_get_color() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_color) as usize - ptr as usize
            },
            456usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_color)
            )
        );
    }
    test_field_get_color();
    fn test_field_get_color_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_color_at) as usize - ptr as usize
            },
            464usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(get_color_at)
            )
        );
    }
    test_field_get_color_at();
    fn test_field_set_font_list() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_font_list) as usize - ptr as usize
            },
            472usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_font_list)
            )
        );
    }
    test_field_set_font_list();
    fn test_field_set_font_list_at() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_menu_model_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_font_list_at) as usize - ptr as usize
            },
            480usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_menu_model_t),
                "::",
                stringify!(set_font_list_at)
            )
        );
    }
    test_field_set_font_list_at();
}
#[doc = ""]
#[doc = " Supports creation and modification of menus. See cef_menu_id_t for the"]
#[doc = " command ids that have default implementations. All user-defined command ids"]
#[doc = " should be between MENU_ID_USER_FIRST and MENU_ID_USER_LAST. The functions of"]
#[doc = " this structure can only be accessed on the browser process the UI thread."]
#[doc = ""]
pub type cef_menu_model_t = _cef_menu_model_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new MenuModel with the specified |delegate|."]
    #[doc = ""]
    pub fn cef_menu_model_create(
        delegate: *mut _cef_menu_model_delegate_t,
    ) -> *mut cef_menu_model_t;
}
#[doc = ""]
#[doc = " Callback structure used for continuation of custom context menu display."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_run_context_menu_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Complete context menu display by selecting the specified |command_id| and"]
    #[doc = " |event_flags|."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_run_context_menu_callback_t,
            command_id: ::std::os::raw::c_int,
            event_flags: cef_event_flags_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel context menu display."]
    #[doc = ""]
    pub cancel:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_run_context_menu_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_run_context_menu_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_run_context_menu_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_run_context_menu_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_run_context_menu_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_run_context_menu_callback_t)
        )
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_run_context_menu_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_run_context_menu_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_run_context_menu_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_run_context_menu_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
    fn test_field_cancel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_run_context_menu_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_run_context_menu_callback_t),
                "::",
                stringify!(cancel)
            )
        );
    }
    test_field_cancel();
}
#[doc = ""]
#[doc = " Callback structure used for continuation of custom context menu display."]
#[doc = ""]
pub type cef_run_context_menu_callback_t = _cef_run_context_menu_callback_t;
#[doc = ""]
#[doc = " Callback structure used for continuation of custom quick menu display."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_run_quick_menu_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Complete quick menu display by selecting the specified |command_id| and"]
    #[doc = " |event_flags|."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_run_quick_menu_callback_t,
            command_id: ::std::os::raw::c_int,
            event_flags: cef_event_flags_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel quick menu display."]
    #[doc = ""]
    pub cancel:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_run_quick_menu_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_run_quick_menu_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_run_quick_menu_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_run_quick_menu_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_run_quick_menu_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_run_quick_menu_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_run_quick_menu_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_run_quick_menu_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_run_quick_menu_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_run_quick_menu_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
    fn test_field_cancel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_run_quick_menu_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_run_quick_menu_callback_t),
                "::",
                stringify!(cancel)
            )
        );
    }
    test_field_cancel();
}
#[doc = ""]
#[doc = " Callback structure used for continuation of custom quick menu display."]
#[doc = ""]
pub type cef_run_quick_menu_callback_t = _cef_run_quick_menu_callback_t;
#[doc = ""]
#[doc = " Implement this structure to handle context menu events. The functions of"]
#[doc = " this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_context_menu_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called before a context menu is displayed. |params| provides information"]
    #[doc = " about the context menu state. |model| initially contains the default"]
    #[doc = " context menu. The |model| can be cleared to show no context menu or"]
    #[doc = " modified to show a custom menu. Do not keep references to |params| or"]
    #[doc = " |model| outside of this callback."]
    #[doc = ""]
    pub on_before_context_menu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            params: *mut _cef_context_menu_params_t,
            model: *mut _cef_menu_model_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called to allow custom display of the context menu. |params| provides"]
    #[doc = " information about the context menu state. |model| contains the context"]
    #[doc = " menu model resulting from OnBeforeContextMenu. For custom display return"]
    #[doc = " true (1) and execute |callback| either synchronously or asynchronously"]
    #[doc = " with the selected command ID. For default display return false (0). Do not"]
    #[doc = " keep references to |params| or |model| outside of this callback."]
    #[doc = ""]
    pub run_context_menu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            params: *mut _cef_context_menu_params_t,
            model: *mut _cef_menu_model_t,
            callback: *mut _cef_run_context_menu_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to execute a command selected from the context menu. Return true"]
    #[doc = " (1) if the command was handled or false (0) for the default"]
    #[doc = " implementation. See cef_menu_id_t for the command ids that have default"]
    #[doc = " implementations. All user-defined command ids should be between"]
    #[doc = " MENU_ID_USER_FIRST and MENU_ID_USER_LAST. |params| will have the same"]
    #[doc = " values as what was passed to on_before_context_menu(). Do not keep a"]
    #[doc = " reference to |params| outside of this callback."]
    #[doc = ""]
    pub on_context_menu_command: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            params: *mut _cef_context_menu_params_t,
            command_id: ::std::os::raw::c_int,
            event_flags: cef_event_flags_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the context menu is dismissed irregardless of whether the menu"]
    #[doc = " was canceled or a command was selected."]
    #[doc = ""]
    pub on_context_menu_dismissed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called to allow custom display of the quick menu for a windowless browser."]
    #[doc = " |location| is the top left corner of the selected region. |size| is the"]
    #[doc = " size of the selected region. |edit_state_flags| is a combination of flags"]
    #[doc = " that represent the state of the quick menu. Return true (1) if the menu"]
    #[doc = " will be handled and execute |callback| either synchronously or"]
    #[doc = " asynchronously with the selected command ID. Return false (0) to cancel"]
    #[doc = " the menu."]
    #[doc = ""]
    pub run_quick_menu: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            location: *const cef_point_t,
            size: *const cef_size_t,
            edit_state_flags: cef_quick_menu_edit_state_flags_t,
            callback: *mut _cef_run_quick_menu_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to execute a command selected from the quick menu for a windowless"]
    #[doc = " browser. Return true (1) if the command was handled or false (0) for the"]
    #[doc = " default implementation. See cef_menu_id_t for command IDs that have"]
    #[doc = " default implementations."]
    #[doc = ""]
    pub on_quick_menu_command: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            command_id: ::std::os::raw::c_int,
            event_flags: cef_event_flags_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the quick menu for a windowless browser is dismissed"]
    #[doc = " irregardless of whether the menu was canceled or a command was selected."]
    #[doc = ""]
    pub on_quick_menu_dismissed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_context_menu_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_context_menu_handler_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_context_menu_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_context_menu_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_context_menu_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_before_context_menu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_before_context_menu) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_handler_t),
                "::",
                stringify!(on_before_context_menu)
            )
        );
    }
    test_field_on_before_context_menu();
    fn test_field_run_context_menu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).run_context_menu) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_handler_t),
                "::",
                stringify!(run_context_menu)
            )
        );
    }
    test_field_run_context_menu();
    fn test_field_on_context_menu_command() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_context_menu_command) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_handler_t),
                "::",
                stringify!(on_context_menu_command)
            )
        );
    }
    test_field_on_context_menu_command();
    fn test_field_on_context_menu_dismissed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_context_menu_dismissed) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_handler_t),
                "::",
                stringify!(on_context_menu_dismissed)
            )
        );
    }
    test_field_on_context_menu_dismissed();
    fn test_field_run_quick_menu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).run_quick_menu) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_handler_t),
                "::",
                stringify!(run_quick_menu)
            )
        );
    }
    test_field_run_quick_menu();
    fn test_field_on_quick_menu_command() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_quick_menu_command) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_handler_t),
                "::",
                stringify!(on_quick_menu_command)
            )
        );
    }
    test_field_on_quick_menu_command();
    fn test_field_on_quick_menu_dismissed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_quick_menu_dismissed) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_handler_t),
                "::",
                stringify!(on_quick_menu_dismissed)
            )
        );
    }
    test_field_on_quick_menu_dismissed();
}
#[doc = ""]
#[doc = " Implement this structure to handle context menu events. The functions of"]
#[doc = " this structure will be called on the UI thread."]
#[doc = ""]
pub type cef_context_menu_handler_t = _cef_context_menu_handler_t;
#[doc = ""]
#[doc = " Provides information about the context menu state. The functions of this"]
#[doc = " structure can only be accessed on browser process the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_context_menu_params_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the X coordinate of the mouse where the context menu was invoked."]
    #[doc = " Coords are relative to the associated RenderView's origin."]
    #[doc = ""]
    pub get_xcoord: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the Y coordinate of the mouse where the context menu was invoked."]
    #[doc = " Coords are relative to the associated RenderView's origin."]
    #[doc = ""]
    pub get_ycoord: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns flags representing the type of node that the context menu was"]
    #[doc = " invoked on."]
    #[doc = ""]
    pub get_type_flags: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_type_flags_t,
    >,
    #[doc = ""]
    #[doc = " Returns the URL of the link, if any, that encloses the node that the"]
    #[doc = " context menu was invoked on."]
    #[doc = ""]
    pub get_link_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the link URL, if any, to be used ONLY for \"copy link address\". We"]
    #[doc = " don't validate this field in the frontend process."]
    #[doc = ""]
    pub get_unfiltered_link_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the source URL, if any, for the element that the context menu was"]
    #[doc = " invoked on. Example of elements with source URLs are img, audio, and"]
    #[doc = " video."]
    #[doc = ""]
    pub get_source_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the context menu was invoked on an image which has"]
    #[doc = " non-NULL contents."]
    #[doc = ""]
    pub has_image_contents: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the title text or the alt text if the context menu was invoked on"]
    #[doc = " an image."]
    #[doc = ""]
    pub get_title_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the URL of the top level page that the context menu was invoked"]
    #[doc = " on."]
    #[doc = ""]
    pub get_page_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the URL of the subframe that the context menu was invoked on."]
    #[doc = ""]
    pub get_frame_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the character encoding of the subframe that the context menu was"]
    #[doc = " invoked on."]
    #[doc = ""]
    pub get_frame_charset: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the type of context node that the context menu was invoked on."]
    #[doc = ""]
    pub get_media_type: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_media_type_t,
    >,
    #[doc = ""]
    #[doc = " Returns flags representing the actions supported by the media element, if"]
    #[doc = " any, that the context menu was invoked on."]
    #[doc = ""]
    pub get_media_state_flags: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_media_state_flags_t,
    >,
    #[doc = ""]
    #[doc = " Returns the text of the selection, if any, that the context menu was"]
    #[doc = " invoked on."]
    #[doc = ""]
    pub get_selection_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the text of the misspelled word, if any, that the context menu was"]
    #[doc = " invoked on."]
    #[doc = ""]
    pub get_misspelled_word: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if suggestions exist, false (0) otherwise. Fills in"]
    #[doc = " |suggestions| from the spell check service for the misspelled word if"]
    #[doc = " there is one."]
    #[doc = ""]
    pub get_dictionary_suggestions: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
            suggestions: cef_string_list_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the context menu was invoked on an editable node."]
    #[doc = ""]
    pub is_editable: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the context menu was invoked on an editable node where"]
    #[doc = " spell-check is enabled."]
    #[doc = ""]
    pub is_spell_check_enabled: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns flags representing the actions supported by the editable node, if"]
    #[doc = " any, that the context menu was invoked on."]
    #[doc = ""]
    pub get_edit_state_flags: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_context_menu_params_t,
        ) -> cef_context_menu_edit_state_flags_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the context menu contains items specified by the"]
    #[doc = " renderer process."]
    #[doc = ""]
    pub is_custom_menu: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_context_menu_params_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_context_menu_params_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_context_menu_params_t>(),
        200usize,
        concat!("Size of: ", stringify!(_cef_context_menu_params_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_context_menu_params_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_context_menu_params_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_xcoord() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_xcoord) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_xcoord)
            )
        );
    }
    test_field_get_xcoord();
    fn test_field_get_ycoord() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_ycoord) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_ycoord)
            )
        );
    }
    test_field_get_ycoord();
    fn test_field_get_type_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_type_flags) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_type_flags)
            )
        );
    }
    test_field_get_type_flags();
    fn test_field_get_link_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_link_url) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_link_url)
            )
        );
    }
    test_field_get_link_url();
    fn test_field_get_unfiltered_link_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_unfiltered_link_url) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_unfiltered_link_url)
            )
        );
    }
    test_field_get_unfiltered_link_url();
    fn test_field_get_source_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_source_url) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_source_url)
            )
        );
    }
    test_field_get_source_url();
    fn test_field_has_image_contents() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_image_contents) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(has_image_contents)
            )
        );
    }
    test_field_has_image_contents();
    fn test_field_get_title_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_title_text) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_title_text)
            )
        );
    }
    test_field_get_title_text();
    fn test_field_get_page_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_page_url) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_page_url)
            )
        );
    }
    test_field_get_page_url();
    fn test_field_get_frame_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_frame_url) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_frame_url)
            )
        );
    }
    test_field_get_frame_url();
    fn test_field_get_frame_charset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_frame_charset) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_frame_charset)
            )
        );
    }
    test_field_get_frame_charset();
    fn test_field_get_media_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_media_type) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_media_type)
            )
        );
    }
    test_field_get_media_type();
    fn test_field_get_media_state_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_media_state_flags) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_media_state_flags)
            )
        );
    }
    test_field_get_media_state_flags();
    fn test_field_get_selection_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_selection_text) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_selection_text)
            )
        );
    }
    test_field_get_selection_text();
    fn test_field_get_misspelled_word() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_misspelled_word) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_misspelled_word)
            )
        );
    }
    test_field_get_misspelled_word();
    fn test_field_get_dictionary_suggestions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_dictionary_suggestions) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_dictionary_suggestions)
            )
        );
    }
    test_field_get_dictionary_suggestions();
    fn test_field_is_editable() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_editable) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(is_editable)
            )
        );
    }
    test_field_is_editable();
    fn test_field_is_spell_check_enabled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_spell_check_enabled) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(is_spell_check_enabled)
            )
        );
    }
    test_field_is_spell_check_enabled();
    fn test_field_get_edit_state_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_edit_state_flags) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(get_edit_state_flags)
            )
        );
    }
    test_field_get_edit_state_flags();
    fn test_field_is_custom_menu() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_context_menu_params_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_custom_menu) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_context_menu_params_t),
                "::",
                stringify!(is_custom_menu)
            )
        );
    }
    test_field_is_custom_menu();
}
#[doc = ""]
#[doc = " Provides information about the context menu state. The functions of this"]
#[doc = " structure can only be accessed on browser process the UI thread."]
#[doc = ""]
pub type cef_context_menu_params_t = _cef_context_menu_params_t;
#[doc = ""]
#[doc = " Callback structure for asynchronous continuation of file dialog requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_file_dialog_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue the file selection. |file_paths| should be a single value or a"]
    #[doc = " list of values depending on the dialog mode. An NULL |file_paths| value is"]
    #[doc = " treated the same as calling cancel()."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_file_dialog_callback_t,
            file_paths: cef_string_list_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel the file selection."]
    #[doc = ""]
    pub cancel:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_file_dialog_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_file_dialog_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_file_dialog_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_file_dialog_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_file_dialog_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_file_dialog_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_file_dialog_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_file_dialog_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_file_dialog_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_file_dialog_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
    fn test_field_cancel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_file_dialog_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_file_dialog_callback_t),
                "::",
                stringify!(cancel)
            )
        );
    }
    test_field_cancel();
}
#[doc = ""]
#[doc = " Callback structure for asynchronous continuation of file dialog requests."]
#[doc = ""]
pub type cef_file_dialog_callback_t = _cef_file_dialog_callback_t;
#[doc = ""]
#[doc = " Implement this structure to handle dialog events. The functions of this"]
#[doc = " structure will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_dialog_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called to run a file chooser dialog. |mode| represents the type of dialog"]
    #[doc = " to display. |title| to the title to be used for the dialog and may be NULL"]
    #[doc = " to show the default title (\"Open\" or \"Save\" depending on the mode)."]
    #[doc = " |default_file_path| is the path with optional directory and/or file name"]
    #[doc = " component that should be initially selected in the dialog."]
    #[doc = " |accept_filters| are used to restrict the selectable file types and may"]
    #[doc = " any combination of (a) valid lower-cased MIME types (e.g. \"text/*\" or"]
    #[doc = " \"image/*\"), (b) individual file extensions (e.g. \".txt\" or \".png\"), or (c)"]
    #[doc = " combined description and file extension delimited using \"|\" and \";\" (e.g."]
    #[doc = " \"Image Types|.png;.gif;.jpg\"). To display a custom dialog return true (1)"]
    #[doc = " and execute |callback| either inline or at a later time. To display the"]
    #[doc = " default dialog return false (0)."]
    #[doc = ""]
    pub on_file_dialog: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_dialog_handler_t,
            browser: *mut _cef_browser_t,
            mode: cef_file_dialog_mode_t,
            title: *const cef_string_t,
            default_file_path: *const cef_string_t,
            accept_filters: cef_string_list_t,
            callback: *mut _cef_file_dialog_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_dialog_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_dialog_handler_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_dialog_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_dialog_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_dialog_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dialog_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dialog_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_file_dialog() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_dialog_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_file_dialog) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_dialog_handler_t),
                "::",
                stringify!(on_file_dialog)
            )
        );
    }
    test_field_on_file_dialog();
}
#[doc = ""]
#[doc = " Implement this structure to handle dialog events. The functions of this"]
#[doc = " structure will be called on the browser process UI thread."]
#[doc = ""]
pub type cef_dialog_handler_t = _cef_dialog_handler_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser display state."]
#[doc = " The functions of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_display_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when a frame's address has changed."]
    #[doc = ""]
    pub on_address_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            url: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the page title changes."]
    #[doc = ""]
    pub on_title_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            title: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the page icon changes."]
    #[doc = ""]
    pub on_favicon_urlchange: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            icon_urls: cef_string_list_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when web content in the page has toggled fullscreen mode. If"]
    #[doc = " |fullscreen| is true (1) the content will automatically be sized to fill"]
    #[doc = " the browser content area. If |fullscreen| is false (0) the content will"]
    #[doc = " automatically return to its original size and position. The client is"]
    #[doc = " responsible for resizing the browser if desired."]
    #[doc = ""]
    pub on_fullscreen_mode_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            fullscreen: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the browser is about to display a tooltip. |text| contains the"]
    #[doc = " text that will be displayed in the tooltip. To handle the display of the"]
    #[doc = " tooltip yourself return true (1). Otherwise, you can optionally modify"]
    #[doc = " |text| and then return false (0) to allow the browser to display the"]
    #[doc = " tooltip. When window rendering is disabled the application is responsible"]
    #[doc = " for drawing tooltips and the return value is ignored."]
    #[doc = ""]
    pub on_tooltip: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            text: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the browser receives a status message. |value| contains the"]
    #[doc = " text that will be displayed in the status message."]
    #[doc = ""]
    pub on_status_message: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            value: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called to display a console message. Return true (1) to stop the message"]
    #[doc = " from being output to the console."]
    #[doc = ""]
    pub on_console_message: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            level: cef_log_severity_t,
            message: *const cef_string_t,
            source: *const cef_string_t,
            line: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when auto-resize is enabled via"]
    #[doc = " cef_browser_host_t::SetAutoResizeEnabled and the contents have auto-"]
    #[doc = " resized. |new_size| will be the desired size in view coordinates. Return"]
    #[doc = " true (1) if the resize was handled or false (0) for default handling."]
    #[doc = ""]
    pub on_auto_resize: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            new_size: *const cef_size_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the overall page loading progress has changed. |progress|"]
    #[doc = " ranges from 0.0 to 1.0."]
    #[doc = ""]
    pub on_loading_progress_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            progress: f64,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the browser's cursor has changed. If |type| is CT_CUSTOM then"]
    #[doc = " |custom_cursor_info| will be populated with the custom cursor information."]
    #[doc = " Return true (1) if the cursor change was handled or false (0) for default"]
    #[doc = " handling."]
    #[doc = ""]
    pub on_cursor_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            cursor: ::std::os::raw::c_ulong,
            type_: cef_cursor_type_t,
            custom_cursor_info: *const cef_cursor_info_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the browser's access to an audio and/or video source has"]
    #[doc = " changed."]
    #[doc = ""]
    pub on_media_access_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_display_handler_t,
            browser: *mut _cef_browser_t,
            has_video_access: ::std::os::raw::c_int,
            has_audio_access: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_display_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_display_handler_t>(),
        128usize,
        concat!("Size of: ", stringify!(_cef_display_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_display_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_display_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_address_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_address_change) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(on_address_change)
            )
        );
    }
    test_field_on_address_change();
    fn test_field_on_title_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_title_change) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(on_title_change)
            )
        );
    }
    test_field_on_title_change();
    fn test_field_on_favicon_urlchange() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_favicon_urlchange) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(on_favicon_urlchange)
            )
        );
    }
    test_field_on_favicon_urlchange();
    fn test_field_on_fullscreen_mode_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_fullscreen_mode_change) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(on_fullscreen_mode_change)
            )
        );
    }
    test_field_on_fullscreen_mode_change();
    fn test_field_on_tooltip() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_tooltip) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(on_tooltip)
            )
        );
    }
    test_field_on_tooltip();
    fn test_field_on_status_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_status_message) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(on_status_message)
            )
        );
    }
    test_field_on_status_message();
    fn test_field_on_console_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_console_message) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(on_console_message)
            )
        );
    }
    test_field_on_console_message();
    fn test_field_on_auto_resize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_auto_resize) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(on_auto_resize)
            )
        );
    }
    test_field_on_auto_resize();
    fn test_field_on_loading_progress_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_loading_progress_change) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(on_loading_progress_change)
            )
        );
    }
    test_field_on_loading_progress_change();
    fn test_field_on_cursor_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_cursor_change) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(on_cursor_change)
            )
        );
    }
    test_field_on_cursor_change();
    fn test_field_on_media_access_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_display_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_media_access_change) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_display_handler_t),
                "::",
                stringify!(on_media_access_change)
            )
        );
    }
    test_field_on_media_access_change();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser display state."]
#[doc = " The functions of this structure will be called on the UI thread."]
#[doc = ""]
pub type cef_display_handler_t = _cef_display_handler_t;
#[doc = ""]
#[doc = " Structure used to represent a download item."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_item_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. Do not call any other functions"]
    #[doc = " if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the download is in progress."]
    #[doc = ""]
    pub is_in_progress: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the download is complete."]
    #[doc = ""]
    pub is_complete: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the download has been canceled or interrupted."]
    #[doc = ""]
    pub is_canceled: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a simple speed estimate in bytes/s."]
    #[doc = ""]
    pub get_current_speed:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> int64>,
    #[doc = ""]
    #[doc = " Returns the rough percent complete or -1 if the receive total size is"]
    #[doc = " unknown."]
    #[doc = ""]
    pub get_percent_complete: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the total number of bytes."]
    #[doc = ""]
    pub get_total_bytes:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> int64>,
    #[doc = ""]
    #[doc = " Returns the number of received bytes."]
    #[doc = ""]
    pub get_received_bytes:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> int64>,
    #[doc = ""]
    #[doc = " Returns the time that the download started."]
    #[doc = ""]
    pub get_start_time: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_basetime_t,
    >,
    #[doc = ""]
    #[doc = " Returns the time that the download ended."]
    #[doc = ""]
    pub get_end_time: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_basetime_t,
    >,
    #[doc = ""]
    #[doc = " Returns the full path to the downloaded or downloading file."]
    #[doc = ""]
    pub get_full_path: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the unique identifier for this download."]
    #[doc = ""]
    pub get_id:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> uint32>,
    #[doc = ""]
    #[doc = " Returns the URL."]
    #[doc = ""]
    pub get_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the original URL before any redirections."]
    #[doc = ""]
    pub get_original_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the suggested file name."]
    #[doc = ""]
    pub get_suggested_file_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the content disposition."]
    #[doc = ""]
    pub get_content_disposition: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the mime type."]
    #[doc = ""]
    pub get_mime_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_download_item_t) -> cef_string_userfree_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_download_item_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_download_item_t>(),
        176usize,
        concat!("Size of: ", stringify!(_cef_download_item_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_download_item_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_download_item_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_is_in_progress() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_in_progress) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(is_in_progress)
            )
        );
    }
    test_field_is_in_progress();
    fn test_field_is_complete() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_complete) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(is_complete)
            )
        );
    }
    test_field_is_complete();
    fn test_field_is_canceled() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_canceled) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(is_canceled)
            )
        );
    }
    test_field_is_canceled();
    fn test_field_get_current_speed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_current_speed) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_current_speed)
            )
        );
    }
    test_field_get_current_speed();
    fn test_field_get_percent_complete() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_percent_complete) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_percent_complete)
            )
        );
    }
    test_field_get_percent_complete();
    fn test_field_get_total_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_total_bytes) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_total_bytes)
            )
        );
    }
    test_field_get_total_bytes();
    fn test_field_get_received_bytes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_received_bytes) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_received_bytes)
            )
        );
    }
    test_field_get_received_bytes();
    fn test_field_get_start_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_start_time) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_start_time)
            )
        );
    }
    test_field_get_start_time();
    fn test_field_get_end_time() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_end_time) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_end_time)
            )
        );
    }
    test_field_get_end_time();
    fn test_field_get_full_path() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_full_path) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_full_path)
            )
        );
    }
    test_field_get_full_path();
    fn test_field_get_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_id) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_id)
            )
        );
    }
    test_field_get_id();
    fn test_field_get_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_url) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_url)
            )
        );
    }
    test_field_get_url();
    fn test_field_get_original_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_original_url) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_original_url)
            )
        );
    }
    test_field_get_original_url();
    fn test_field_get_suggested_file_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_suggested_file_name) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_suggested_file_name)
            )
        );
    }
    test_field_get_suggested_file_name();
    fn test_field_get_content_disposition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_content_disposition) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_content_disposition)
            )
        );
    }
    test_field_get_content_disposition();
    fn test_field_get_mime_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_mime_type) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_t),
                "::",
                stringify!(get_mime_type)
            )
        );
    }
    test_field_get_mime_type();
}
#[doc = ""]
#[doc = " Structure used to represent a download item."]
#[doc = ""]
pub type cef_download_item_t = _cef_download_item_t;
#[doc = ""]
#[doc = " Callback structure used to asynchronously continue a download."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_before_download_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Call to continue the download. Set |download_path| to the full file path"]
    #[doc = " for the download including the file name or leave blank to use the"]
    #[doc = " suggested name and the default temp directory. Set |show_dialog| to true"]
    #[doc = " (1) if you do wish to show the default \"Save As\" dialog."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_before_download_callback_t,
            download_path: *const cef_string_t,
            show_dialog: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_before_download_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_before_download_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_before_download_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_before_download_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_before_download_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_before_download_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_before_download_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_before_download_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_before_download_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
}
#[doc = ""]
#[doc = " Callback structure used to asynchronously continue a download."]
#[doc = ""]
pub type cef_before_download_callback_t = _cef_before_download_callback_t;
#[doc = ""]
#[doc = " Callback structure used to asynchronously cancel a download."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_item_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Call to cancel the download."]
    #[doc = ""]
    pub cancel:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_callback_t)>,
    #[doc = ""]
    #[doc = " Call to pause the download."]
    #[doc = ""]
    pub pause:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_callback_t)>,
    #[doc = ""]
    #[doc = " Call to resume the download."]
    #[doc = ""]
    pub resume:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_download_item_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_download_item_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_download_item_callback_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_download_item_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_download_item_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_download_item_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cancel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_callback_t),
                "::",
                stringify!(cancel)
            )
        );
    }
    test_field_cancel();
    fn test_field_pause() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).pause) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_callback_t),
                "::",
                stringify!(pause)
            )
        );
    }
    test_field_pause();
    fn test_field_resume() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_item_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).resume) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_item_callback_t),
                "::",
                stringify!(resume)
            )
        );
    }
    test_field_resume();
}
#[doc = ""]
#[doc = " Callback structure used to asynchronously cancel a download."]
#[doc = ""]
pub type cef_download_item_callback_t = _cef_download_item_callback_t;
#[doc = ""]
#[doc = " Structure used to handle file downloads. The functions of this structure"]
#[doc = " will called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_download_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called before a download begins in response to a user-initiated action"]
    #[doc = " (e.g. alt + link click or link click that returns a `Content-Disposition:"]
    #[doc = " attachment` response from the server). |url| is the target download URL"]
    #[doc = " and |request_function| is the target function (GET, POST, etc). Return"]
    #[doc = " true (1) to proceed with the download or false (0) to cancel the download."]
    #[doc = ""]
    pub can_download: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_download_handler_t,
            browser: *mut _cef_browser_t,
            url: *const cef_string_t,
            request_method: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called before a download begins. |suggested_name| is the suggested name"]
    #[doc = " for the download file. By default the download will be canceled. Execute"]
    #[doc = " |callback| either asynchronously or in this function to continue the"]
    #[doc = " download if desired. Do not keep a reference to |download_item| outside of"]
    #[doc = " this function."]
    #[doc = ""]
    pub on_before_download: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_download_handler_t,
            browser: *mut _cef_browser_t,
            download_item: *mut _cef_download_item_t,
            suggested_name: *const cef_string_t,
            callback: *mut _cef_before_download_callback_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when a download's status or progress information has been updated."]
    #[doc = " This may be called multiple times before and after on_before_download()."]
    #[doc = " Execute |callback| either asynchronously or in this function to cancel the"]
    #[doc = " download if desired. Do not keep a reference to |download_item| outside of"]
    #[doc = " this function."]
    #[doc = ""]
    pub on_download_updated: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_download_handler_t,
            browser: *mut _cef_browser_t,
            download_item: *mut _cef_download_item_t,
            callback: *mut _cef_download_item_callback_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_download_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_download_handler_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_download_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_download_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_download_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_can_download() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).can_download) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_handler_t),
                "::",
                stringify!(can_download)
            )
        );
    }
    test_field_can_download();
    fn test_field_on_before_download() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_before_download) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_handler_t),
                "::",
                stringify!(on_before_download)
            )
        );
    }
    test_field_on_before_download();
    fn test_field_on_download_updated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_download_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_download_updated) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_download_handler_t),
                "::",
                stringify!(on_download_updated)
            )
        );
    }
    test_field_on_download_updated();
}
#[doc = ""]
#[doc = " Structure used to handle file downloads. The functions of this structure"]
#[doc = " will called on the browser process UI thread."]
#[doc = ""]
pub type cef_download_handler_t = _cef_download_handler_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to dragging. The functions"]
#[doc = " of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_drag_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when an external drag event enters the browser window. |dragData|"]
    #[doc = " contains the drag event data and |mask| represents the type of drag"]
    #[doc = " operation. Return false (0) for default drag handling behavior or true (1)"]
    #[doc = " to cancel the drag event."]
    #[doc = ""]
    pub on_drag_enter: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_handler_t,
            browser: *mut _cef_browser_t,
            dragData: *mut _cef_drag_data_t,
            mask: cef_drag_operations_mask_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called whenever draggable regions for the browser window change. These can"]
    #[doc = " be specified using the '-webkit-app-region: drag/no-drag' CSS-property. If"]
    #[doc = " draggable regions are never defined in a document this function will also"]
    #[doc = " never be called. If the last draggable region is removed from a document"]
    #[doc = " this function will be called with an NULL vector."]
    #[doc = ""]
    pub on_draggable_regions_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_drag_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            regionsCount: size_t,
            regions: *const cef_draggable_region_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_drag_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_drag_handler_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_drag_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_drag_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_drag_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_drag_enter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_drag_enter) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_handler_t),
                "::",
                stringify!(on_drag_enter)
            )
        );
    }
    test_field_on_drag_enter();
    fn test_field_on_draggable_regions_changed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_drag_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_draggable_regions_changed) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_drag_handler_t),
                "::",
                stringify!(on_draggable_regions_changed)
            )
        );
    }
    test_field_on_draggable_regions_changed();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to dragging. The functions"]
#[doc = " of this structure will be called on the UI thread."]
#[doc = ""]
pub type cef_drag_handler_t = _cef_drag_handler_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to find results. The"]
#[doc = " functions of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_find_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called to report find results returned by cef_browser_host_t::find()."]
    #[doc = " |identifer| is a unique incremental identifier for the currently active"]
    #[doc = " search, |count| is the number of matches currently identified,"]
    #[doc = " |selectionRect| is the location of where the match was found (in window"]
    #[doc = " coordinates), |activeMatchOrdinal| is the current position in the search"]
    #[doc = " results, and |finalUpdate| is true (1) if this is the last find"]
    #[doc = " notification."]
    #[doc = ""]
    pub on_find_result: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_find_handler_t,
            browser: *mut _cef_browser_t,
            identifier: ::std::os::raw::c_int,
            count: ::std::os::raw::c_int,
            selectionRect: *const cef_rect_t,
            activeMatchOrdinal: ::std::os::raw::c_int,
            finalUpdate: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_find_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_find_handler_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_find_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_find_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_find_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_find_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_find_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_find_result() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_find_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_find_result) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_find_handler_t),
                "::",
                stringify!(on_find_result)
            )
        );
    }
    test_field_on_find_result();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to find results. The"]
#[doc = " functions of this structure will be called on the UI thread."]
#[doc = ""]
pub type cef_find_handler_t = _cef_find_handler_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to focus. The functions of"]
#[doc = " this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_focus_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when the browser component is about to loose focus. For instance,"]
    #[doc = " if focus was on the last HTML element and the user pressed the TAB key."]
    #[doc = " |next| will be true (1) if the browser is giving focus to the next"]
    #[doc = " component and false (0) if the browser is giving focus to the previous"]
    #[doc = " component."]
    #[doc = ""]
    pub on_take_focus: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_focus_handler_t,
            browser: *mut _cef_browser_t,
            next: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the browser component is requesting focus. |source| indicates"]
    #[doc = " where the focus request is originating from. Return false (0) to allow the"]
    #[doc = " focus to be set or true (1) to cancel setting the focus."]
    #[doc = ""]
    pub on_set_focus: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_focus_handler_t,
            browser: *mut _cef_browser_t,
            source: cef_focus_source_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the browser component has received focus."]
    #[doc = ""]
    pub on_got_focus: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_focus_handler_t, browser: *mut _cef_browser_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_focus_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_focus_handler_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_focus_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_focus_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_focus_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_focus_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_focus_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_take_focus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_focus_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_take_focus) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_focus_handler_t),
                "::",
                stringify!(on_take_focus)
            )
        );
    }
    test_field_on_take_focus();
    fn test_field_on_set_focus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_focus_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_set_focus) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_focus_handler_t),
                "::",
                stringify!(on_set_focus)
            )
        );
    }
    test_field_on_set_focus();
    fn test_field_on_got_focus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_focus_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_got_focus) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_focus_handler_t),
                "::",
                stringify!(on_got_focus)
            )
        );
    }
    test_field_on_got_focus();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to focus. The functions of"]
#[doc = " this structure will be called on the UI thread."]
#[doc = ""]
pub type cef_focus_handler_t = _cef_focus_handler_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to cef_frame_t life span."]
#[doc = " The order of callbacks is:"]
#[doc = ""]
#[doc = " (1) During initial cef_browser_host_t creation and navigation of the main"]
#[doc = " frame: - cef_frame_handler_t::OnFrameCreated => The initial main frame"]
#[doc = " object has been"]
#[doc = "   created. Any commands will be queued until the frame is attached."]
#[doc = " - cef_frame_handler_t::OnMainFrameChanged => The initial main frame object"]
#[doc = " has"]
#[doc = "   been assigned to the browser."]
#[doc = " - cef_life_span_handler_t::OnAfterCreated => The browser is now valid and"]
#[doc = " can be"]
#[doc = "   used."]
#[doc = " - cef_frame_handler_t::OnFrameAttached => The initial main frame object is"]
#[doc = " now"]
#[doc = "   connected to its peer in the renderer process. Commands can be routed."]
#[doc = ""]
#[doc = " (2) During further cef_browser_host_t navigation/loading of the main frame"]
#[doc = "     and/or sub-frames:"]
#[doc = " - cef_frame_handler_t::OnFrameCreated => A new main frame or sub-frame"]
#[doc = " object"]
#[doc = "   has been created. Any commands will be queued until the frame is attached."]
#[doc = " - cef_frame_handler_t::OnFrameAttached => A new main frame or sub-frame"]
#[doc = " object"]
#[doc = "   is now connected to its peer in the renderer process. Commands can be"]
#[doc = "   routed."]
#[doc = " - cef_frame_handler_t::OnFrameDetached => An existing main frame or sub-"]
#[doc = " frame"]
#[doc = "   object has lost its connection to the renderer process. If multiple"]
#[doc = "   objects are detached at the same time then notifications will be sent for"]
#[doc = "   any sub-frame objects before the main frame object. Commands can no longer"]
#[doc = "   be routed and will be discarded."]
#[doc = " - cef_frame_handler_t::OnMainFrameChanged => A new main frame object has"]
#[doc = " been"]
#[doc = "   assigned to the browser. This will only occur with cross-origin navigation"]
#[doc = "   or re-navigation after renderer process termination (due to crashes, etc)."]
#[doc = ""]
#[doc = " (3) During final cef_browser_host_t destruction of the main frame: -"]
#[doc = " cef_frame_handler_t::OnFrameDetached => Any sub-frame objects have lost"]
#[doc = " their"]
#[doc = "   connection to the renderer process. Commands can no longer be routed and"]
#[doc = "   will be discarded."]
#[doc = " - cef_life_span_handler_t::OnBeforeClose => The browser has been destroyed."]
#[doc = " - cef_frame_handler_t::OnFrameDetached => The main frame object have lost"]
#[doc = " its"]
#[doc = "   connection to the renderer process. Notifications will be sent for any"]
#[doc = "   sub-frame objects before the main frame object. Commands can no longer be"]
#[doc = "   routed and will be discarded."]
#[doc = " - cef_frame_handler_t::OnMainFrameChanged => The final main frame object has"]
#[doc = "   been removed from the browser."]
#[doc = ""]
#[doc = " Cross-origin navigation and/or loading receives special handling."]
#[doc = ""]
#[doc = " When the main frame navigates to a different origin the OnMainFrameChanged"]
#[doc = " callback (2) will be executed with the old and new main frame objects."]
#[doc = ""]
#[doc = " When a new sub-frame is loaded in, or an existing sub-frame is navigated to,"]
#[doc = " a different origin from the parent frame, a temporary sub-frame object will"]
#[doc = " first be created in the parent's renderer process. That temporary sub-frame"]
#[doc = " will then be discarded after the real cross-origin sub-frame is created in"]
#[doc = " the new/target renderer process. The client will receive cross-origin"]
#[doc = " navigation callbacks (2) for the transition from the temporary sub-frame to"]
#[doc = " the real sub-frame. The temporary sub-frame will not recieve or execute"]
#[doc = " commands during this transitional period (any sent commands will be"]
#[doc = " discarded)."]
#[doc = ""]
#[doc = " When a new popup browser is created in a different origin from the parent"]
#[doc = " browser, a temporary main frame object for the popup will first be created"]
#[doc = " in the parent's renderer process. That temporary main frame will then be"]
#[doc = " discarded after the real cross-origin main frame is created in the"]
#[doc = " new/target renderer process. The client will recieve creation and initial"]
#[doc = " navigation callbacks (1) for the temporary main frame, followed by cross-"]
#[doc = " origin navigation callbacks (2) for the transition from the temporary main"]
#[doc = " frame to the real main frame. The temporary main frame may receive and"]
#[doc = " execute commands during this transitional period (any sent commands may be"]
#[doc = " executed, but the behavior is potentially undesirable since they execute in"]
#[doc = " the parent browser's renderer process and not the new/target renderer"]
#[doc = " process)."]
#[doc = ""]
#[doc = " Callbacks will not be executed for placeholders that may be created during"]
#[doc = " pre-commit navigation for sub-frames that do not yet exist in the renderer"]
#[doc = " process. Placeholders will have cef_frame_t::get_identifier() == -4."]
#[doc = ""]
#[doc = " The functions of this structure will be called on the UI thread unless"]
#[doc = " otherwise indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_frame_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when a new frame is created. This will be the first notification"]
    #[doc = " that references |frame|. Any commands that require transport to the"]
    #[doc = " associated renderer process (LoadRequest, SendProcessMessage, GetSource,"]
    #[doc = " etc.) will be queued until OnFrameAttached is called for |frame|."]
    #[doc = ""]
    pub on_frame_created: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when a frame can begin routing commands to/from the associated"]
    #[doc = " renderer process. |reattached| will be true (1) if the frame was re-"]
    #[doc = " attached after exiting the BackForwardCache. Any commands that were queued"]
    #[doc = " have now been dispatched."]
    #[doc = ""]
    pub on_frame_attached: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            reattached: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when a frame loses its connection to the renderer process and will"]
    #[doc = " be destroyed. Any pending or future commands will be discarded and"]
    #[doc = " cef_frame_t::is_valid() will now return false (0) for |frame|. If called"]
    #[doc = " after cef_life_span_handler_t::on_before_close() during browser"]
    #[doc = " destruction then cef_browser_t::is_valid() will return false (0) for"]
    #[doc = " |browser|."]
    #[doc = ""]
    pub on_frame_detached: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the main frame changes due to (a) initial browser creation,"]
    #[doc = " (b) final browser destruction, (c) cross-origin navigation or (d) re-"]
    #[doc = " navigation after renderer process termination (due to crashes, etc)."]
    #[doc = " |old_frame| will be NULL and |new_frame| will be non-NULL when a main"]
    #[doc = " frame is assigned to |browser| for the first time. |old_frame| will be"]
    #[doc = " non-NULL and |new_frame| will be NULL and  when a main frame is removed"]
    #[doc = " from |browser| for the last time. Both |old_frame| and |new_frame| will be"]
    #[doc = " non-NULL for cross-origin navigations or re-navigation after renderer"]
    #[doc = " process termination. This function will be called after on_frame_created()"]
    #[doc = " for |new_frame| and/or after on_frame_detached() for |old_frame|. If"]
    #[doc = " called after cef_life_span_handler_t::on_before_close() during browser"]
    #[doc = " destruction then cef_browser_t::is_valid() will return false (0) for"]
    #[doc = " |browser|."]
    #[doc = ""]
    pub on_main_frame_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_frame_handler_t,
            browser: *mut _cef_browser_t,
            old_frame: *mut _cef_frame_t,
            new_frame: *mut _cef_frame_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_frame_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_frame_handler_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_frame_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_frame_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_frame_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_frame_created() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_frame_created) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_handler_t),
                "::",
                stringify!(on_frame_created)
            )
        );
    }
    test_field_on_frame_created();
    fn test_field_on_frame_attached() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_frame_attached) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_handler_t),
                "::",
                stringify!(on_frame_attached)
            )
        );
    }
    test_field_on_frame_attached();
    fn test_field_on_frame_detached() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_frame_detached) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_handler_t),
                "::",
                stringify!(on_frame_detached)
            )
        );
    }
    test_field_on_frame_detached();
    fn test_field_on_main_frame_changed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_frame_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_main_frame_changed) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_frame_handler_t),
                "::",
                stringify!(on_main_frame_changed)
            )
        );
    }
    test_field_on_main_frame_changed();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to cef_frame_t life span."]
#[doc = " The order of callbacks is:"]
#[doc = ""]
#[doc = " (1) During initial cef_browser_host_t creation and navigation of the main"]
#[doc = " frame: - cef_frame_handler_t::OnFrameCreated => The initial main frame"]
#[doc = " object has been"]
#[doc = "   created. Any commands will be queued until the frame is attached."]
#[doc = " - cef_frame_handler_t::OnMainFrameChanged => The initial main frame object"]
#[doc = " has"]
#[doc = "   been assigned to the browser."]
#[doc = " - cef_life_span_handler_t::OnAfterCreated => The browser is now valid and"]
#[doc = " can be"]
#[doc = "   used."]
#[doc = " - cef_frame_handler_t::OnFrameAttached => The initial main frame object is"]
#[doc = " now"]
#[doc = "   connected to its peer in the renderer process. Commands can be routed."]
#[doc = ""]
#[doc = " (2) During further cef_browser_host_t navigation/loading of the main frame"]
#[doc = "     and/or sub-frames:"]
#[doc = " - cef_frame_handler_t::OnFrameCreated => A new main frame or sub-frame"]
#[doc = " object"]
#[doc = "   has been created. Any commands will be queued until the frame is attached."]
#[doc = " - cef_frame_handler_t::OnFrameAttached => A new main frame or sub-frame"]
#[doc = " object"]
#[doc = "   is now connected to its peer in the renderer process. Commands can be"]
#[doc = "   routed."]
#[doc = " - cef_frame_handler_t::OnFrameDetached => An existing main frame or sub-"]
#[doc = " frame"]
#[doc = "   object has lost its connection to the renderer process. If multiple"]
#[doc = "   objects are detached at the same time then notifications will be sent for"]
#[doc = "   any sub-frame objects before the main frame object. Commands can no longer"]
#[doc = "   be routed and will be discarded."]
#[doc = " - cef_frame_handler_t::OnMainFrameChanged => A new main frame object has"]
#[doc = " been"]
#[doc = "   assigned to the browser. This will only occur with cross-origin navigation"]
#[doc = "   or re-navigation after renderer process termination (due to crashes, etc)."]
#[doc = ""]
#[doc = " (3) During final cef_browser_host_t destruction of the main frame: -"]
#[doc = " cef_frame_handler_t::OnFrameDetached => Any sub-frame objects have lost"]
#[doc = " their"]
#[doc = "   connection to the renderer process. Commands can no longer be routed and"]
#[doc = "   will be discarded."]
#[doc = " - cef_life_span_handler_t::OnBeforeClose => The browser has been destroyed."]
#[doc = " - cef_frame_handler_t::OnFrameDetached => The main frame object have lost"]
#[doc = " its"]
#[doc = "   connection to the renderer process. Notifications will be sent for any"]
#[doc = "   sub-frame objects before the main frame object. Commands can no longer be"]
#[doc = "   routed and will be discarded."]
#[doc = " - cef_frame_handler_t::OnMainFrameChanged => The final main frame object has"]
#[doc = "   been removed from the browser."]
#[doc = ""]
#[doc = " Cross-origin navigation and/or loading receives special handling."]
#[doc = ""]
#[doc = " When the main frame navigates to a different origin the OnMainFrameChanged"]
#[doc = " callback (2) will be executed with the old and new main frame objects."]
#[doc = ""]
#[doc = " When a new sub-frame is loaded in, or an existing sub-frame is navigated to,"]
#[doc = " a different origin from the parent frame, a temporary sub-frame object will"]
#[doc = " first be created in the parent's renderer process. That temporary sub-frame"]
#[doc = " will then be discarded after the real cross-origin sub-frame is created in"]
#[doc = " the new/target renderer process. The client will receive cross-origin"]
#[doc = " navigation callbacks (2) for the transition from the temporary sub-frame to"]
#[doc = " the real sub-frame. The temporary sub-frame will not recieve or execute"]
#[doc = " commands during this transitional period (any sent commands will be"]
#[doc = " discarded)."]
#[doc = ""]
#[doc = " When a new popup browser is created in a different origin from the parent"]
#[doc = " browser, a temporary main frame object for the popup will first be created"]
#[doc = " in the parent's renderer process. That temporary main frame will then be"]
#[doc = " discarded after the real cross-origin main frame is created in the"]
#[doc = " new/target renderer process. The client will recieve creation and initial"]
#[doc = " navigation callbacks (1) for the temporary main frame, followed by cross-"]
#[doc = " origin navigation callbacks (2) for the transition from the temporary main"]
#[doc = " frame to the real main frame. The temporary main frame may receive and"]
#[doc = " execute commands during this transitional period (any sent commands may be"]
#[doc = " executed, but the behavior is potentially undesirable since they execute in"]
#[doc = " the parent browser's renderer process and not the new/target renderer"]
#[doc = " process)."]
#[doc = ""]
#[doc = " Callbacks will not be executed for placeholders that may be created during"]
#[doc = " pre-commit navigation for sub-frames that do not yet exist in the renderer"]
#[doc = " process. Placeholders will have cef_frame_t::get_identifier() == -4."]
#[doc = ""]
#[doc = " The functions of this structure will be called on the UI thread unless"]
#[doc = " otherwise indicated."]
#[doc = ""]
pub type cef_frame_handler_t = _cef_frame_handler_t;
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of JavaScript dialog"]
#[doc = " requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_jsdialog_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue the JS dialog request. Set |success| to true (1) if the OK button"]
    #[doc = " was pressed. The |user_input| value should be specified for prompt"]
    #[doc = " dialogs."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_jsdialog_callback_t,
            success: ::std::os::raw::c_int,
            user_input: *const cef_string_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_jsdialog_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_jsdialog_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_jsdialog_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_jsdialog_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_jsdialog_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_jsdialog_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_jsdialog_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_jsdialog_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_jsdialog_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
}
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of JavaScript dialog"]
#[doc = " requests."]
#[doc = ""]
pub type cef_jsdialog_callback_t = _cef_jsdialog_callback_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to JavaScript dialogs. The"]
#[doc = " functions of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_jsdialog_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called to run a JavaScript dialog. If |origin_url| is non-NULL it can be"]
    #[doc = " passed to the CefFormatUrlForSecurityDisplay function to retrieve a secure"]
    #[doc = " and user-friendly display string. The |default_prompt_text| value will be"]
    #[doc = " specified for prompt dialogs only. Set |suppress_message| to true (1) and"]
    #[doc = " return false (0) to suppress the message (suppressing messages is"]
    #[doc = " preferable to immediately executing the callback as this is used to detect"]
    #[doc = " presumably malicious behavior like spamming alert messages in"]
    #[doc = " onbeforeunload). Set |suppress_message| to false (0) and return false (0)"]
    #[doc = " to use the default implementation (the default implementation will show"]
    #[doc = " one modal dialog at a time and suppress any additional dialog requests"]
    #[doc = " until the displayed dialog is dismissed). Return true (1) if the"]
    #[doc = " application will use a custom dialog or if the callback has been executed"]
    #[doc = " immediately. Custom dialogs may be either modal or modeless. If a custom"]
    #[doc = " dialog is used the application must execute |callback| once the custom"]
    #[doc = " dialog is dismissed."]
    #[doc = ""]
    pub on_jsdialog: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_jsdialog_handler_t,
            browser: *mut _cef_browser_t,
            origin_url: *const cef_string_t,
            dialog_type: cef_jsdialog_type_t,
            message_text: *const cef_string_t,
            default_prompt_text: *const cef_string_t,
            callback: *mut _cef_jsdialog_callback_t,
            suppress_message: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to run a dialog asking the user if they want to leave a page."]
    #[doc = " Return false (0) to use the default dialog implementation. Return true (1)"]
    #[doc = " if the application will use a custom dialog or if the callback has been"]
    #[doc = " executed immediately. Custom dialogs may be either modal or modeless. If a"]
    #[doc = " custom dialog is used the application must execute |callback| once the"]
    #[doc = " custom dialog is dismissed."]
    #[doc = ""]
    pub on_before_unload_dialog: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_jsdialog_handler_t,
            browser: *mut _cef_browser_t,
            message_text: *const cef_string_t,
            is_reload: ::std::os::raw::c_int,
            callback: *mut _cef_jsdialog_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to cancel any pending dialogs and reset any saved dialog state."]
    #[doc = " Will be called due to events like page navigation irregardless of whether"]
    #[doc = " any dialogs are currently pending."]
    #[doc = ""]
    pub on_reset_dialog_state: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_jsdialog_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = ""]
    #[doc = " Called when the dialog is closed."]
    #[doc = ""]
    pub on_dialog_closed: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_jsdialog_handler_t, browser: *mut _cef_browser_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_jsdialog_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_jsdialog_handler_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_jsdialog_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_jsdialog_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_jsdialog_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_jsdialog_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_jsdialog_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_jsdialog() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_jsdialog_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_jsdialog) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_jsdialog_handler_t),
                "::",
                stringify!(on_jsdialog)
            )
        );
    }
    test_field_on_jsdialog();
    fn test_field_on_before_unload_dialog() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_jsdialog_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_before_unload_dialog) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_jsdialog_handler_t),
                "::",
                stringify!(on_before_unload_dialog)
            )
        );
    }
    test_field_on_before_unload_dialog();
    fn test_field_on_reset_dialog_state() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_jsdialog_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_reset_dialog_state) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_jsdialog_handler_t),
                "::",
                stringify!(on_reset_dialog_state)
            )
        );
    }
    test_field_on_reset_dialog_state();
    fn test_field_on_dialog_closed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_jsdialog_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_dialog_closed) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_jsdialog_handler_t),
                "::",
                stringify!(on_dialog_closed)
            )
        );
    }
    test_field_on_dialog_closed();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to JavaScript dialogs. The"]
#[doc = " functions of this structure will be called on the UI thread."]
#[doc = ""]
pub type cef_jsdialog_handler_t = _cef_jsdialog_handler_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to keyboard input. The"]
#[doc = " functions of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_keyboard_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called before a keyboard event is sent to the renderer. |event| contains"]
    #[doc = " information about the keyboard event. |os_event| is the operating system"]
    #[doc = " event message, if any. Return true (1) if the event was handled or false"]
    #[doc = " (0) otherwise. If the event will be handled in on_key_event() as a"]
    #[doc = " keyboard shortcut set |is_keyboard_shortcut| to true (1) and return false"]
    #[doc = " (0)."]
    #[doc = ""]
    pub on_pre_key_event: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_keyboard_handler_t,
            browser: *mut _cef_browser_t,
            event: *const cef_key_event_t,
            os_event: *mut XEvent,
            is_keyboard_shortcut: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called after the renderer and JavaScript in the page has had a chance to"]
    #[doc = " handle the event. |event| contains information about the keyboard event."]
    #[doc = " |os_event| is the operating system event message, if any. Return true (1)"]
    #[doc = " if the keyboard event was handled or false (0) otherwise."]
    #[doc = ""]
    pub on_key_event: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_keyboard_handler_t,
            browser: *mut _cef_browser_t,
            event: *const cef_key_event_t,
            os_event: *mut XEvent,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_keyboard_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_keyboard_handler_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_keyboard_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_keyboard_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_keyboard_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_keyboard_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_keyboard_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_pre_key_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_keyboard_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_pre_key_event) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_keyboard_handler_t),
                "::",
                stringify!(on_pre_key_event)
            )
        );
    }
    test_field_on_pre_key_event();
    fn test_field_on_key_event() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_keyboard_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_key_event) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_keyboard_handler_t),
                "::",
                stringify!(on_key_event)
            )
        );
    }
    test_field_on_key_event();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to keyboard input. The"]
#[doc = " functions of this structure will be called on the UI thread."]
#[doc = ""]
pub type cef_keyboard_handler_t = _cef_keyboard_handler_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser life span. The"]
#[doc = " functions of this structure will be called on the UI thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _cef_life_span_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called on the UI thread before a new popup browser is created. The"]
    #[doc = " |browser| and |frame| values represent the source of the popup request."]
    #[doc = " The |target_url| and |target_frame_name| values indicate where the popup"]
    #[doc = " browser should navigate and may be NULL if not specified with the request."]
    #[doc = " The |target_disposition| value indicates where the user intended to open"]
    #[doc = " the popup (e.g. current tab, new tab, etc). The |user_gesture| value will"]
    #[doc = " be true (1) if the popup was opened via explicit user gesture (e.g."]
    #[doc = " clicking a link) or false (0) if the popup opened automatically (e.g. via"]
    #[doc = " the DomContentLoaded event). The |popupFeatures| structure contains"]
    #[doc = " additional information about the requested popup window. To allow creation"]
    #[doc = " of the popup browser optionally modify |windowInfo|, |client|, |settings|"]
    #[doc = " and |no_javascript_access| and return false (0). To cancel creation of the"]
    #[doc = " popup browser return true (1). The |client| and |settings| values will"]
    #[doc = " default to the source browser's values. If the |no_javascript_access|"]
    #[doc = " value is set to false (0) the new browser will not be scriptable and may"]
    #[doc = " not be hosted in the same renderer process as the source browser. Any"]
    #[doc = " modifications to |windowInfo| will be ignored if the parent browser is"]
    #[doc = " wrapped in a cef_browser_view_t. Popup browser creation will be canceled"]
    #[doc = " if the parent browser is destroyed before the popup browser creation"]
    #[doc = " completes (indicated by a call to OnAfterCreated for the popup browser)."]
    #[doc = " The |extra_info| parameter provides an opportunity to specify extra"]
    #[doc = " information specific to the created popup browser that will be passed to"]
    #[doc = " cef_render_process_handler_t::on_browser_created() in the render process."]
    #[doc = ""]
    pub on_before_popup: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_life_span_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            target_url: *const cef_string_t,
            target_frame_name: *const cef_string_t,
            target_disposition: cef_window_open_disposition_t,
            user_gesture: ::std::os::raw::c_int,
            popupFeatures: *const cef_popup_features_t,
            windowInfo: *mut _cef_window_info_t,
            client: *mut *mut _cef_client_t,
            settings: *mut _cef_browser_settings_t,
            extra_info: *mut *mut _cef_dictionary_value_t,
            no_javascript_access: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called after a new browser is created. It is now safe to begin performing"]
    #[doc = " actions with |browser|. cef_frame_handler_t callbacks related to initial"]
    #[doc = " main frame creation will arrive before this callback. See"]
    #[doc = " cef_frame_handler_t documentation for additional usage information."]
    #[doc = ""]
    pub on_after_created: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_life_span_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = ""]
    #[doc = " Called when a browser has recieved a request to close. This may result"]
    #[doc = " directly from a call to cef_browser_host_t::*close_browser() or indirectly"]
    #[doc = " if the browser is parented to a top-level window created by CEF and the"]
    #[doc = " user attempts to close that window (by clicking the 'X', for example). The"]
    #[doc = " do_close() function will be called after the JavaScript 'onunload' event"]
    #[doc = " has been fired."]
    #[doc = ""]
    #[doc = " An application should handle top-level owner window close notifications by"]
    #[doc = " calling cef_browser_host_t::try_close_browser() or"]
    #[doc = " cef_browser_host_t::CloseBrowser(false (0)) instead of allowing the window"]
    #[doc = " to close immediately (see the examples below). This gives CEF an"]
    #[doc = " opportunity to process the 'onbeforeunload' event and optionally cancel"]
    #[doc = " the close before do_close() is called."]
    #[doc = ""]
    #[doc = " When windowed rendering is enabled CEF will internally create a window or"]
    #[doc = " view to host the browser. In that case returning false (0) from do_close()"]
    #[doc = " will send the standard close notification to the browser's top-level owner"]
    #[doc = " window (e.g. WM_CLOSE on Windows, performClose: on OS X, \"delete_event\" on"]
    #[doc = " Linux or cef_window_delegate_t::can_close() callback from Views). If the"]
    #[doc = " browser's host window/view has already been destroyed (via view hierarchy"]
    #[doc = " tear-down, for example) then do_close() will not be called for that"]
    #[doc = " browser since is no longer possible to cancel the close."]
    #[doc = ""]
    #[doc = " When windowed rendering is disabled returning false (0) from do_close()"]
    #[doc = " will cause the browser object to be destroyed immediately."]
    #[doc = ""]
    #[doc = " If the browser's top-level owner window requires a non-standard close"]
    #[doc = " notification then send that notification from do_close() and return true"]
    #[doc = " (1)."]
    #[doc = ""]
    #[doc = " The cef_life_span_handler_t::on_before_close() function will be called"]
    #[doc = " after do_close() (if do_close() is called) and immediately before the"]
    #[doc = " browser object is destroyed. The application should only exit after"]
    #[doc = " on_before_close() has been called for all existing browsers."]
    #[doc = ""]
    #[doc = " The below examples describe what should happen during window close when"]
    #[doc = " the browser is parented to an application-provided top-level window."]
    #[doc = ""]
    #[doc = " Example 1: Using cef_browser_host_t::try_close_browser(). This is"]
    #[doc = " recommended for clients using standard close handling and windows created"]
    #[doc = " on the browser process UI thread. 1.  User clicks the window close button"]
    #[doc = " which sends a close notification"]
    #[doc = "     to the application's top-level window."]
    #[doc = " 2.  Application's top-level window receives the close notification and"]
    #[doc = "     calls TryCloseBrowser() (which internally calls CloseBrowser(false))."]
    #[doc = "     TryCloseBrowser() returns false so the client cancels the window"]
    #[doc = "     close."]
    #[doc = " 3.  JavaScript 'onbeforeunload' handler executes and shows the close"]
    #[doc = "     confirmation dialog (which can be overridden via"]
    #[doc = "     CefJSDialogHandler::OnBeforeUnloadDialog())."]
    #[doc = " 4.  User approves the close. 5.  JavaScript 'onunload' handler executes."]
    #[doc = " 6.  CEF sends a close notification to the application's top-level window"]
    #[doc = "     (because DoClose() returned false by default)."]
    #[doc = " 7.  Application's top-level window receives the close notification and"]
    #[doc = "     calls TryCloseBrowser(). TryCloseBrowser() returns true so the client"]
    #[doc = "     allows the window close."]
    #[doc = " 8.  Application's top-level window is destroyed. 9.  Application's"]
    #[doc = " on_before_close() handler is called and the browser object"]
    #[doc = "     is destroyed."]
    #[doc = " 10. Application exits by calling cef_quit_message_loop() if no other"]
    #[doc = " browsers"]
    #[doc = "     exist."]
    #[doc = ""]
    #[doc = " Example 2: Using cef_browser_host_t::CloseBrowser(false (0)) and"]
    #[doc = " implementing the do_close() callback. This is recommended for clients"]
    #[doc = " using non-standard close handling or windows that were not created on the"]
    #[doc = " browser process UI thread. 1.  User clicks the window close button which"]
    #[doc = " sends a close notification"]
    #[doc = "     to the application's top-level window."]
    #[doc = " 2.  Application's top-level window receives the close notification and:"]
    #[doc = "     A. Calls CefBrowserHost::CloseBrowser(false)."]
    #[doc = "     B. Cancels the window close."]
    #[doc = " 3.  JavaScript 'onbeforeunload' handler executes and shows the close"]
    #[doc = "     confirmation dialog (which can be overridden via"]
    #[doc = "     CefJSDialogHandler::OnBeforeUnloadDialog())."]
    #[doc = " 4.  User approves the close. 5.  JavaScript 'onunload' handler executes."]
    #[doc = " 6.  Application's do_close() handler is called. Application will:"]
    #[doc = "     A. Set a flag to indicate that the next close attempt will be allowed."]
    #[doc = "     B. Return false."]
    #[doc = " 7.  CEF sends an close notification to the application's top-level window."]
    #[doc = " 8.  Application's top-level window receives the close notification and"]
    #[doc = "     allows the window to close based on the flag from #6B."]
    #[doc = " 9.  Application's top-level window is destroyed. 10. Application's"]
    #[doc = " on_before_close() handler is called and the browser object"]
    #[doc = "     is destroyed."]
    #[doc = " 11. Application exits by calling cef_quit_message_loop() if no other"]
    #[doc = " browsers"]
    #[doc = "     exist."]
    #[doc = ""]
    pub do_close: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_life_span_handler_t,
            browser: *mut _cef_browser_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called just before a browser is destroyed. Release all references to the"]
    #[doc = " browser object and do not attempt to execute any functions on the browser"]
    #[doc = " object (other than IsValid, GetIdentifier or IsSame) after this callback"]
    #[doc = " returns. cef_frame_handler_t callbacks related to final main frame"]
    #[doc = " destruction will arrive after this callback and cef_browser_t::IsValid"]
    #[doc = " will return false (0) at that time. Any in-progress network requests"]
    #[doc = " associated with |browser| will be aborted when the browser is destroyed,"]
    #[doc = " and cef_resource_request_handler_t callbacks related to those requests may"]
    #[doc = " still arrive on the IO thread after this callback. See cef_frame_handler_t"]
    #[doc = " and do_close() documentation for additional usage information."]
    #[doc = ""]
    pub on_before_close: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_life_span_handler_t, browser: *mut _cef_browser_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_life_span_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_life_span_handler_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_life_span_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_life_span_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_life_span_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_life_span_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_life_span_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_before_popup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_life_span_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_before_popup) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_life_span_handler_t),
                "::",
                stringify!(on_before_popup)
            )
        );
    }
    test_field_on_before_popup();
    fn test_field_on_after_created() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_life_span_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_after_created) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_life_span_handler_t),
                "::",
                stringify!(on_after_created)
            )
        );
    }
    test_field_on_after_created();
    fn test_field_do_close() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_life_span_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).do_close) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_life_span_handler_t),
                "::",
                stringify!(do_close)
            )
        );
    }
    test_field_do_close();
    fn test_field_on_before_close() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_life_span_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_before_close) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_life_span_handler_t),
                "::",
                stringify!(on_before_close)
            )
        );
    }
    test_field_on_before_close();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser life span. The"]
#[doc = " functions of this structure will be called on the UI thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
pub type cef_life_span_handler_t = _cef_life_span_handler_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser load status."]
#[doc = " The functions of this structure will be called on the browser process UI"]
#[doc = " thread or render process main thread (TID_RENDERER)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_load_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when the loading state has changed. This callback will be executed"]
    #[doc = " twice -- once when loading is initiated either programmatically or by user"]
    #[doc = " action, and once when loading is terminated due to completion,"]
    #[doc = " cancellation of failure. It will be called before any calls to OnLoadStart"]
    #[doc = " and after all calls to OnLoadError and/or OnLoadEnd."]
    #[doc = ""]
    pub on_loading_state_change: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            isLoading: ::std::os::raw::c_int,
            canGoBack: ::std::os::raw::c_int,
            canGoForward: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called after a navigation has been committed and before the browser begins"]
    #[doc = " loading contents in the frame. The |frame| value will never be NULL --"]
    #[doc = " call the is_main() function to check if this frame is the main frame."]
    #[doc = " |transition_type| provides information about the source of the navigation"]
    #[doc = " and an accurate value is only available in the browser process. Multiple"]
    #[doc = " frames may be loading at the same time. Sub-frames may start or continue"]
    #[doc = " loading after the main frame load has ended. This function will not be"]
    #[doc = " called for same page navigations (fragments, history state, etc.) or for"]
    #[doc = " navigations that fail or are canceled before commit. For notification of"]
    #[doc = " overall browser load status use OnLoadingStateChange instead."]
    #[doc = ""]
    pub on_load_start: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            transition_type: cef_transition_type_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the browser is done loading a frame. The |frame| value will"]
    #[doc = " never be NULL -- call the is_main() function to check if this frame is the"]
    #[doc = " main frame. Multiple frames may be loading at the same time. Sub-frames"]
    #[doc = " may start or continue loading after the main frame load has ended. This"]
    #[doc = " function will not be called for same page navigations (fragments, history"]
    #[doc = " state, etc.) or for navigations that fail or are canceled before commit."]
    #[doc = " For notification of overall browser load status use OnLoadingStateChange"]
    #[doc = " instead."]
    #[doc = ""]
    pub on_load_end: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            httpStatusCode: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when a navigation fails or is canceled. This function may be called"]
    #[doc = " by itself if before commit or in combination with OnLoadStart/OnLoadEnd if"]
    #[doc = " after commit. |errorCode| is the error code number, |errorText| is the"]
    #[doc = " error text and |failedUrl| is the URL that failed to load. See"]
    #[doc = " net\\base\\net_error_list.h for complete descriptions of the error codes."]
    #[doc = ""]
    pub on_load_error: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_load_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            errorCode: cef_errorcode_t,
            errorText: *const cef_string_t,
            failedUrl: *const cef_string_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_load_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_load_handler_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_load_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_load_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_load_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_load_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_load_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_loading_state_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_load_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_loading_state_change) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_load_handler_t),
                "::",
                stringify!(on_loading_state_change)
            )
        );
    }
    test_field_on_loading_state_change();
    fn test_field_on_load_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_load_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_load_start) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_load_handler_t),
                "::",
                stringify!(on_load_start)
            )
        );
    }
    test_field_on_load_start();
    fn test_field_on_load_end() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_load_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_load_end) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_load_handler_t),
                "::",
                stringify!(on_load_end)
            )
        );
    }
    test_field_on_load_end();
    fn test_field_on_load_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_load_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_load_error) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_load_handler_t),
                "::",
                stringify!(on_load_error)
            )
        );
    }
    test_field_on_load_error();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser load status."]
#[doc = " The functions of this structure will be called on the browser process UI"]
#[doc = " thread or render process main thread (TID_RENDERER)."]
#[doc = ""]
pub type cef_load_handler_t = _cef_load_handler_t;
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of media access"]
#[doc = " permission requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_media_access_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Call to allow or deny media access. If this callback was initiated in"]
    #[doc = " response to a getUserMedia (indicated by"]
    #[doc = " CEF_MEDIA_PERMISSION_DEVICE_AUDIO_CAPTURE and/or"]
    #[doc = " CEF_MEDIA_PERMISSION_DEVICE_VIDEO_CAPTURE being set) then"]
    #[doc = " |allowed_permissions| must match |required_permissions| passed to"]
    #[doc = " OnRequestMediaAccessPermission."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_media_access_callback_t, allowed_permissions: uint32),
    >,
    #[doc = ""]
    #[doc = " Cancel the media access request."]
    #[doc = ""]
    pub cancel:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_media_access_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_media_access_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_media_access_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_media_access_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_media_access_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_media_access_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_access_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_access_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_access_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_access_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
    fn test_field_cancel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_media_access_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_media_access_callback_t),
                "::",
                stringify!(cancel)
            )
        );
    }
    test_field_cancel();
}
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of media access"]
#[doc = " permission requests."]
#[doc = ""]
pub type cef_media_access_callback_t = _cef_media_access_callback_t;
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of permission prompts."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_permission_prompt_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Complete the permissions request with the specified |result|."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_permission_prompt_callback_t,
            result: cef_permission_request_result_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_permission_prompt_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_permission_prompt_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_permission_prompt_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_permission_prompt_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_permission_prompt_callback_t)
        )
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_permission_prompt_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_permission_prompt_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_permission_prompt_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_permission_prompt_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
}
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of permission prompts."]
#[doc = ""]
pub type cef_permission_prompt_callback_t = _cef_permission_prompt_callback_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to permission requests."]
#[doc = " The functions of this structure will be called on the browser process UI"]
#[doc = " thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_permission_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when a page requests permission to access media."]
    #[doc = " |requesting_origin| is the URL origin requesting permission."]
    #[doc = " |requested_permissions| is a combination of values from"]
    #[doc = " cef_media_access_permission_types_t that represent the requested"]
    #[doc = " permissions. Return true (1) and call cef_media_access_callback_t"]
    #[doc = " functions either in this function or at a later time to continue or cancel"]
    #[doc = " the request. Return false (0) to proceed with default handling. With the"]
    #[doc = " Chrome runtime, default handling will display the permission request UI."]
    #[doc = " With the Alloy runtime, default handling will deny the request. This"]
    #[doc = " function will not be called if the \"--enable-media-stream\" command-line"]
    #[doc = " switch is used to grant all permissions."]
    #[doc = ""]
    pub on_request_media_access_permission: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_permission_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            requesting_origin: *const cef_string_t,
            requested_permissions: uint32,
            callback: *mut _cef_media_access_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when a page should show a permission prompt. |prompt_id| uniquely"]
    #[doc = " identifies the prompt. |requesting_origin| is the URL origin requesting"]
    #[doc = " permission. |requested_permissions| is a combination of values from"]
    #[doc = " cef_permission_request_types_t that represent the requested permissions."]
    #[doc = " Return true (1) and call cef_permission_prompt_callback_t::Continue either"]
    #[doc = " in this function or at a later time to continue or cancel the request."]
    #[doc = " Return false (0) to proceed with default handling. With the Chrome"]
    #[doc = " runtime, default handling will display the permission prompt UI. With the"]
    #[doc = " Alloy runtime, default handling is CEF_PERMISSION_RESULT_IGNORE."]
    #[doc = ""]
    pub on_show_permission_prompt: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_permission_handler_t,
            browser: *mut _cef_browser_t,
            prompt_id: uint64,
            requesting_origin: *const cef_string_t,
            requested_permissions: uint32,
            callback: *mut _cef_permission_prompt_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when a permission prompt handled via OnShowPermissionPrompt is"]
    #[doc = " dismissed. |prompt_id| will match the value that was passed to"]
    #[doc = " OnShowPermissionPrompt. |result| will be the value passed to"]
    #[doc = " cef_permission_prompt_callback_t::Continue or CEF_PERMISSION_RESULT_IGNORE"]
    #[doc = " if the dialog was dismissed for other reasons such as navigation, browser"]
    #[doc = " closure, etc. This function will not be called if OnShowPermissionPrompt"]
    #[doc = " returned false (0) for |prompt_id|."]
    #[doc = ""]
    pub on_dismiss_permission_prompt: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_permission_handler_t,
            browser: *mut _cef_browser_t,
            prompt_id: uint64,
            result: cef_permission_request_result_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_permission_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_permission_handler_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_permission_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_permission_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_permission_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_permission_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_permission_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_request_media_access_permission() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_permission_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_request_media_access_permission) as usize
                    - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_permission_handler_t),
                "::",
                stringify!(on_request_media_access_permission)
            )
        );
    }
    test_field_on_request_media_access_permission();
    fn test_field_on_show_permission_prompt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_permission_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_show_permission_prompt) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_permission_handler_t),
                "::",
                stringify!(on_show_permission_prompt)
            )
        );
    }
    test_field_on_show_permission_prompt();
    fn test_field_on_dismiss_permission_prompt() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_permission_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_dismiss_permission_prompt) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_permission_handler_t),
                "::",
                stringify!(on_dismiss_permission_prompt)
            )
        );
    }
    test_field_on_dismiss_permission_prompt();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to permission requests."]
#[doc = " The functions of this structure will be called on the browser process UI"]
#[doc = " thread."]
#[doc = ""]
pub type cef_permission_handler_t = _cef_permission_handler_t;
#[doc = ""]
#[doc = " Structure representing print settings."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_settings_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. Do not call any other functions"]
    #[doc = " if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the values of this object are read-only. Some APIs may"]
    #[doc = " expose read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the page orientation."]
    #[doc = ""]
    pub set_orientation: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, landscape: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the orientation is landscape."]
    #[doc = ""]
    pub is_landscape: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the printer printable area in device units. Some platforms already"]
    #[doc = " provide flipped area. Set |landscape_needs_flip| to false (0) on those"]
    #[doc = " platforms to avoid double flipping."]
    #[doc = ""]
    pub set_printer_printable_area: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_settings_t,
            physical_size_device_units: *const cef_size_t,
            printable_area_device_units: *const cef_rect_t,
            landscape_needs_flip: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Set the device name."]
    #[doc = ""]
    pub set_device_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, name: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Get the device name."]
    #[doc = ""]
    pub get_device_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the DPI (dots per inch)."]
    #[doc = ""]
    pub set_dpi: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, dpi: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Get the DPI (dots per inch)."]
    #[doc = ""]
    pub get_dpi: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the page ranges."]
    #[doc = ""]
    pub set_page_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_settings_t,
            rangesCount: size_t,
            ranges: *const cef_range_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns the number of page ranges that currently exist."]
    #[doc = ""]
    pub get_page_ranges_count:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> size_t>,
    #[doc = ""]
    #[doc = " Retrieve the page ranges."]
    #[doc = ""]
    pub get_page_ranges: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_settings_t,
            rangesCount: *mut size_t,
            ranges: *mut cef_range_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Set whether only the selection will be printed."]
    #[doc = ""]
    pub set_selection_only: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_settings_t,
            selection_only: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if only the selection will be printed."]
    #[doc = ""]
    pub is_selection_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set whether pages will be collated."]
    #[doc = ""]
    pub set_collate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, collate: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if pages will be collated."]
    #[doc = ""]
    pub will_collate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the color model."]
    #[doc = ""]
    pub set_color_model: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, model: cef_color_model_t),
    >,
    #[doc = ""]
    #[doc = " Get the color model."]
    #[doc = ""]
    pub get_color_model: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> cef_color_model_t,
    >,
    #[doc = ""]
    #[doc = " Set the number of copies."]
    #[doc = ""]
    pub set_copies: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, copies: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Get the number of copies."]
    #[doc = ""]
    pub get_copies: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the duplex mode."]
    #[doc = ""]
    pub set_duplex_mode: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t, mode: cef_duplex_mode_t),
    >,
    #[doc = ""]
    #[doc = " Get the duplex mode."]
    #[doc = ""]
    pub get_duplex_mode: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_settings_t) -> cef_duplex_mode_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_print_settings_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_print_settings_t>(),
        216usize,
        concat!("Size of: ", stringify!(_cef_print_settings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_print_settings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_print_settings_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_is_read_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(is_read_only)
            )
        );
    }
    test_field_is_read_only();
    fn test_field_set_orientation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_orientation) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(set_orientation)
            )
        );
    }
    test_field_set_orientation();
    fn test_field_is_landscape() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_landscape) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(is_landscape)
            )
        );
    }
    test_field_is_landscape();
    fn test_field_set_printer_printable_area() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_printer_printable_area) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(set_printer_printable_area)
            )
        );
    }
    test_field_set_printer_printable_area();
    fn test_field_set_device_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_device_name) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(set_device_name)
            )
        );
    }
    test_field_set_device_name();
    fn test_field_get_device_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_device_name) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(get_device_name)
            )
        );
    }
    test_field_get_device_name();
    fn test_field_set_dpi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_dpi) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(set_dpi)
            )
        );
    }
    test_field_set_dpi();
    fn test_field_get_dpi() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_dpi) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(get_dpi)
            )
        );
    }
    test_field_get_dpi();
    fn test_field_set_page_ranges() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_page_ranges) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(set_page_ranges)
            )
        );
    }
    test_field_set_page_ranges();
    fn test_field_get_page_ranges_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_page_ranges_count) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(get_page_ranges_count)
            )
        );
    }
    test_field_get_page_ranges_count();
    fn test_field_get_page_ranges() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_page_ranges) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(get_page_ranges)
            )
        );
    }
    test_field_get_page_ranges();
    fn test_field_set_selection_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_selection_only) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(set_selection_only)
            )
        );
    }
    test_field_set_selection_only();
    fn test_field_is_selection_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_selection_only) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(is_selection_only)
            )
        );
    }
    test_field_is_selection_only();
    fn test_field_set_collate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_collate) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(set_collate)
            )
        );
    }
    test_field_set_collate();
    fn test_field_will_collate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).will_collate) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(will_collate)
            )
        );
    }
    test_field_will_collate();
    fn test_field_set_color_model() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_color_model) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(set_color_model)
            )
        );
    }
    test_field_set_color_model();
    fn test_field_get_color_model() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_color_model) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(get_color_model)
            )
        );
    }
    test_field_get_color_model();
    fn test_field_set_copies() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_copies) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(set_copies)
            )
        );
    }
    test_field_set_copies();
    fn test_field_get_copies() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_copies) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(get_copies)
            )
        );
    }
    test_field_get_copies();
    fn test_field_set_duplex_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_duplex_mode) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(set_duplex_mode)
            )
        );
    }
    test_field_set_duplex_mode();
    fn test_field_get_duplex_mode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_settings_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_duplex_mode) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_settings_t),
                "::",
                stringify!(get_duplex_mode)
            )
        );
    }
    test_field_get_duplex_mode();
}
#[doc = ""]
#[doc = " Structure representing print settings."]
#[doc = ""]
pub type cef_print_settings_t = _cef_print_settings_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_print_settings_t object."]
    #[doc = ""]
    pub fn cef_print_settings_create() -> *mut cef_print_settings_t;
}
#[doc = ""]
#[doc = " Callback structure for asynchronous continuation of print dialog requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_dialog_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue printing with the specified |settings|."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_dialog_callback_t,
            settings: *mut _cef_print_settings_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel the printing."]
    #[doc = ""]
    pub cancel:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_print_dialog_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_print_dialog_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_print_dialog_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_print_dialog_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_print_dialog_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_print_dialog_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_dialog_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_dialog_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_dialog_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_dialog_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
    fn test_field_cancel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_dialog_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_dialog_callback_t),
                "::",
                stringify!(cancel)
            )
        );
    }
    test_field_cancel();
}
#[doc = ""]
#[doc = " Callback structure for asynchronous continuation of print dialog requests."]
#[doc = ""]
pub type cef_print_dialog_callback_t = _cef_print_dialog_callback_t;
#[doc = ""]
#[doc = " Callback structure for asynchronous continuation of print job requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_job_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Indicate completion of the print job."]
    #[doc = ""]
    pub cont: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_print_job_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_print_job_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_print_job_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_print_job_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_print_job_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_print_job_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_job_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_job_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_job_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_job_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
}
#[doc = ""]
#[doc = " Callback structure for asynchronous continuation of print job requests."]
#[doc = ""]
pub type cef_print_job_callback_t = _cef_print_job_callback_t;
#[doc = ""]
#[doc = " Implement this structure to handle printing on Linux. Each browser will have"]
#[doc = " only one print job in progress at a time. The functions of this structure"]
#[doc = " will be called on the browser process UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_print_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called when printing has started for the specified |browser|. This"]
    #[doc = " function will be called before the other OnPrint*() functions and"]
    #[doc = " irrespective of how printing was initiated (e.g."]
    #[doc = " cef_browser_host_t::print(), JavaScript window.print() or PDF extension"]
    #[doc = " print button)."]
    #[doc = ""]
    pub on_print_start: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = ""]
    #[doc = " Synchronize |settings| with client state. If |get_defaults| is true (1)"]
    #[doc = " then populate |settings| with the default print settings. Do not keep a"]
    #[doc = " reference to |settings| outside of this callback."]
    #[doc = ""]
    pub on_print_settings: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            browser: *mut _cef_browser_t,
            settings: *mut _cef_print_settings_t,
            get_defaults: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Show the print dialog. Execute |callback| once the dialog is dismissed."]
    #[doc = " Return true (1) if the dialog will be displayed or false (0) to cancel the"]
    #[doc = " printing immediately."]
    #[doc = ""]
    pub on_print_dialog: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            browser: *mut _cef_browser_t,
            has_selection: ::std::os::raw::c_int,
            callback: *mut _cef_print_dialog_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Send the print job to the printer. Execute |callback| once the job is"]
    #[doc = " completed. Return true (1) if the job will proceed or false (0) to cancel"]
    #[doc = " the job immediately."]
    #[doc = ""]
    pub on_print_job: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            browser: *mut _cef_browser_t,
            document_name: *const cef_string_t,
            pdf_file_path: *const cef_string_t,
            callback: *mut _cef_print_job_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Reset client state related to printing."]
    #[doc = ""]
    pub on_print_reset: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_print_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = ""]
    #[doc = " Return the PDF paper size in device units. Used in combination with"]
    #[doc = " cef_browser_host_t::print_to_pdf()."]
    #[doc = ""]
    pub get_pdf_paper_size: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_print_handler_t,
            browser: *mut _cef_browser_t,
            device_units_per_inch: ::std::os::raw::c_int,
        ) -> cef_size_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_print_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_print_handler_t>(),
        88usize,
        concat!("Size of: ", stringify!(_cef_print_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_print_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_print_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_print_start() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_print_start) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_handler_t),
                "::",
                stringify!(on_print_start)
            )
        );
    }
    test_field_on_print_start();
    fn test_field_on_print_settings() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_print_settings) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_handler_t),
                "::",
                stringify!(on_print_settings)
            )
        );
    }
    test_field_on_print_settings();
    fn test_field_on_print_dialog() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_print_dialog) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_handler_t),
                "::",
                stringify!(on_print_dialog)
            )
        );
    }
    test_field_on_print_dialog();
    fn test_field_on_print_job() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_print_job) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_handler_t),
                "::",
                stringify!(on_print_job)
            )
        );
    }
    test_field_on_print_job();
    fn test_field_on_print_reset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_print_reset) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_handler_t),
                "::",
                stringify!(on_print_reset)
            )
        );
    }
    test_field_on_print_reset();
    fn test_field_get_pdf_paper_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_print_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_pdf_paper_size) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_print_handler_t),
                "::",
                stringify!(get_pdf_paper_size)
            )
        );
    }
    test_field_get_pdf_paper_size();
}
#[doc = ""]
#[doc = " Implement this structure to handle printing on Linux. Each browser will have"]
#[doc = " only one print job in progress at a time. The functions of this structure"]
#[doc = " will be called on the browser process UI thread."]
#[doc = ""]
pub type cef_print_handler_t = _cef_print_handler_t;
#[doc = ""]
#[doc = " Implement this structure to receive accessibility notification when"]
#[doc = " accessibility events have been registered. The functions of this structure"]
#[doc = " will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_accessibility_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called after renderer process sends accessibility tree changes to the"]
    #[doc = " browser process."]
    #[doc = ""]
    pub on_accessibility_tree_change: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_accessibility_handler_t, value: *mut _cef_value_t),
    >,
    #[doc = ""]
    #[doc = " Called after renderer process sends accessibility location changes to the"]
    #[doc = " browser process."]
    #[doc = ""]
    pub on_accessibility_location_change: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_accessibility_handler_t, value: *mut _cef_value_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_accessibility_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_accessibility_handler_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_accessibility_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_accessibility_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_accessibility_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_accessibility_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_accessibility_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_accessibility_tree_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_accessibility_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_accessibility_tree_change) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_accessibility_handler_t),
                "::",
                stringify!(on_accessibility_tree_change)
            )
        );
    }
    test_field_on_accessibility_tree_change();
    fn test_field_on_accessibility_location_change() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_accessibility_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_accessibility_location_change) as usize
                    - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_accessibility_handler_t),
                "::",
                stringify!(on_accessibility_location_change)
            )
        );
    }
    test_field_on_accessibility_location_change();
}
#[doc = ""]
#[doc = " Implement this structure to receive accessibility notification when"]
#[doc = " accessibility events have been registered. The functions of this structure"]
#[doc = " will be called on the UI thread."]
#[doc = ""]
pub type cef_accessibility_handler_t = _cef_accessibility_handler_t;
#[doc = ""]
#[doc = " Implement this structure to handle events when window rendering is disabled."]
#[doc = " The functions of this structure will be called on the UI thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_render_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Return the handler for accessibility notifications. If no handler is"]
    #[doc = " provided the default implementation will be used."]
    #[doc = ""]
    pub get_accessibility_handler: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
        ) -> *mut _cef_accessibility_handler_t,
    >,
    #[doc = ""]
    #[doc = " Called to retrieve the root window rectangle in screen DIP coordinates."]
    #[doc = " Return true (1) if the rectangle was provided. If this function returns"]
    #[doc = " false (0) the rectangle from GetViewRect will be used."]
    #[doc = ""]
    pub get_root_screen_rect: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            rect: *mut cef_rect_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to retrieve the view rectangle in screen DIP coordinates. This"]
    #[doc = " function must always provide a non-NULL rectangle."]
    #[doc = ""]
    pub get_view_rect: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            rect: *mut cef_rect_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called to retrieve the translation from view DIP coordinates to screen"]
    #[doc = " coordinates. Windows/Linux should provide screen device (pixel)"]
    #[doc = " coordinates and MacOS should provide screen DIP coordinates. Return true"]
    #[doc = " (1) if the requested coordinates were provided."]
    #[doc = ""]
    pub get_screen_point: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            viewX: ::std::os::raw::c_int,
            viewY: ::std::os::raw::c_int,
            screenX: *mut ::std::os::raw::c_int,
            screenY: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to allow the client to fill in the CefScreenInfo object with"]
    #[doc = " appropriate values. Return true (1) if the |screen_info| structure has"]
    #[doc = " been modified."]
    #[doc = ""]
    #[doc = " If the screen info rectangle is left NULL the rectangle from GetViewRect"]
    #[doc = " will be used. If the rectangle is still NULL or invalid popups may not be"]
    #[doc = " drawn correctly."]
    #[doc = ""]
    pub get_screen_info: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            screen_info: *mut cef_screen_info_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the browser wants to show or hide the popup widget. The popup"]
    #[doc = " should be shown if |show| is true (1) and hidden if |show| is false (0)."]
    #[doc = ""]
    pub on_popup_show: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            show: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the browser wants to move or resize the popup widget. |rect|"]
    #[doc = " contains the new location and size in view coordinates."]
    #[doc = ""]
    pub on_popup_size: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            rect: *const cef_rect_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when an element should be painted. Pixel values passed to this"]
    #[doc = " function are scaled relative to view coordinates based on the value of"]
    #[doc = " CefScreenInfo.device_scale_factor returned from GetScreenInfo. |type|"]
    #[doc = " indicates whether the element is the view or the popup widget. |buffer|"]
    #[doc = " contains the pixel data for the whole image. |dirtyRects| contains the set"]
    #[doc = " of rectangles in pixel coordinates that need to be repainted. |buffer|"]
    #[doc = " will be |width|*|height|*4 bytes in size and represents a BGRA image with"]
    #[doc = " an upper-left origin. This function is only called when"]
    #[doc = " cef_window_tInfo::shared_texture_enabled is set to false (0)."]
    #[doc = ""]
    pub on_paint: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            type_: cef_paint_element_type_t,
            dirtyRectsCount: size_t,
            dirtyRects: *const cef_rect_t,
            buffer: *const ::std::os::raw::c_void,
            width: ::std::os::raw::c_int,
            height: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when an element has been rendered to the shared texture handle."]
    #[doc = " |type| indicates whether the element is the view or the popup widget."]
    #[doc = " |dirtyRects| contains the set of rectangles in pixel coordinates that need"]
    #[doc = " to be repainted. |shared_handle| is the handle for a D3D11 Texture2D that"]
    #[doc = " can be accessed via ID3D11Device using the OpenSharedResource function."]
    #[doc = " This function is only called when cef_window_tInfo::shared_texture_enabled"]
    #[doc = " is set to true (1), and is currently only supported on Windows."]
    #[doc = ""]
    pub on_accelerated_paint: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            type_: cef_paint_element_type_t,
            dirtyRectsCount: size_t,
            dirtyRects: *const cef_rect_t,
            shared_handle: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = ""]
    #[doc = " Called to retrieve the size of the touch handle for the specified"]
    #[doc = " |orientation|."]
    #[doc = ""]
    pub get_touch_handle_size: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            orientation: cef_horizontal_alignment_t,
            size: *mut cef_size_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when touch handle state is updated. The client is responsible for"]
    #[doc = " rendering the touch handles."]
    #[doc = ""]
    pub on_touch_handle_state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            state: *const cef_touch_handle_state_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the user starts dragging content in the web view. Contextual"]
    #[doc = " information about the dragged content is supplied by |drag_data|. (|x|,"]
    #[doc = " |y|) is the drag start location in screen coordinates. OS APIs that run a"]
    #[doc = " system message loop may be used within the StartDragging call."]
    #[doc = ""]
    #[doc = " Return false (0) to abort the drag operation. Don't call any of"]
    #[doc = " cef_browser_host_t::DragSource*Ended* functions after returning false (0)."]
    #[doc = ""]
    #[doc = " Return true (1) to handle the drag operation. Call"]
    #[doc = " cef_browser_host_t::DragSourceEndedAt and DragSourceSystemDragEnded either"]
    #[doc = " synchronously or asynchronously to inform the web view that the drag"]
    #[doc = " operation has ended."]
    #[doc = ""]
    pub start_dragging: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            drag_data: *mut _cef_drag_data_t,
            allowed_ops: cef_drag_operations_mask_t,
            x: ::std::os::raw::c_int,
            y: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called when the web view wants to update the mouse cursor during a drag &"]
    #[doc = " drop operation. |operation| describes the allowed operation (none, move,"]
    #[doc = " copy, link)."]
    #[doc = ""]
    pub update_drag_cursor: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            operation: cef_drag_operations_mask_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the scroll offset has changed."]
    #[doc = ""]
    pub on_scroll_offset_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            x: f64,
            y: f64,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when the IME composition range has changed. |selected_range| is the"]
    #[doc = " range of characters that have been selected. |character_bounds| is the"]
    #[doc = " bounds of each character in view coordinates."]
    #[doc = ""]
    pub on_ime_composition_range_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            selected_range: *const cef_range_t,
            character_boundsCount: size_t,
            character_bounds: *const cef_rect_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when text selection has changed for the specified |browser|."]
    #[doc = " |selected_text| is the currently selected text and |selected_range| is the"]
    #[doc = " character range."]
    #[doc = ""]
    pub on_text_selection_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            selected_text: *const cef_string_t,
            selected_range: *const cef_range_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when an on-screen keyboard should be shown or hidden for the"]
    #[doc = " specified |browser|. |input_mode| specifies what kind of keyboard should"]
    #[doc = " be opened. If |input_mode| is CEF_TEXT_INPUT_MODE_NONE, any existing"]
    #[doc = " keyboard for this browser should be hidden."]
    #[doc = ""]
    pub on_virtual_keyboard_requested: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_handler_t,
            browser: *mut _cef_browser_t,
            input_mode: cef_text_input_mode_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_render_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_render_handler_t>(),
        176usize,
        concat!("Size of: ", stringify!(_cef_render_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_render_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_render_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_accessibility_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_accessibility_handler) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(get_accessibility_handler)
            )
        );
    }
    test_field_get_accessibility_handler();
    fn test_field_get_root_screen_rect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_root_screen_rect) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(get_root_screen_rect)
            )
        );
    }
    test_field_get_root_screen_rect();
    fn test_field_get_view_rect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_view_rect) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(get_view_rect)
            )
        );
    }
    test_field_get_view_rect();
    fn test_field_get_screen_point() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_screen_point) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(get_screen_point)
            )
        );
    }
    test_field_get_screen_point();
    fn test_field_get_screen_info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_screen_info) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(get_screen_info)
            )
        );
    }
    test_field_get_screen_info();
    fn test_field_on_popup_show() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_popup_show) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(on_popup_show)
            )
        );
    }
    test_field_on_popup_show();
    fn test_field_on_popup_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_popup_size) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(on_popup_size)
            )
        );
    }
    test_field_on_popup_size();
    fn test_field_on_paint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_paint) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(on_paint)
            )
        );
    }
    test_field_on_paint();
    fn test_field_on_accelerated_paint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_accelerated_paint) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(on_accelerated_paint)
            )
        );
    }
    test_field_on_accelerated_paint();
    fn test_field_get_touch_handle_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_touch_handle_size) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(get_touch_handle_size)
            )
        );
    }
    test_field_get_touch_handle_size();
    fn test_field_on_touch_handle_state_changed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_touch_handle_state_changed) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(on_touch_handle_state_changed)
            )
        );
    }
    test_field_on_touch_handle_state_changed();
    fn test_field_start_dragging() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).start_dragging) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(start_dragging)
            )
        );
    }
    test_field_start_dragging();
    fn test_field_update_drag_cursor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).update_drag_cursor) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(update_drag_cursor)
            )
        );
    }
    test_field_update_drag_cursor();
    fn test_field_on_scroll_offset_changed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_scroll_offset_changed) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(on_scroll_offset_changed)
            )
        );
    }
    test_field_on_scroll_offset_changed();
    fn test_field_on_ime_composition_range_changed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_ime_composition_range_changed) as usize
                    - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(on_ime_composition_range_changed)
            )
        );
    }
    test_field_on_ime_composition_range_changed();
    fn test_field_on_text_selection_changed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_text_selection_changed) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(on_text_selection_changed)
            )
        );
    }
    test_field_on_text_selection_changed();
    fn test_field_on_virtual_keyboard_requested() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_virtual_keyboard_requested) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_handler_t),
                "::",
                stringify!(on_virtual_keyboard_requested)
            )
        );
    }
    test_field_on_virtual_keyboard_requested();
}
#[doc = ""]
#[doc = " Implement this structure to handle events when window rendering is disabled."]
#[doc = " The functions of this structure will be called on the UI thread."]
#[doc = ""]
pub type cef_render_handler_t = _cef_render_handler_t;
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of authentication"]
#[doc = " requests."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_auth_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Continue the authentication request."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_auth_callback_t,
            username: *const cef_string_t,
            password: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Cancel the authentication request."]
    #[doc = ""]
    pub cancel: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_auth_callback_t)>,
}
#[test]
fn bindgen_test_layout__cef_auth_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_auth_callback_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_auth_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_auth_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_auth_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_auth_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_auth_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_auth_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_auth_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
    fn test_field_cancel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_auth_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_auth_callback_t),
                "::",
                stringify!(cancel)
            )
        );
    }
    test_field_cancel();
}
#[doc = ""]
#[doc = " Callback structure used for asynchronous continuation of authentication"]
#[doc = " requests."]
#[doc = ""]
pub type cef_auth_callback_t = _cef_auth_callback_t;
#[doc = ""]
#[doc = " Structure used to represent a web response. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_response_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is read-only."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Get the response error code. Returns ERR_NONE if there was no error."]
    #[doc = ""]
    pub get_error:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_errorcode_t>,
    #[doc = ""]
    #[doc = " Set the response error code. This can be used by custom scheme handlers to"]
    #[doc = " return errors during initial request processing."]
    #[doc = ""]
    pub set_error: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, error: cef_errorcode_t),
    >,
    #[doc = ""]
    #[doc = " Get the response status code."]
    #[doc = ""]
    pub get_status: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set the response status code."]
    #[doc = ""]
    pub set_status: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, status: ::std::os::raw::c_int),
    >,
    #[doc = ""]
    #[doc = " Get the response status text."]
    #[doc = ""]
    pub get_status_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the response status text."]
    #[doc = ""]
    pub set_status_text: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, statusText: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Get the response mime type."]
    #[doc = ""]
    pub get_mime_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the response mime type."]
    #[doc = ""]
    pub set_mime_type: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, mimeType: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Get the response charset."]
    #[doc = ""]
    pub get_charset: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the response charset."]
    #[doc = ""]
    pub set_charset: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, charset: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Get the value for the specified response header field."]
    #[doc = ""]
    pub get_header_by_name: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_response_t,
            name: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the header |name| to |value|. If |overwrite| is true (1) any existing"]
    #[doc = " values will be replaced with the new value. If |overwrite| is false (0)"]
    #[doc = " any existing values will not be overwritten."]
    #[doc = ""]
    pub set_header_by_name: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_response_t,
            name: *const cef_string_t,
            value: *const cef_string_t,
            overwrite: ::std::os::raw::c_int,
        ),
    >,
    #[doc = ""]
    #[doc = " Get all response header fields."]
    #[doc = ""]
    pub get_header_map: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, headerMap: cef_string_multimap_t),
    >,
    #[doc = ""]
    #[doc = " Set all response header fields."]
    #[doc = ""]
    pub set_header_map: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, headerMap: cef_string_multimap_t),
    >,
    #[doc = ""]
    #[doc = " Get the resolved URL after redirects or changed as a result of HSTS."]
    #[doc = ""]
    pub get_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the resolved URL after redirects or changed as a result of HSTS."]
    #[doc = ""]
    pub set_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_t, url: *const cef_string_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_response_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_response_t>(),
        176usize,
        concat!("Size of: ", stringify!(_cef_response_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_response_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_response_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_read_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(is_read_only)
            )
        );
    }
    test_field_is_read_only();
    fn test_field_get_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_error) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(get_error)
            )
        );
    }
    test_field_get_error();
    fn test_field_set_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_error) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(set_error)
            )
        );
    }
    test_field_set_error();
    fn test_field_get_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_status) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(get_status)
            )
        );
    }
    test_field_get_status();
    fn test_field_set_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_status) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(set_status)
            )
        );
    }
    test_field_set_status();
    fn test_field_get_status_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_status_text) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(get_status_text)
            )
        );
    }
    test_field_get_status_text();
    fn test_field_set_status_text() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_status_text) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(set_status_text)
            )
        );
    }
    test_field_set_status_text();
    fn test_field_get_mime_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_mime_type) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(get_mime_type)
            )
        );
    }
    test_field_get_mime_type();
    fn test_field_set_mime_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_mime_type) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(set_mime_type)
            )
        );
    }
    test_field_set_mime_type();
    fn test_field_get_charset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_charset) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(get_charset)
            )
        );
    }
    test_field_get_charset();
    fn test_field_set_charset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_charset) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(set_charset)
            )
        );
    }
    test_field_set_charset();
    fn test_field_get_header_by_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_header_by_name) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(get_header_by_name)
            )
        );
    }
    test_field_get_header_by_name();
    fn test_field_set_header_by_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_header_by_name) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(set_header_by_name)
            )
        );
    }
    test_field_set_header_by_name();
    fn test_field_get_header_map() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_header_map) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(get_header_map)
            )
        );
    }
    test_field_get_header_map();
    fn test_field_set_header_map() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_header_map) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(set_header_map)
            )
        );
    }
    test_field_set_header_map();
    fn test_field_get_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_url) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(get_url)
            )
        );
    }
    test_field_get_url();
    fn test_field_set_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_url) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_t),
                "::",
                stringify!(set_url)
            )
        );
    }
    test_field_set_url();
}
#[doc = ""]
#[doc = " Structure used to represent a web response. The functions of this structure"]
#[doc = " may be called on any thread."]
#[doc = ""]
pub type cef_response_t = _cef_response_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_response_t object."]
    #[doc = ""]
    pub fn cef_response_create() -> *mut cef_response_t;
}
#[doc = ""]
#[doc = " Callback for asynchronous continuation of cef_resource_handler_t::skip()."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_skip_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Callback for asynchronous continuation of skip(). If |bytes_skipped| > 0"]
    #[doc = " then either skip() will be called again until the requested number of"]
    #[doc = " bytes have been skipped or the request will proceed. If |bytes_skipped| <="]
    #[doc = " 0 the request will fail with ERR_REQUEST_RANGE_NOT_SATISFIABLE."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_resource_skip_callback_t, bytes_skipped: int64),
    >,
}
#[test]
fn bindgen_test_layout__cef_resource_skip_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_resource_skip_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_resource_skip_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_resource_skip_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resource_skip_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_skip_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_skip_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_skip_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_skip_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
}
#[doc = ""]
#[doc = " Callback for asynchronous continuation of cef_resource_handler_t::skip()."]
#[doc = ""]
pub type cef_resource_skip_callback_t = _cef_resource_skip_callback_t;
#[doc = ""]
#[doc = " Callback for asynchronous continuation of cef_resource_handler_t::read()."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_read_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Callback for asynchronous continuation of read(). If |bytes_read| == 0 the"]
    #[doc = " response will be considered complete. If |bytes_read| > 0 then read() will"]
    #[doc = " be called again until the request is complete (based on either the result"]
    #[doc = " or the expected content length). If |bytes_read| < 0 then the request will"]
    #[doc = " fail and the |bytes_read| value will be treated as the error code."]
    #[doc = ""]
    pub cont: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_read_callback_t,
            bytes_read: ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_resource_read_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_resource_read_callback_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_resource_read_callback_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_resource_read_callback_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resource_read_callback_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_read_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_read_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_cont() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_read_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cont) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_read_callback_t),
                "::",
                stringify!(cont)
            )
        );
    }
    test_field_cont();
}
#[doc = ""]
#[doc = " Callback for asynchronous continuation of cef_resource_handler_t::read()."]
#[doc = ""]
pub type cef_resource_read_callback_t = _cef_resource_read_callback_t;
#[doc = ""]
#[doc = " Structure used to implement a custom request handler structure. The"]
#[doc = " functions of this structure will be called on the IO thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Open the response stream. To handle the request immediately set"]
    #[doc = " |handle_request| to true (1) and return true (1). To decide at a later"]
    #[doc = " time set |handle_request| to false (0), return true (1), and execute"]
    #[doc = " |callback| to continue or cancel the request. To cancel the request"]
    #[doc = " immediately set |handle_request| to true (1) and return false (0). This"]
    #[doc = " function will be called in sequence but not from a dedicated thread. For"]
    #[doc = " backwards compatibility set |handle_request| to false (0) and return false"]
    #[doc = " (0) and the ProcessRequest function will be called."]
    #[doc = ""]
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            request: *mut _cef_request_t,
            handle_request: *mut ::std::os::raw::c_int,
            callback: *mut _cef_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Begin processing the request. To handle the request return true (1) and"]
    #[doc = " call cef_callback_t::cont() once the response header information is"]
    #[doc = " available (cef_callback_t::cont() can also be called from inside this"]
    #[doc = " function if header information is available immediately). To cancel the"]
    #[doc = " request return false (0)."]
    #[doc = ""]
    #[doc = " WARNING: This function is deprecated. Use Open instead."]
    #[doc = ""]
    pub process_request: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            request: *mut _cef_request_t,
            callback: *mut _cef_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Retrieve response header information. If the response length is not known"]
    #[doc = " set |response_length| to -1 and read_response() will be called until it"]
    #[doc = " returns false (0). If the response length is known set |response_length|"]
    #[doc = " to a positive value and read_response() will be called until it returns"]
    #[doc = " false (0) or the specified number of bytes have been read. Use the"]
    #[doc = " |response| object to set the mime type, http status code and other"]
    #[doc = " optional header values. To redirect the request to a new URL set"]
    #[doc = " |redirectUrl| to the new URL. |redirectUrl| can be either a relative or"]
    #[doc = " fully qualified URL. It is also possible to set |response| to a redirect"]
    #[doc = " http status code and pass the new URL via a Location header. Likewise with"]
    #[doc = " |redirectUrl| it is valid to set a relative or fully qualified URL as the"]
    #[doc = " Location header value. If an error occured while setting up the request"]
    #[doc = " you can call set_error() on |response| to indicate the error condition."]
    #[doc = ""]
    pub get_response_headers: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            response: *mut _cef_response_t,
            response_length: *mut int64,
            redirectUrl: *mut cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Skip response data when requested by a Range header. Skip over and discard"]
    #[doc = " |bytes_to_skip| bytes of response data. If data is available immediately"]
    #[doc = " set |bytes_skipped| to the number of bytes skipped and return true (1). To"]
    #[doc = " read the data at a later time set |bytes_skipped| to 0, return true (1)"]
    #[doc = " and execute |callback| when the data is available. To indicate failure set"]
    #[doc = " |bytes_skipped| to < 0 (e.g. -2 for ERR_FAILED) and return false (0). This"]
    #[doc = " function will be called in sequence but not from a dedicated thread."]
    #[doc = ""]
    pub skip: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            bytes_to_skip: int64,
            bytes_skipped: *mut int64,
            callback: *mut _cef_resource_skip_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Read response data. If data is available immediately copy up to"]
    #[doc = " |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of"]
    #[doc = " bytes copied, and return true (1). To read the data at a later time keep a"]
    #[doc = " pointer to |data_out|, set |bytes_read| to 0, return true (1) and execute"]
    #[doc = " |callback| when the data is available (|data_out| will remain valid until"]
    #[doc = " the callback is executed). To indicate response completion set"]
    #[doc = " |bytes_read| to 0 and return false (0). To indicate failure set"]
    #[doc = " |bytes_read| to < 0 (e.g. -2 for ERR_FAILED) and return false (0). This"]
    #[doc = " function will be called in sequence but not from a dedicated thread. For"]
    #[doc = " backwards compatibility set |bytes_read| to -1 and return false (0) and"]
    #[doc = " the ReadResponse function will be called."]
    #[doc = ""]
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            data_out: *mut ::std::os::raw::c_void,
            bytes_to_read: ::std::os::raw::c_int,
            bytes_read: *mut ::std::os::raw::c_int,
            callback: *mut _cef_resource_read_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Read response data. If data is available immediately copy up to"]
    #[doc = " |bytes_to_read| bytes into |data_out|, set |bytes_read| to the number of"]
    #[doc = " bytes copied, and return true (1). To read the data at a later time set"]
    #[doc = " |bytes_read| to 0, return true (1) and call cef_callback_t::cont() when"]
    #[doc = " the data is available. To indicate response completion return false (0)."]
    #[doc = ""]
    #[doc = " WARNING: This function is deprecated. Use Skip and Read instead."]
    #[doc = ""]
    pub read_response: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_handler_t,
            data_out: *mut ::std::os::raw::c_void,
            bytes_to_read: ::std::os::raw::c_int,
            bytes_read: *mut ::std::os::raw::c_int,
            callback: *mut _cef_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Request processing has been canceled."]
    #[doc = ""]
    pub cancel: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_resource_handler_t)>,
}
#[test]
fn bindgen_test_layout__cef_resource_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_resource_handler_t>(),
        96usize,
        concat!("Size of: ", stringify!(_cef_resource_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_resource_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resource_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_open() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).open) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_handler_t),
                "::",
                stringify!(open)
            )
        );
    }
    test_field_open();
    fn test_field_process_request() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).process_request) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_handler_t),
                "::",
                stringify!(process_request)
            )
        );
    }
    test_field_process_request();
    fn test_field_get_response_headers() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_response_headers) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_handler_t),
                "::",
                stringify!(get_response_headers)
            )
        );
    }
    test_field_get_response_headers();
    fn test_field_skip() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).skip) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_handler_t),
                "::",
                stringify!(skip)
            )
        );
    }
    test_field_skip();
    fn test_field_read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_handler_t),
                "::",
                stringify!(read)
            )
        );
    }
    test_field_read();
    fn test_field_read_response() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).read_response) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_handler_t),
                "::",
                stringify!(read_response)
            )
        );
    }
    test_field_read_response();
    fn test_field_cancel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cancel) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_handler_t),
                "::",
                stringify!(cancel)
            )
        );
    }
    test_field_cancel();
}
#[doc = ""]
#[doc = " Structure used to implement a custom request handler structure. The"]
#[doc = " functions of this structure will be called on the IO thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
pub type cef_resource_handler_t = _cef_resource_handler_t;
#[doc = ""]
#[doc = " Implement this structure to filter resource response content. The functions"]
#[doc = " of this structure will be called on the browser process IO thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_response_filter_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Initialize the response filter. Will only be called a single time. The"]
    #[doc = " filter will not be installed if this function returns false (0)."]
    #[doc = ""]
    pub init_filter: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_response_filter_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to filter a chunk of data. Expected usage is as follows:"]
    #[doc = ""]
    #[doc = "  1. Read input data from |data_in| and set |data_in_read| to the number of"]
    #[doc = "     bytes that were read up to a maximum of |data_in_size|. |data_in| will"]
    #[doc = "     be NULL if |data_in_size| is zero."]
    #[doc = "  2. Write filtered output data to |data_out| and set |data_out_written| to"]
    #[doc = "     the number of bytes that were written up to a maximum of"]
    #[doc = "     |data_out_size|. If no output data was written then all data must be"]
    #[doc = "     read from |data_in| (user must set |data_in_read| = |data_in_size|)."]
    #[doc = "  3. Return RESPONSE_FILTER_DONE if all output data was written or"]
    #[doc = "     RESPONSE_FILTER_NEED_MORE_DATA if output data is still pending."]
    #[doc = ""]
    #[doc = " This function will be called repeatedly until the input buffer has been"]
    #[doc = " fully read (user sets |data_in_read| = |data_in_size|) and there is no"]
    #[doc = " more input data to filter (the resource response is complete). This"]
    #[doc = " function may then be called an additional time with an NULL input buffer"]
    #[doc = " if the user filled the output buffer (set |data_out_written| ="]
    #[doc = " |data_out_size|) and returned RESPONSE_FILTER_NEED_MORE_DATA to indicate"]
    #[doc = " that output data is still pending."]
    #[doc = ""]
    #[doc = " Calls to this function will stop when one of the following conditions is"]
    #[doc = " met:"]
    #[doc = ""]
    #[doc = "  1. There is no more input data to filter (the resource response is"]
    #[doc = "     complete) and the user sets |data_out_written| = 0 or returns"]
    #[doc = "     RESPONSE_FILTER_DONE to indicate that all data has been written, or;"]
    #[doc = "  2. The user returns RESPONSE_FILTER_ERROR to indicate an error."]
    #[doc = ""]
    #[doc = " Do not keep a reference to the buffers passed to this function."]
    #[doc = ""]
    pub filter: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_response_filter_t,
            data_in: *mut ::std::os::raw::c_void,
            data_in_size: size_t,
            data_in_read: *mut size_t,
            data_out: *mut ::std::os::raw::c_void,
            data_out_size: size_t,
            data_out_written: *mut size_t,
        ) -> cef_response_filter_status_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_response_filter_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_response_filter_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_response_filter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_response_filter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_response_filter_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_filter_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_filter_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_init_filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_filter_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init_filter) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_filter_t),
                "::",
                stringify!(init_filter)
            )
        );
    }
    test_field_init_filter();
    fn test_field_filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_response_filter_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filter) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_response_filter_t),
                "::",
                stringify!(filter)
            )
        );
    }
    test_field_filter();
}
#[doc = ""]
#[doc = " Implement this structure to filter resource response content. The functions"]
#[doc = " of this structure will be called on the browser process IO thread."]
#[doc = ""]
pub type cef_response_filter_t = _cef_response_filter_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser requests. The"]
#[doc = " functions of this structure will be called on the IO thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_request_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called on the IO thread before a resource request is loaded. The |browser|"]
    #[doc = " and |frame| values represent the source of the request, and may be NULL"]
    #[doc = " for requests originating from service workers or cef_urlrequest_t. To"]
    #[doc = " optionally filter cookies for the request return a"]
    #[doc = " cef_cookie_access_filter_t object. The |request| object cannot not be"]
    #[doc = " modified in this callback."]
    #[doc = ""]
    pub get_cookie_access_filter: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
        ) -> *mut _cef_cookie_access_filter_t,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread before a resource request is loaded. The |browser|"]
    #[doc = " and |frame| values represent the source of the request, and may be NULL"]
    #[doc = " for requests originating from service workers or cef_urlrequest_t. To"]
    #[doc = " redirect or change the resource load optionally modify |request|."]
    #[doc = " Modification of the request URL will be treated as a redirect. Return"]
    #[doc = " RV_CONTINUE to continue the request immediately. Return RV_CONTINUE_ASYNC"]
    #[doc = " and call cef_callback_t functions at a later time to continue or cancel"]
    #[doc = " the request asynchronously. Return RV_CANCEL to cancel the request"]
    #[doc = " immediately."]
    #[doc = ""]
    pub on_before_resource_load: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            callback: *mut _cef_callback_t,
        ) -> cef_return_value_t,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread before a resource is loaded. The |browser| and"]
    #[doc = " |frame| values represent the source of the request, and may be NULL for"]
    #[doc = " requests originating from service workers or cef_urlrequest_t. To allow"]
    #[doc = " the resource to load using the default network loader return NULL. To"]
    #[doc = " specify a handler for the resource return a cef_resource_handler_t object."]
    #[doc = " The |request| object cannot not be modified in this callback."]
    #[doc = ""]
    pub get_resource_handler: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
        ) -> *mut _cef_resource_handler_t,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread when a resource load is redirected. The |browser|"]
    #[doc = " and |frame| values represent the source of the request, and may be NULL"]
    #[doc = " for requests originating from service workers or cef_urlrequest_t. The"]
    #[doc = " |request| parameter will contain the old URL and other request-related"]
    #[doc = " information. The |response| parameter will contain the response that"]
    #[doc = " resulted in the redirect. The |new_url| parameter will contain the new URL"]
    #[doc = " and can be changed if desired. The |request| and |response| objects cannot"]
    #[doc = " be modified in this callback."]
    #[doc = ""]
    pub on_resource_redirect: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
            new_url: *mut cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread when a resource response is received. The"]
    #[doc = " |browser| and |frame| values represent the source of the request, and may"]
    #[doc = " be NULL for requests originating from service workers or cef_urlrequest_t."]
    #[doc = " To allow the resource load to proceed without modification return false"]
    #[doc = " (0). To redirect or retry the resource load optionally modify |request|"]
    #[doc = " and return true (1). Modification of the request URL will be treated as a"]
    #[doc = " redirect. Requests handled using the default network loader cannot be"]
    #[doc = " redirected in this callback. The |response| object cannot be modified in"]
    #[doc = " this callback."]
    #[doc = ""]
    #[doc = " WARNING: Redirecting using this function is deprecated. Use"]
    #[doc = " OnBeforeResourceLoad or GetResourceHandler to perform redirects."]
    #[doc = ""]
    pub on_resource_response: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread to optionally filter resource response content."]
    #[doc = " The |browser| and |frame| values represent the source of the request, and"]
    #[doc = " may be NULL for requests originating from service workers or"]
    #[doc = " cef_urlrequest_t. |request| and |response| represent the request and"]
    #[doc = " response respectively and cannot be modified in this callback."]
    #[doc = ""]
    pub get_resource_response_filter: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
        ) -> *mut _cef_response_filter_t,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread when a resource load has completed. The |browser|"]
    #[doc = " and |frame| values represent the source of the request, and may be NULL"]
    #[doc = " for requests originating from service workers or cef_urlrequest_t."]
    #[doc = " |request| and |response| represent the request and response respectively"]
    #[doc = " and cannot be modified in this callback. |status| indicates the load"]
    #[doc = " completion status. |received_content_length| is the number of response"]
    #[doc = " bytes actually read. This function will be called for all requests,"]
    #[doc = " including requests that are aborted due to CEF shutdown or destruction of"]
    #[doc = " the associated browser. In cases where the associated browser is destroyed"]
    #[doc = " this callback may arrive after the cef_life_span_handler_t::OnBeforeClose"]
    #[doc = " callback for that browser. The cef_frame_t::IsValid function can be used"]
    #[doc = " to test for this situation, and care should be taken not to call |browser|"]
    #[doc = " or |frame| functions that modify state (like LoadURL, SendProcessMessage,"]
    #[doc = " etc.) if the frame is invalid."]
    #[doc = ""]
    pub on_resource_load_complete: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
            status: cef_urlrequest_status_t,
            received_content_length: int64,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread to handle requests for URLs with an unknown"]
    #[doc = " protocol component. The |browser| and |frame| values represent the source"]
    #[doc = " of the request, and may be NULL for requests originating from service"]
    #[doc = " workers or cef_urlrequest_t. |request| cannot be modified in this"]
    #[doc = " callback. Set |allow_os_execution| to true (1) to attempt execution via"]
    #[doc = " the registered OS protocol handler, if any. SECURITY WARNING: YOU SHOULD"]
    #[doc = " USE THIS METHOD TO ENFORCE RESTRICTIONS BASED ON SCHEME, HOST OR OTHER URL"]
    #[doc = " ANALYSIS BEFORE ALLOWING OS EXECUTION."]
    #[doc = ""]
    pub on_protocol_execution: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            allow_os_execution: *mut ::std::os::raw::c_int,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_resource_request_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_resource_request_handler_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_resource_request_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_resource_request_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resource_request_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_request_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_cookie_access_filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_cookie_access_filter) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_request_handler_t),
                "::",
                stringify!(get_cookie_access_filter)
            )
        );
    }
    test_field_get_cookie_access_filter();
    fn test_field_on_before_resource_load() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_before_resource_load) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_request_handler_t),
                "::",
                stringify!(on_before_resource_load)
            )
        );
    }
    test_field_on_before_resource_load();
    fn test_field_get_resource_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_resource_handler) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_request_handler_t),
                "::",
                stringify!(get_resource_handler)
            )
        );
    }
    test_field_get_resource_handler();
    fn test_field_on_resource_redirect() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_resource_redirect) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_request_handler_t),
                "::",
                stringify!(on_resource_redirect)
            )
        );
    }
    test_field_on_resource_redirect();
    fn test_field_on_resource_response() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_resource_response) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_request_handler_t),
                "::",
                stringify!(on_resource_response)
            )
        );
    }
    test_field_on_resource_response();
    fn test_field_get_resource_response_filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_resource_response_filter) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_request_handler_t),
                "::",
                stringify!(get_resource_response_filter)
            )
        );
    }
    test_field_get_resource_response_filter();
    fn test_field_on_resource_load_complete() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_resource_load_complete) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_request_handler_t),
                "::",
                stringify!(on_resource_load_complete)
            )
        );
    }
    test_field_on_resource_load_complete();
    fn test_field_on_protocol_execution() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_protocol_execution) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_request_handler_t),
                "::",
                stringify!(on_protocol_execution)
            )
        );
    }
    test_field_on_protocol_execution();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser requests. The"]
#[doc = " functions of this structure will be called on the IO thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
pub type cef_resource_request_handler_t = _cef_resource_request_handler_t;
#[doc = ""]
#[doc = " Implement this structure to filter cookies that may be sent or received from"]
#[doc = " resource requests. The functions of this structure will be called on the IO"]
#[doc = " thread unless otherwise indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_cookie_access_filter_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called on the IO thread before a resource request is sent. The |browser|"]
    #[doc = " and |frame| values represent the source of the request, and may be NULL"]
    #[doc = " for requests originating from service workers or cef_urlrequest_t."]
    #[doc = " |request| cannot be modified in this callback. Return true (1) if the"]
    #[doc = " specified cookie can be sent with the request or false (0) otherwise."]
    #[doc = ""]
    pub can_send_cookie: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_access_filter_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            cookie: *const _cef_cookie_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread after a resource response is received. The"]
    #[doc = " |browser| and |frame| values represent the source of the request, and may"]
    #[doc = " be NULL for requests originating from service workers or cef_urlrequest_t."]
    #[doc = " |request| cannot be modified in this callback. Return true (1) if the"]
    #[doc = " specified cookie returned with the response can be saved or false (0)"]
    #[doc = " otherwise."]
    #[doc = ""]
    pub can_save_cookie: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_cookie_access_filter_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            response: *mut _cef_response_t,
            cookie: *const _cef_cookie_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_cookie_access_filter_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_cookie_access_filter_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_cookie_access_filter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_cookie_access_filter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_cookie_access_filter_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_access_filter_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_access_filter_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_can_send_cookie() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_access_filter_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).can_send_cookie) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_access_filter_t),
                "::",
                stringify!(can_send_cookie)
            )
        );
    }
    test_field_can_send_cookie();
    fn test_field_can_save_cookie() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_cookie_access_filter_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).can_save_cookie) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_cookie_access_filter_t),
                "::",
                stringify!(can_save_cookie)
            )
        );
    }
    test_field_can_save_cookie();
}
#[doc = ""]
#[doc = " Implement this structure to filter cookies that may be sent or received from"]
#[doc = " resource requests. The functions of this structure will be called on the IO"]
#[doc = " thread unless otherwise indicated."]
#[doc = ""]
pub type cef_cookie_access_filter_t = _cef_cookie_access_filter_t;
#[doc = ""]
#[doc = " Structure representing SSL information."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_sslinfo_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns a bitmask containing any and all problems verifying the server"]
    #[doc = " certificate."]
    #[doc = ""]
    pub get_cert_status: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslinfo_t) -> cef_cert_status_t,
    >,
    #[doc = ""]
    #[doc = " Returns the X.509 certificate."]
    #[doc = ""]
    pub get_x509certificate: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_sslinfo_t) -> *mut _cef_x509certificate_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_sslinfo_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_sslinfo_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_sslinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_sslinfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_sslinfo_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_sslinfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_sslinfo_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_cert_status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_sslinfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_cert_status) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_sslinfo_t),
                "::",
                stringify!(get_cert_status)
            )
        );
    }
    test_field_get_cert_status();
    fn test_field_get_x509certificate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_sslinfo_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_x509certificate) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_sslinfo_t),
                "::",
                stringify!(get_x509certificate)
            )
        );
    }
    test_field_get_x509certificate();
}
#[doc = ""]
#[doc = " Structure representing SSL information."]
#[doc = ""]
pub type cef_sslinfo_t = _cef_sslinfo_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns true (1) if the certificate status represents an error."]
    #[doc = ""]
    pub fn cef_is_cert_status_error(status: cef_cert_status_t) -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " Callback structure used to select a client certificate for authentication."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_select_client_certificate_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Chooses the specified certificate for client certificate authentication."]
    #[doc = " NULL value means that no client certificate should be used."]
    #[doc = ""]
    pub select: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_select_client_certificate_callback_t,
            cert: *mut _cef_x509certificate_t,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_select_client_certificate_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_select_client_certificate_callback_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_cef_select_client_certificate_callback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_select_client_certificate_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_select_client_certificate_callback_t)
        )
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_cef_select_client_certificate_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_select_client_certificate_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_select() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_cef_select_client_certificate_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).select) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_select_client_certificate_callback_t),
                "::",
                stringify!(select)
            )
        );
    }
    test_field_select();
}
#[doc = ""]
#[doc = " Callback structure used to select a client certificate for authentication."]
#[doc = ""]
pub type cef_select_client_certificate_callback_t = _cef_select_client_certificate_callback_t;
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser requests. The"]
#[doc = " functions of this structure will be called on the thread indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_request_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called on the UI thread before browser navigation. Return true (1) to"]
    #[doc = " cancel the navigation or false (0) to allow the navigation to proceed. The"]
    #[doc = " |request| object cannot be modified in this callback."]
    #[doc = " cef_load_handler_t::OnLoadingStateChange will be called twice in all"]
    #[doc = " cases. If the navigation is allowed cef_load_handler_t::OnLoadStart and"]
    #[doc = " cef_load_handler_t::OnLoadEnd will be called. If the navigation is"]
    #[doc = " canceled cef_load_handler_t::OnLoadError will be called with an"]
    #[doc = " |errorCode| value of ERR_ABORTED. The |user_gesture| value will be true"]
    #[doc = " (1) if the browser navigated via explicit user gesture (e.g. clicking a"]
    #[doc = " link) or false (0) if it navigated automatically (e.g. via the"]
    #[doc = " DomContentLoaded event)."]
    #[doc = ""]
    pub on_before_browse: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            user_gesture: ::std::os::raw::c_int,
            is_redirect: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the UI thread before OnBeforeBrowse in certain limited cases"]
    #[doc = " where navigating a new or different browser might be desirable. This"]
    #[doc = " includes user-initiated navigation that might open in a special way (e.g."]
    #[doc = " links clicked via middle-click or ctrl + left-click) and certain types of"]
    #[doc = " cross-origin navigation initiated from the renderer process (e.g."]
    #[doc = " navigating the top-level frame to/from a file URL). The |browser| and"]
    #[doc = " |frame| values represent the source of the navigation. The"]
    #[doc = " |target_disposition| value indicates where the user intended to navigate"]
    #[doc = " the browser based on standard Chromium behaviors (e.g. current tab, new"]
    #[doc = " tab, etc). The |user_gesture| value will be true (1) if the browser"]
    #[doc = " navigated via explicit user gesture (e.g. clicking a link) or false (0) if"]
    #[doc = " it navigated automatically (e.g. via the DomContentLoaded event). Return"]
    #[doc = " true (1) to cancel the navigation or false (0) to allow the navigation to"]
    #[doc = " proceed in the source browser's top-level frame."]
    #[doc = ""]
    pub on_open_urlfrom_tab: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            target_url: *const cef_string_t,
            target_disposition: cef_window_open_disposition_t,
            user_gesture: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the browser process IO thread before a resource request is"]
    #[doc = " initiated. The |browser| and |frame| values represent the source of the"]
    #[doc = " request. |request| represents the request contents and cannot be modified"]
    #[doc = " in this callback. |is_navigation| will be true (1) if the resource request"]
    #[doc = " is a navigation. |is_download| will be true (1) if the resource request is"]
    #[doc = " a download. |request_initiator| is the origin (scheme + domain) of the"]
    #[doc = " page that initiated the request. Set |disable_default_handling| to true"]
    #[doc = " (1) to disable default handling of the request, in which case it will need"]
    #[doc = " to be handled via cef_resource_request_handler_t::GetResourceHandler or it"]
    #[doc = " will be canceled. To allow the resource load to proceed with default"]
    #[doc = " handling return NULL. To specify a handler for the resource return a"]
    #[doc = " cef_resource_request_handler_t object. If this callback returns NULL the"]
    #[doc = " same function will be called on the associated"]
    #[doc = " cef_request_context_handler_t, if any."]
    #[doc = ""]
    pub get_resource_request_handler: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            request: *mut _cef_request_t,
            is_navigation: ::std::os::raw::c_int,
            is_download: ::std::os::raw::c_int,
            request_initiator: *const cef_string_t,
            disable_default_handling: *mut ::std::os::raw::c_int,
        ) -> *mut _cef_resource_request_handler_t,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread when the browser needs credentials from the user."]
    #[doc = " |origin_url| is the origin making this authentication request. |isProxy|"]
    #[doc = " indicates whether the host is a proxy server. |host| contains the hostname"]
    #[doc = " and |port| contains the port number. |realm| is the realm of the challenge"]
    #[doc = " and may be NULL. |scheme| is the authentication scheme used, such as"]
    #[doc = " \"basic\" or \"digest\", and will be NULL if the source of the request is an"]
    #[doc = " FTP server. Return true (1) to continue the request and call"]
    #[doc = " cef_auth_callback_t::cont() either in this function or at a later time"]
    #[doc = " when the authentication information is available. Return false (0) to"]
    #[doc = " cancel the request immediately."]
    #[doc = ""]
    pub get_auth_credentials: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            origin_url: *const cef_string_t,
            isProxy: ::std::os::raw::c_int,
            host: *const cef_string_t,
            port: ::std::os::raw::c_int,
            realm: *const cef_string_t,
            scheme: *const cef_string_t,
            callback: *mut _cef_auth_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the IO thread when JavaScript requests a specific storage quota"]
    #[doc = " size via the webkitStorageInfo.requestQuota function. |origin_url| is the"]
    #[doc = " origin of the page making the request. |new_size| is the requested quota"]
    #[doc = " size in bytes. Return true (1) to continue the request and call"]
    #[doc = " cef_callback_t functions either in this function or at a later time to"]
    #[doc = " grant or deny the request. Return false (0) to cancel the request"]
    #[doc = " immediately."]
    #[doc = ""]
    pub on_quota_request: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            origin_url: *const cef_string_t,
            new_size: int64,
            callback: *mut _cef_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the UI thread to handle requests for URLs with an invalid SSL"]
    #[doc = " certificate. Return true (1) and call cef_callback_t functions either in"]
    #[doc = " this function or at a later time to continue or cancel the request. Return"]
    #[doc = " false (0) to cancel the request immediately. If"]
    #[doc = " cef_settings_t.ignore_certificate_errors is set all invalid certificates"]
    #[doc = " will be accepted without calling this function."]
    #[doc = ""]
    pub on_certificate_error: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            cert_error: cef_errorcode_t,
            request_url: *const cef_string_t,
            ssl_info: *mut _cef_sslinfo_t,
            callback: *mut _cef_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the UI thread when a client certificate is being requested for"]
    #[doc = " authentication. Return false (0) to use the default behavior and"]
    #[doc = " automatically select the first certificate available. Return true (1) and"]
    #[doc = " call cef_select_client_certificate_callback_t::Select either in this"]
    #[doc = " function or at a later time to select a certificate. Do not call Select or"]
    #[doc = " call it with NULL to continue without using any certificate. |isProxy|"]
    #[doc = " indicates whether the host is an HTTPS proxy or the origin server. |host|"]
    #[doc = " and |port| contains the hostname and port of the SSL server."]
    #[doc = " |certificates| is the list of certificates to choose from; this list has"]
    #[doc = " already been pruned by Chromium so that it only contains certificates from"]
    #[doc = " issuers that the server trusts."]
    #[doc = ""]
    pub on_select_client_certificate: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            isProxy: ::std::os::raw::c_int,
            host: *const cef_string_t,
            port: ::std::os::raw::c_int,
            certificatesCount: size_t,
            certificates: *const *mut _cef_x509certificate_t,
            callback: *mut _cef_select_client_certificate_callback_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called on the browser process UI thread when the render view associated"]
    #[doc = " with |browser| is ready to receive/handle IPC messages in the render"]
    #[doc = " process."]
    #[doc = ""]
    pub on_render_view_ready: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_handler_t, browser: *mut _cef_browser_t),
    >,
    #[doc = ""]
    #[doc = " Called on the browser process UI thread when the render process terminates"]
    #[doc = " unexpectedly. |status| indicates how the process terminated."]
    #[doc = ""]
    pub on_render_process_terminated: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_request_handler_t,
            browser: *mut _cef_browser_t,
            status: cef_termination_status_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called on the browser process UI thread when the window.document object of"]
    #[doc = " the main frame has been created."]
    #[doc = ""]
    pub on_document_available_in_main_frame: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_request_handler_t, browser: *mut _cef_browser_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_request_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_request_handler_t>(),
        120usize,
        concat!("Size of: ", stringify!(_cef_request_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_request_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_request_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_before_browse() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_before_browse) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_handler_t),
                "::",
                stringify!(on_before_browse)
            )
        );
    }
    test_field_on_before_browse();
    fn test_field_on_open_urlfrom_tab() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_open_urlfrom_tab) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_handler_t),
                "::",
                stringify!(on_open_urlfrom_tab)
            )
        );
    }
    test_field_on_open_urlfrom_tab();
    fn test_field_get_resource_request_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_resource_request_handler) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_handler_t),
                "::",
                stringify!(get_resource_request_handler)
            )
        );
    }
    test_field_get_resource_request_handler();
    fn test_field_get_auth_credentials() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_auth_credentials) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_handler_t),
                "::",
                stringify!(get_auth_credentials)
            )
        );
    }
    test_field_get_auth_credentials();
    fn test_field_on_quota_request() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_quota_request) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_handler_t),
                "::",
                stringify!(on_quota_request)
            )
        );
    }
    test_field_on_quota_request();
    fn test_field_on_certificate_error() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_certificate_error) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_handler_t),
                "::",
                stringify!(on_certificate_error)
            )
        );
    }
    test_field_on_certificate_error();
    fn test_field_on_select_client_certificate() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_select_client_certificate) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_handler_t),
                "::",
                stringify!(on_select_client_certificate)
            )
        );
    }
    test_field_on_select_client_certificate();
    fn test_field_on_render_view_ready() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_render_view_ready) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_handler_t),
                "::",
                stringify!(on_render_view_ready)
            )
        );
    }
    test_field_on_render_view_ready();
    fn test_field_on_render_process_terminated() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_render_process_terminated) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_handler_t),
                "::",
                stringify!(on_render_process_terminated)
            )
        );
    }
    test_field_on_render_process_terminated();
    fn test_field_on_document_available_in_main_frame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_request_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_document_available_in_main_frame) as usize
                    - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_request_handler_t),
                "::",
                stringify!(on_document_available_in_main_frame)
            )
        );
    }
    test_field_on_document_available_in_main_frame();
}
#[doc = ""]
#[doc = " Implement this structure to handle events related to browser requests. The"]
#[doc = " functions of this structure will be called on the thread indicated."]
#[doc = ""]
pub type cef_request_handler_t = _cef_request_handler_t;
#[doc = ""]
#[doc = " Implement this structure to provide handler implementations."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_client_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Return the handler for audio rendering events."]
    #[doc = ""]
    pub get_audio_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_audio_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for commands. If no handler is provided the default"]
    #[doc = " implementation will be used."]
    #[doc = ""]
    pub get_command_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_command_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for context menus. If no handler is provided the"]
    #[doc = " default implementation will be used."]
    #[doc = ""]
    pub get_context_menu_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_context_menu_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for dialogs. If no handler is provided the default"]
    #[doc = " implementation will be used."]
    #[doc = ""]
    pub get_dialog_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_dialog_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for browser display state events."]
    #[doc = ""]
    pub get_display_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_display_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for download events. If no handler is returned"]
    #[doc = " downloads will not be allowed."]
    #[doc = ""]
    pub get_download_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_download_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for drag events."]
    #[doc = ""]
    pub get_drag_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_drag_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for find result events."]
    #[doc = ""]
    pub get_find_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_find_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for focus events."]
    #[doc = ""]
    pub get_focus_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_focus_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for events related to cef_frame_t lifespan. This"]
    #[doc = " function will be called once during cef_browser_t creation and the result"]
    #[doc = " will be cached for performance reasons."]
    #[doc = ""]
    pub get_frame_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_frame_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for permission requests."]
    #[doc = ""]
    pub get_permission_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_permission_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for JavaScript dialogs. If no handler is provided the"]
    #[doc = " default implementation will be used."]
    #[doc = ""]
    pub get_jsdialog_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_jsdialog_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for keyboard events."]
    #[doc = ""]
    pub get_keyboard_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_keyboard_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for browser life span events."]
    #[doc = ""]
    pub get_life_span_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_life_span_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for browser load status events."]
    #[doc = ""]
    pub get_load_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_load_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for printing on Linux. If a print handler is not"]
    #[doc = " provided then printing will not be supported on the Linux platform."]
    #[doc = ""]
    pub get_print_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_print_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for off-screen rendering events."]
    #[doc = ""]
    pub get_render_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_render_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for browser request events."]
    #[doc = ""]
    pub get_request_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_client_t) -> *mut _cef_request_handler_t,
    >,
    #[doc = ""]
    #[doc = " Called when a new message is received from a different process. Return"]
    #[doc = " true (1) if the message was handled or false (0) otherwise.  It is safe to"]
    #[doc = " keep a reference to |message| outside of this callback."]
    #[doc = ""]
    pub on_process_message_received: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_client_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            source_process: cef_process_id_t,
            message: *mut _cef_process_message_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_client_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_client_t>(),
        192usize,
        concat!("Size of: ", stringify!(_cef_client_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_client_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_client_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_audio_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_audio_handler) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_audio_handler)
            )
        );
    }
    test_field_get_audio_handler();
    fn test_field_get_command_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_command_handler) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_command_handler)
            )
        );
    }
    test_field_get_command_handler();
    fn test_field_get_context_menu_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_context_menu_handler) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_context_menu_handler)
            )
        );
    }
    test_field_get_context_menu_handler();
    fn test_field_get_dialog_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_dialog_handler) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_dialog_handler)
            )
        );
    }
    test_field_get_dialog_handler();
    fn test_field_get_display_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_display_handler) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_display_handler)
            )
        );
    }
    test_field_get_display_handler();
    fn test_field_get_download_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_download_handler) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_download_handler)
            )
        );
    }
    test_field_get_download_handler();
    fn test_field_get_drag_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_drag_handler) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_drag_handler)
            )
        );
    }
    test_field_get_drag_handler();
    fn test_field_get_find_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_find_handler) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_find_handler)
            )
        );
    }
    test_field_get_find_handler();
    fn test_field_get_focus_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_focus_handler) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_focus_handler)
            )
        );
    }
    test_field_get_focus_handler();
    fn test_field_get_frame_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_frame_handler) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_frame_handler)
            )
        );
    }
    test_field_get_frame_handler();
    fn test_field_get_permission_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_permission_handler) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_permission_handler)
            )
        );
    }
    test_field_get_permission_handler();
    fn test_field_get_jsdialog_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_jsdialog_handler) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_jsdialog_handler)
            )
        );
    }
    test_field_get_jsdialog_handler();
    fn test_field_get_keyboard_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_keyboard_handler) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_keyboard_handler)
            )
        );
    }
    test_field_get_keyboard_handler();
    fn test_field_get_life_span_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_life_span_handler) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_life_span_handler)
            )
        );
    }
    test_field_get_life_span_handler();
    fn test_field_get_load_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_load_handler) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_load_handler)
            )
        );
    }
    test_field_get_load_handler();
    fn test_field_get_print_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_print_handler) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_print_handler)
            )
        );
    }
    test_field_get_print_handler();
    fn test_field_get_render_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_render_handler) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_render_handler)
            )
        );
    }
    test_field_get_render_handler();
    fn test_field_get_request_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_request_handler) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(get_request_handler)
            )
        );
    }
    test_field_get_request_handler();
    fn test_field_on_process_message_received() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_client_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_process_message_received) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_client_t),
                "::",
                stringify!(on_process_message_received)
            )
        );
    }
    test_field_on_process_message_received();
}
#[doc = ""]
#[doc = " Implement this structure to provide handler implementations."]
#[doc = ""]
pub type cef_client_t = _cef_client_t;
#[doc = ""]
#[doc = " Structure used to create and/or parse command line arguments. Arguments with"]
#[doc = " \"--\", \"-\" and, on Windows, \"/\" prefixes are considered switches. Switches"]
#[doc = " will always precede any arguments without switch prefixes. Switches can"]
#[doc = " optionally have a value specified using the \"=\" delimiter (e.g."]
#[doc = " \"-switch=value\"). An argument of \"--\" will terminate switch parsing with all"]
#[doc = " subsequent tokens, regardless of prefix, being interpreted as non-switch"]
#[doc = " arguments. Switch names should be lowercase ASCII and will be converted to"]
#[doc = " such if necessary. Switch values will retain the original case and UTF8"]
#[doc = " encoding. This structure can be used before cef_initialize() is called."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_command_line_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is valid. Do not call any other functions"]
    #[doc = " if this function returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the values of this object are read-only. Some APIs may"]
    #[doc = " expose read-only objects."]
    #[doc = ""]
    pub is_read_only: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns a writable copy of this object."]
    #[doc = ""]
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> *mut _cef_command_line_t,
    >,
    #[doc = ""]
    #[doc = " Initialize the command line with the specified |argc| and |argv| values."]
    #[doc = " The first argument must be the name of the program. This function is only"]
    #[doc = " supported on non-Windows platforms."]
    #[doc = ""]
    pub init_from_argv: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            argc: ::std::os::raw::c_int,
            argv: *const *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = ""]
    #[doc = " Initialize the command line with the string returned by calling"]
    #[doc = " GetCommandLineW(). This function is only supported on Windows."]
    #[doc = ""]
    pub init_from_string: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, command_line: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Reset the command-line switches and arguments but leave the program"]
    #[doc = " component unchanged."]
    #[doc = ""]
    pub reset: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_command_line_t)>,
    #[doc = ""]
    #[doc = " Retrieve the original command line string as a vector of strings. The argv"]
    #[doc = " array: `{ program, [(--|-|/)switch[=value]]*, [--], [argument]* }`"]
    #[doc = ""]
    pub get_argv: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, argv: cef_string_list_t),
    >,
    #[doc = ""]
    #[doc = " Constructs and returns the represented command line string. Use this"]
    #[doc = " function cautiously because quoting behavior is unclear."]
    #[doc = ""]
    pub get_command_line_string: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Get the program part of the command line string (the first item)."]
    #[doc = ""]
    pub get_program: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Set the program part of the command line string (the first item)."]
    #[doc = ""]
    pub set_program: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, program: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the command line has switches."]
    #[doc = ""]
    pub has_switches: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the command line contains the given switch."]
    #[doc = ""]
    pub has_switch: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            name: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value associated with the given switch. If the switch has no"]
    #[doc = " value or isn't present this function returns the NULL string."]
    #[doc = ""]
    pub get_switch_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            name: *const cef_string_t,
        ) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the map of switch names and values. If a switch has no value an"]
    #[doc = " NULL string is returned."]
    #[doc = ""]
    pub get_switches: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, switches: cef_string_map_t),
    >,
    #[doc = ""]
    #[doc = " Add a switch to the end of the command line. If the switch has no value"]
    #[doc = " pass an NULL value string."]
    #[doc = ""]
    pub append_switch: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, name: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Add a switch with the specified value to the end of the command line."]
    #[doc = ""]
    pub append_switch_with_value: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_command_line_t,
            name: *const cef_string_t,
            value: *const cef_string_t,
        ),
    >,
    #[doc = ""]
    #[doc = " True if there are remaining command line arguments."]
    #[doc = ""]
    pub has_arguments: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Get the remaining command line arguments."]
    #[doc = ""]
    pub get_arguments: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, arguments: cef_string_list_t),
    >,
    #[doc = ""]
    #[doc = " Add an argument to the end of the command line."]
    #[doc = ""]
    pub append_argument: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, argument: *const cef_string_t),
    >,
    #[doc = ""]
    #[doc = " Insert a command before the current command. Common for debuggers, like"]
    #[doc = " \"valgrind\" or \"gdb --args\"."]
    #[doc = ""]
    pub prepend_wrapper: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_command_line_t, wrapper: *const cef_string_t),
    >,
}
#[test]
fn bindgen_test_layout__cef_command_line_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_command_line_t>(),
        200usize,
        concat!("Size of: ", stringify!(_cef_command_line_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_command_line_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_command_line_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_is_read_only() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_read_only) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(is_read_only)
            )
        );
    }
    test_field_is_read_only();
    fn test_field_copy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).copy) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(copy)
            )
        );
    }
    test_field_copy();
    fn test_field_init_from_argv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init_from_argv) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(init_from_argv)
            )
        );
    }
    test_field_init_from_argv();
    fn test_field_init_from_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).init_from_string) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(init_from_string)
            )
        );
    }
    test_field_init_from_string();
    fn test_field_reset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reset) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(reset)
            )
        );
    }
    test_field_reset();
    fn test_field_get_argv() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_argv) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(get_argv)
            )
        );
    }
    test_field_get_argv();
    fn test_field_get_command_line_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_command_line_string) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(get_command_line_string)
            )
        );
    }
    test_field_get_command_line_string();
    fn test_field_get_program() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_program) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(get_program)
            )
        );
    }
    test_field_get_program();
    fn test_field_set_program() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_program) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(set_program)
            )
        );
    }
    test_field_set_program();
    fn test_field_has_switches() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_switches) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(has_switches)
            )
        );
    }
    test_field_has_switches();
    fn test_field_has_switch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_switch) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(has_switch)
            )
        );
    }
    test_field_has_switch();
    fn test_field_get_switch_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_switch_value) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(get_switch_value)
            )
        );
    }
    test_field_get_switch_value();
    fn test_field_get_switches() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_switches) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(get_switches)
            )
        );
    }
    test_field_get_switches();
    fn test_field_append_switch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).append_switch) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(append_switch)
            )
        );
    }
    test_field_append_switch();
    fn test_field_append_switch_with_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).append_switch_with_value) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(append_switch_with_value)
            )
        );
    }
    test_field_append_switch_with_value();
    fn test_field_has_arguments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_arguments) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(has_arguments)
            )
        );
    }
    test_field_has_arguments();
    fn test_field_get_arguments() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_arguments) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(get_arguments)
            )
        );
    }
    test_field_get_arguments();
    fn test_field_append_argument() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).append_argument) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(append_argument)
            )
        );
    }
    test_field_append_argument();
    fn test_field_prepend_wrapper() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_command_line_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).prepend_wrapper) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_command_line_t),
                "::",
                stringify!(prepend_wrapper)
            )
        );
    }
    test_field_prepend_wrapper();
}
#[doc = ""]
#[doc = " Structure used to create and/or parse command line arguments. Arguments with"]
#[doc = " \"--\", \"-\" and, on Windows, \"/\" prefixes are considered switches. Switches"]
#[doc = " will always precede any arguments without switch prefixes. Switches can"]
#[doc = " optionally have a value specified using the \"=\" delimiter (e.g."]
#[doc = " \"-switch=value\"). An argument of \"--\" will terminate switch parsing with all"]
#[doc = " subsequent tokens, regardless of prefix, being interpreted as non-switch"]
#[doc = " arguments. Switch names should be lowercase ASCII and will be converted to"]
#[doc = " such if necessary. Switch values will retain the original case and UTF8"]
#[doc = " encoding. This structure can be used before cef_initialize() is called."]
#[doc = ""]
pub type cef_command_line_t = _cef_command_line_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_command_line_t instance."]
    #[doc = ""]
    pub fn cef_command_line_create() -> *mut cef_command_line_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns the singleton global cef_command_line_t object. The returned object"]
    #[doc = " will be read-only."]
    #[doc = ""]
    pub fn cef_command_line_get_global() -> *mut cef_command_line_t;
}
#[doc = ""]
#[doc = " Structure used to implement browser process callbacks. The functions of this"]
#[doc = " structure will be called on the browser process main thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_browser_process_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called on the browser process UI thread immediately after the CEF context"]
    #[doc = " has been initialized."]
    #[doc = ""]
    pub on_context_initialized:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_browser_process_handler_t)>,
    #[doc = ""]
    #[doc = " Called before a child process is launched. Will be called on the browser"]
    #[doc = " process UI thread when launching a render process and on the browser"]
    #[doc = " process IO thread when launching a GPU process. Provides an opportunity to"]
    #[doc = " modify the child process command line. Do not keep a reference to"]
    #[doc = " |command_line| outside of this function."]
    #[doc = ""]
    pub on_before_child_process_launch: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_browser_process_handler_t,
            command_line: *mut _cef_command_line_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called from any thread when work has been scheduled for the browser"]
    #[doc = " process main (UI) thread. This callback is used in combination with"]
    #[doc = " cef_settings_t.external_message_pump and cef_do_message_loop_work() in"]
    #[doc = " cases where the CEF message loop must be integrated into an existing"]
    #[doc = " application message loop (see additional comments and warnings on"]
    #[doc = " CefDoMessageLoopWork). This callback should schedule a"]
    #[doc = " cef_do_message_loop_work() call to happen on the main (UI) thread."]
    #[doc = " |delay_ms| is the requested delay in milliseconds. If |delay_ms| is <= 0"]
    #[doc = " then the call should happen reasonably soon. If |delay_ms| is > 0 then the"]
    #[doc = " call should be scheduled to happen after the specified delay and any"]
    #[doc = " currently pending scheduled call should be cancelled."]
    #[doc = ""]
    pub on_schedule_message_pump_work: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_process_handler_t, delay_ms: int64),
    >,
    #[doc = ""]
    #[doc = " Return the default client for use with a newly created browser window. If"]
    #[doc = " null is returned the browser will be unmanaged (no callbacks will be"]
    #[doc = " executed for that browser) and application shutdown will be blocked until"]
    #[doc = " the browser window is closed manually. This function is currently only"]
    #[doc = " used with the chrome runtime."]
    #[doc = ""]
    pub get_default_client: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_browser_process_handler_t) -> *mut _cef_client_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_browser_process_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_browser_process_handler_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_browser_process_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_browser_process_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_browser_process_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_process_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_context_initialized() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_context_initialized) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_process_handler_t),
                "::",
                stringify!(on_context_initialized)
            )
        );
    }
    test_field_on_context_initialized();
    fn test_field_on_before_child_process_launch() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_before_child_process_launch) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_process_handler_t),
                "::",
                stringify!(on_before_child_process_launch)
            )
        );
    }
    test_field_on_before_child_process_launch();
    fn test_field_on_schedule_message_pump_work() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_schedule_message_pump_work) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_process_handler_t),
                "::",
                stringify!(on_schedule_message_pump_work)
            )
        );
    }
    test_field_on_schedule_message_pump_work();
    fn test_field_get_default_client() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_browser_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_default_client) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_browser_process_handler_t),
                "::",
                stringify!(get_default_client)
            )
        );
    }
    test_field_get_default_client();
}
#[doc = ""]
#[doc = " Structure used to implement browser process callbacks. The functions of this"]
#[doc = " structure will be called on the browser process main thread unless otherwise"]
#[doc = " indicated."]
#[doc = ""]
pub type cef_browser_process_handler_t = _cef_browser_process_handler_t;
#[doc = ""]
#[doc = " Implement this structure for asynchronous task execution. If the task is"]
#[doc = " posted successfully and if the associated message loop is still running then"]
#[doc = " the execute() function will be called on the target thread. If the task"]
#[doc = " fails to post then the task object may be destroyed on the source thread"]
#[doc = " instead of the target thread. For this reason be cautious when performing"]
#[doc = " work in the task object destructor."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_task_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Method that will be executed on the target thread."]
    #[doc = ""]
    pub execute: ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_task_t)>,
}
#[test]
fn bindgen_test_layout__cef_task_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_task_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_task_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_task_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_task_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_task_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_execute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_task_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).execute) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_task_t),
                "::",
                stringify!(execute)
            )
        );
    }
    test_field_execute();
}
#[doc = ""]
#[doc = " Implement this structure for asynchronous task execution. If the task is"]
#[doc = " posted successfully and if the associated message loop is still running then"]
#[doc = " the execute() function will be called on the target thread. If the task"]
#[doc = " fails to post then the task object may be destroyed on the source thread"]
#[doc = " instead of the target thread. For this reason be cautious when performing"]
#[doc = " work in the task object destructor."]
#[doc = ""]
pub type cef_task_t = _cef_task_t;
#[doc = ""]
#[doc = " Structure that asynchronously executes tasks on the associated thread. It is"]
#[doc = " safe to call the functions of this structure on any thread."]
#[doc = ""]
#[doc = " CEF maintains multiple internal threads that are used for handling different"]
#[doc = " types of tasks in different processes. The cef_thread_id_t definitions in"]
#[doc = " cef_types.h list the common CEF threads. Task runners are also available for"]
#[doc = " other CEF threads as appropriate (for example, V8 WebWorker threads)."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_task_runner_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same task runner as"]
    #[doc = " |that| object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            that: *mut _cef_task_runner_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this task runner belongs to the current thread."]
    #[doc = ""]
    pub belongs_to_current_thread: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_task_runner_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this task runner is for the specified CEF thread."]
    #[doc = ""]
    pub belongs_to_thread: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            threadId: cef_thread_id_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Post a task for execution on the thread associated with this task runner."]
    #[doc = " Execution will occur asynchronously."]
    #[doc = ""]
    pub post_task: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            task: *mut _cef_task_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Post a task for delayed execution on the thread associated with this task"]
    #[doc = " runner. Execution will occur asynchronously. Delayed tasks are not"]
    #[doc = " supported on V8 WebWorker threads and will be executed without the"]
    #[doc = " specified delay."]
    #[doc = ""]
    pub post_delayed_task: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_task_runner_t,
            task: *mut _cef_task_t,
            delay_ms: int64,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_task_runner_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_task_runner_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_task_runner_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_task_runner_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_task_runner_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_task_runner_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_task_runner_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_task_runner_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_task_runner_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_belongs_to_current_thread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_task_runner_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).belongs_to_current_thread) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_task_runner_t),
                "::",
                stringify!(belongs_to_current_thread)
            )
        );
    }
    test_field_belongs_to_current_thread();
    fn test_field_belongs_to_thread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_task_runner_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).belongs_to_thread) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_task_runner_t),
                "::",
                stringify!(belongs_to_thread)
            )
        );
    }
    test_field_belongs_to_thread();
    fn test_field_post_task() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_task_runner_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).post_task) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_task_runner_t),
                "::",
                stringify!(post_task)
            )
        );
    }
    test_field_post_task();
    fn test_field_post_delayed_task() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_task_runner_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).post_delayed_task) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_task_runner_t),
                "::",
                stringify!(post_delayed_task)
            )
        );
    }
    test_field_post_delayed_task();
}
#[doc = ""]
#[doc = " Structure that asynchronously executes tasks on the associated thread. It is"]
#[doc = " safe to call the functions of this structure on any thread."]
#[doc = ""]
#[doc = " CEF maintains multiple internal threads that are used for handling different"]
#[doc = " types of tasks in different processes. The cef_thread_id_t definitions in"]
#[doc = " cef_types.h list the common CEF threads. Task runners are also available for"]
#[doc = " other CEF threads as appropriate (for example, V8 WebWorker threads)."]
#[doc = ""]
pub type cef_task_runner_t = _cef_task_runner_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns the task runner for the current thread. Only CEF threads will have"]
    #[doc = " task runners. An NULL reference will be returned if this function is called"]
    #[doc = " on an invalid thread."]
    #[doc = ""]
    pub fn cef_task_runner_get_for_current_thread() -> *mut cef_task_runner_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns the task runner for the specified CEF thread."]
    #[doc = ""]
    pub fn cef_task_runner_get_for_thread(threadId: cef_thread_id_t) -> *mut cef_task_runner_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns true (1) if called on the specified thread. Equivalent to using"]
    #[doc = " cef_task_runner_t::GetForThread(threadId)->belongs_to_current_thread()."]
    #[doc = ""]
    pub fn cef_currently_on(threadId: cef_thread_id_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Post a task for execution on the specified thread. Equivalent to using"]
    #[doc = " cef_task_runner_t::GetForThread(threadId)->PostTask(task)."]
    #[doc = ""]
    pub fn cef_post_task(threadId: cef_thread_id_t, task: *mut cef_task_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Post a task for delayed execution on the specified thread. Equivalent to"]
    #[doc = " using cef_task_runner_t::GetForThread(threadId)->PostDelayedTask(task,"]
    #[doc = " delay_ms)."]
    #[doc = ""]
    pub fn cef_post_delayed_task(
        threadId: cef_thread_id_t,
        task: *mut cef_task_t,
        delay_ms: int64,
    ) -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " Structure representing a V8 context handle. V8 handles can only be accessed"]
#[doc = " from the thread on which they are created. Valid threads for creating a V8"]
#[doc = " handle include the render process main thread (TID_RENDERER) and WebWorker"]
#[doc = " threads. A task runner for posting tasks on the associated thread can be"]
#[doc = " retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8context_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the task runner associated with this context. V8 handles can only"]
    #[doc = " be accessed from the thread on which they are created. This function can"]
    #[doc = " be called on any render process thread."]
    #[doc = ""]
    pub get_task_runner: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_task_runner_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying handle is valid and it can be accessed"]
    #[doc = " on the current thread. Do not call any other functions if this function"]
    #[doc = " returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the browser for this context. This function will return an NULL"]
    #[doc = " reference for WebWorker contexts."]
    #[doc = ""]
    pub get_browser: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_browser_t,
    >,
    #[doc = ""]
    #[doc = " Returns the frame for this context. This function will return an NULL"]
    #[doc = " reference for WebWorker contexts."]
    #[doc = ""]
    pub get_frame: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_frame_t,
    >,
    #[doc = ""]
    #[doc = " Returns the global object for this context. The context must be entered"]
    #[doc = " before calling this function."]
    #[doc = ""]
    pub get_global: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> *mut _cef_v8value_t,
    >,
    #[doc = ""]
    #[doc = " Enter this context. A context must be explicitly entered before creating a"]
    #[doc = " V8 Object, Array, Function or Date asynchronously. exit() must be called"]
    #[doc = " the same number of times as enter() before releasing this context. V8"]
    #[doc = " objects belong to the context in which they are created. Returns true (1)"]
    #[doc = " if the scope was entered successfully."]
    #[doc = ""]
    pub enter: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Exit this context. Call this function only after calling enter(). Returns"]
    #[doc = " true (1) if the scope was exited successfully."]
    #[doc = ""]
    pub exit: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8context_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same handle as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8context_t,
            that: *mut _cef_v8context_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Execute a string of JavaScript code in this V8 context. The |script_url|"]
    #[doc = " parameter is the URL where the script in question can be found, if any."]
    #[doc = " The |start_line| parameter is the base line number to use for error"]
    #[doc = " reporting. On success |retval| will be set to the return value, if any,"]
    #[doc = " and the function will return true (1). On failure |exception| will be set"]
    #[doc = " to the exception, if any, and the function will return false (0)."]
    #[doc = ""]
    pub eval: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8context_t,
            code: *const cef_string_t,
            script_url: *const cef_string_t,
            start_line: ::std::os::raw::c_int,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut *mut _cef_v8exception_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8context_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_v8context_t>(),
        112usize,
        concat!("Size of: ", stringify!(_cef_v8context_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_v8context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8context_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8context_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_task_runner() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_task_runner) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8context_t),
                "::",
                stringify!(get_task_runner)
            )
        );
    }
    test_field_get_task_runner();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8context_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_get_browser() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_browser) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8context_t),
                "::",
                stringify!(get_browser)
            )
        );
    }
    test_field_get_browser();
    fn test_field_get_frame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_frame) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8context_t),
                "::",
                stringify!(get_frame)
            )
        );
    }
    test_field_get_frame();
    fn test_field_get_global() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_global) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8context_t),
                "::",
                stringify!(get_global)
            )
        );
    }
    test_field_get_global();
    fn test_field_enter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).enter) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8context_t),
                "::",
                stringify!(enter)
            )
        );
    }
    test_field_enter();
    fn test_field_exit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).exit) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8context_t),
                "::",
                stringify!(exit)
            )
        );
    }
    test_field_exit();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8context_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_eval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8context_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).eval) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8context_t),
                "::",
                stringify!(eval)
            )
        );
    }
    test_field_eval();
}
#[doc = ""]
#[doc = " Structure representing a V8 context handle. V8 handles can only be accessed"]
#[doc = " from the thread on which they are created. Valid threads for creating a V8"]
#[doc = " handle include the render process main thread (TID_RENDERER) and WebWorker"]
#[doc = " threads. A task runner for posting tasks on the associated thread can be"]
#[doc = " retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
pub type cef_v8context_t = _cef_v8context_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns the current (top) context object in the V8 context stack."]
    #[doc = ""]
    pub fn cef_v8context_get_current_context() -> *mut cef_v8context_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns the entered (bottom) context object in the V8 context stack."]
    #[doc = ""]
    pub fn cef_v8context_get_entered_context() -> *mut cef_v8context_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Returns true (1) if V8 is currently inside a context."]
    #[doc = ""]
    pub fn cef_v8context_in_context() -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 function calls. The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Handle execution of the function identified by |name|. |object| is the"]
    #[doc = " receiver ('this' object) of the function. |arguments| is the list of"]
    #[doc = " arguments passed to the function. If execution succeeds set |retval| to"]
    #[doc = " the function return value. If execution fails set |exception| to the"]
    #[doc = " exception that will be thrown. Return true (1) if execution was handled."]
    #[doc = ""]
    pub execute: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8handler_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            argumentsCount: size_t,
            arguments: *const *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_v8handler_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_v8handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_v8handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_execute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).execute) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8handler_t),
                "::",
                stringify!(execute)
            )
        );
    }
    test_field_execute();
}
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 function calls. The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 function."]
#[doc = ""]
pub type cef_v8handler_t = _cef_v8handler_t;
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 accessor calls. Accessor"]
#[doc = " identifiers are registered by calling cef_v8value_t::set_value(). The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 accessor."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8accessor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Handle retrieval the accessor value identified by |name|. |object| is the"]
    #[doc = " receiver ('this' object) of the accessor. If retrieval succeeds set"]
    #[doc = " |retval| to the return value. If retrieval fails set |exception| to the"]
    #[doc = " exception that will be thrown. Return true (1) if accessor retrieval was"]
    #[doc = " handled."]
    #[doc = ""]
    pub get: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8accessor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Handle assignment of the accessor value identified by |name|. |object| is"]
    #[doc = " the receiver ('this' object) of the accessor. |value| is the new value"]
    #[doc = " being assigned to the accessor. If assignment fails set |exception| to the"]
    #[doc = " exception that will be thrown. Return true (1) if accessor assignment was"]
    #[doc = " handled."]
    #[doc = ""]
    pub set: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8accessor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            value: *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8accessor_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_v8accessor_t>(),
        56usize,
        concat!("Size of: ", stringify!(_cef_v8accessor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_v8accessor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8accessor_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8accessor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8accessor_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8accessor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8accessor_t),
                "::",
                stringify!(get)
            )
        );
    }
    test_field_get();
    fn test_field_set() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8accessor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8accessor_t),
                "::",
                stringify!(set)
            )
        );
    }
    test_field_set();
}
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 accessor calls. Accessor"]
#[doc = " identifiers are registered by calling cef_v8value_t::set_value(). The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 accessor."]
#[doc = ""]
pub type cef_v8accessor_t = _cef_v8accessor_t;
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 interceptor calls. The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 interceptor. Interceptor's named property handlers (with first argument"]
#[doc = " of type CefString) are called when object is indexed by string. Indexed"]
#[doc = " property handlers (with first argument of type int) are called when object"]
#[doc = " is indexed by integer."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8interceptor_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Handle retrieval of the interceptor value identified by |name|. |object|"]
    #[doc = " is the receiver ('this' object) of the interceptor. If retrieval succeeds,"]
    #[doc = " set |retval| to the return value. If the requested value does not exist,"]
    #[doc = " don't set either |retval| or |exception|. If retrieval fails, set"]
    #[doc = " |exception| to the exception that will be thrown. If the property has an"]
    #[doc = " associated accessor, it will be called only if you don't set |retval|."]
    #[doc = " Return true (1) if interceptor retrieval was handled, false (0) otherwise."]
    #[doc = ""]
    pub get_byname: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Handle retrieval of the interceptor value identified by |index|. |object|"]
    #[doc = " is the receiver ('this' object) of the interceptor. If retrieval succeeds,"]
    #[doc = " set |retval| to the return value. If the requested value does not exist,"]
    #[doc = " don't set either |retval| or |exception|. If retrieval fails, set"]
    #[doc = " |exception| to the exception that will be thrown. Return true (1) if"]
    #[doc = " interceptor retrieval was handled, false (0) otherwise."]
    #[doc = ""]
    pub get_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            index: ::std::os::raw::c_int,
            object: *mut _cef_v8value_t,
            retval: *mut *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Handle assignment of the interceptor value identified by |name|. |object|"]
    #[doc = " is the receiver ('this' object) of the interceptor. |value| is the new"]
    #[doc = " value being assigned to the interceptor. If assignment fails, set"]
    #[doc = " |exception| to the exception that will be thrown. This setter will always"]
    #[doc = " be called, even when the property has an associated accessor. Return true"]
    #[doc = " (1) if interceptor assignment was handled, false (0) otherwise."]
    #[doc = ""]
    pub set_byname: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            name: *const cef_string_t,
            object: *mut _cef_v8value_t,
            value: *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Handle assignment of the interceptor value identified by |index|. |object|"]
    #[doc = " is the receiver ('this' object) of the interceptor. |value| is the new"]
    #[doc = " value being assigned to the interceptor. If assignment fails, set"]
    #[doc = " |exception| to the exception that will be thrown. Return true (1) if"]
    #[doc = " interceptor assignment was handled, false (0) otherwise."]
    #[doc = ""]
    pub set_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8interceptor_t,
            index: ::std::os::raw::c_int,
            object: *mut _cef_v8value_t,
            value: *mut _cef_v8value_t,
            exception: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8interceptor_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_v8interceptor_t>(),
        72usize,
        concat!("Size of: ", stringify!(_cef_v8interceptor_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_v8interceptor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8interceptor_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8interceptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8interceptor_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_byname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8interceptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_byname) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8interceptor_t),
                "::",
                stringify!(get_byname)
            )
        );
    }
    test_field_get_byname();
    fn test_field_get_byindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8interceptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_byindex) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8interceptor_t),
                "::",
                stringify!(get_byindex)
            )
        );
    }
    test_field_get_byindex();
    fn test_field_set_byname() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8interceptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_byname) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8interceptor_t),
                "::",
                stringify!(set_byname)
            )
        );
    }
    test_field_set_byname();
    fn test_field_set_byindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8interceptor_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_byindex) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8interceptor_t),
                "::",
                stringify!(set_byindex)
            )
        );
    }
    test_field_set_byindex();
}
#[doc = ""]
#[doc = " Structure that should be implemented to handle V8 interceptor calls. The"]
#[doc = " functions of this structure will be called on the thread associated with the"]
#[doc = " V8 interceptor. Interceptor's named property handlers (with first argument"]
#[doc = " of type CefString) are called when object is indexed by string. Indexed"]
#[doc = " property handlers (with first argument of type int) are called when object"]
#[doc = " is indexed by integer."]
#[doc = ""]
pub type cef_v8interceptor_t = _cef_v8interceptor_t;
#[doc = ""]
#[doc = " Structure representing a V8 exception. The functions of this structure may"]
#[doc = " be called on any render process thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8exception_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns the exception message."]
    #[doc = ""]
    pub get_message: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the line of source code that the exception occurred within."]
    #[doc = ""]
    pub get_source_line: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the resource name for the script from where the function causing"]
    #[doc = " the error originates."]
    #[doc = ""]
    pub get_script_resource_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the 1-based number of the line where the error occurred or 0 if"]
    #[doc = " the line number is unknown."]
    #[doc = ""]
    pub get_line_number: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the index within the script of the first character where the error"]
    #[doc = " occurred."]
    #[doc = ""]
    pub get_start_position: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the index within the script of the last character where the error"]
    #[doc = " occurred."]
    #[doc = ""]
    pub get_end_position: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the index within the line of the first character where the error"]
    #[doc = " occurred."]
    #[doc = ""]
    pub get_start_column: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the index within the line of the last character where the error"]
    #[doc = " occurred."]
    #[doc = ""]
    pub get_end_column: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8exception_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8exception_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_v8exception_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_v8exception_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_v8exception_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8exception_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8exception_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8exception_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_message() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8exception_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_message) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8exception_t),
                "::",
                stringify!(get_message)
            )
        );
    }
    test_field_get_message();
    fn test_field_get_source_line() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8exception_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_source_line) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8exception_t),
                "::",
                stringify!(get_source_line)
            )
        );
    }
    test_field_get_source_line();
    fn test_field_get_script_resource_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8exception_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_script_resource_name) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8exception_t),
                "::",
                stringify!(get_script_resource_name)
            )
        );
    }
    test_field_get_script_resource_name();
    fn test_field_get_line_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8exception_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_line_number) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8exception_t),
                "::",
                stringify!(get_line_number)
            )
        );
    }
    test_field_get_line_number();
    fn test_field_get_start_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8exception_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_start_position) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8exception_t),
                "::",
                stringify!(get_start_position)
            )
        );
    }
    test_field_get_start_position();
    fn test_field_get_end_position() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8exception_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_end_position) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8exception_t),
                "::",
                stringify!(get_end_position)
            )
        );
    }
    test_field_get_end_position();
    fn test_field_get_start_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8exception_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_start_column) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8exception_t),
                "::",
                stringify!(get_start_column)
            )
        );
    }
    test_field_get_start_column();
    fn test_field_get_end_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8exception_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_end_column) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8exception_t),
                "::",
                stringify!(get_end_column)
            )
        );
    }
    test_field_get_end_column();
}
#[doc = ""]
#[doc = " Structure representing a V8 exception. The functions of this structure may"]
#[doc = " be called on any render process thread."]
#[doc = ""]
pub type cef_v8exception_t = _cef_v8exception_t;
#[doc = ""]
#[doc = " Callback structure that is passed to cef_v8value_t::CreateArrayBuffer."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8array_buffer_release_callback_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called to release |buffer| when the ArrayBuffer JS object is garbage"]
    #[doc = " collected. |buffer| is the value that was passed to CreateArrayBuffer"]
    #[doc = " along with this object."]
    #[doc = ""]
    pub release_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8array_buffer_release_callback_t,
            buffer: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[test]
fn bindgen_test_layout__cef_v8array_buffer_release_callback_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_v8array_buffer_release_callback_t>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_cef_v8array_buffer_release_callback_t)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_v8array_buffer_release_callback_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_cef_v8array_buffer_release_callback_t)
        )
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_cef_v8array_buffer_release_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8array_buffer_release_callback_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_release_buffer() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_cef_v8array_buffer_release_callback_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).release_buffer) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8array_buffer_release_callback_t),
                "::",
                stringify!(release_buffer)
            )
        );
    }
    test_field_release_buffer();
}
#[doc = ""]
#[doc = " Callback structure that is passed to cef_v8value_t::CreateArrayBuffer."]
#[doc = ""]
pub type cef_v8array_buffer_release_callback_t = _cef_v8array_buffer_release_callback_t;
#[doc = ""]
#[doc = " Structure representing a V8 value handle. V8 handles can only be accessed"]
#[doc = " from the thread on which they are created. Valid threads for creating a V8"]
#[doc = " handle include the render process main thread (TID_RENDERER) and WebWorker"]
#[doc = " threads. A task runner for posting tasks on the associated thread can be"]
#[doc = " retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8value_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying handle is valid and it can be accessed"]
    #[doc = " on the current thread. Do not call any other functions if this function"]
    #[doc = " returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is undefined."]
    #[doc = ""]
    pub is_undefined: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is null."]
    #[doc = ""]
    pub is_null: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is bool."]
    #[doc = ""]
    pub is_bool: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is int."]
    #[doc = ""]
    pub is_int: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is unsigned int."]
    #[doc = ""]
    pub is_uint: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is double."]
    #[doc = ""]
    pub is_double: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is Date."]
    #[doc = ""]
    pub is_date: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is string."]
    #[doc = ""]
    pub is_string: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is object."]
    #[doc = ""]
    pub is_object: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is array."]
    #[doc = ""]
    pub is_array: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is an ArrayBuffer."]
    #[doc = ""]
    pub is_array_buffer: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " True if the value type is function."]
    #[doc = ""]
    pub is_function: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object is pointing to the same handle as |that|"]
    #[doc = " object."]
    #[doc = ""]
    pub is_same: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            that: *mut _cef_v8value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return a bool value."]
    #[doc = ""]
    pub get_bool_value: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Return an int value."]
    #[doc = ""]
    pub get_int_value:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> int32>,
    #[doc = ""]
    #[doc = " Return an unsigned int value."]
    #[doc = ""]
    pub get_uint_value:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> uint32>,
    #[doc = ""]
    #[doc = " Return a double value."]
    #[doc = ""]
    pub get_double_value:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> f64>,
    #[doc = ""]
    #[doc = " Return a Date value."]
    #[doc = ""]
    pub get_date_value:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> cef_basetime_t>,
    #[doc = ""]
    #[doc = " Return a string value."]
    #[doc = ""]
    pub get_string_value: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this is a user created object."]
    #[doc = ""]
    pub is_user_created: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the last function call resulted in an exception. This"]
    #[doc = " attribute exists only in the scope of the current CEF value object."]
    #[doc = ""]
    pub has_exception: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the exception resulting from the last function call. This"]
    #[doc = " attribute exists only in the scope of the current CEF value object."]
    #[doc = ""]
    pub get_exception: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> *mut _cef_v8exception_t,
    >,
    #[doc = ""]
    #[doc = " Clears the last exception and returns true (1) on success."]
    #[doc = ""]
    pub clear_exception: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if this object will re-throw future exceptions. This"]
    #[doc = " attribute exists only in the scope of the current CEF value object."]
    #[doc = ""]
    pub will_rethrow_exceptions: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Set whether this object will re-throw future exceptions. By default"]
    #[doc = " exceptions are not re-thrown. If a exception is re-thrown the current"]
    #[doc = " context should not be accessed again until after the exception has been"]
    #[doc = " caught and not re-thrown. Returns true (1) on success. This attribute"]
    #[doc = " exists only in the scope of the current CEF value object."]
    #[doc = ""]
    pub set_rethrow_exceptions: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            rethrow: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the object has a value with the specified identifier."]
    #[doc = ""]
    pub has_value_bykey: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the object has a value with the specified identifier."]
    #[doc = ""]
    pub has_value_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Deletes the value with the specified identifier and returns true (1) on"]
    #[doc = " success. Returns false (0) if this function is called incorrectly or an"]
    #[doc = " exception is thrown. For read-only and don't-delete values this function"]
    #[doc = " will return true (1) even though deletion failed."]
    #[doc = ""]
    pub delete_value_bykey: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Deletes the value with the specified identifier and returns true (1) on"]
    #[doc = " success. Returns false (0) if this function is called incorrectly,"]
    #[doc = " deletion fails or an exception is thrown. For read-only and don't-delete"]
    #[doc = " values this function will return true (1) even though deletion failed."]
    #[doc = ""]
    pub delete_value_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the value with the specified identifier on success. Returns NULL"]
    #[doc = " if this function is called incorrectly or an exception is thrown."]
    #[doc = ""]
    pub get_value_bykey: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
        ) -> *mut _cef_v8value_t,
    >,
    #[doc = ""]
    #[doc = " Returns the value with the specified identifier on success. Returns NULL"]
    #[doc = " if this function is called incorrectly or an exception is thrown."]
    #[doc = ""]
    pub get_value_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::std::os::raw::c_int,
        ) -> *mut _cef_v8value_t,
    >,
    #[doc = ""]
    #[doc = " Associates a value with the specified identifier and returns true (1) on"]
    #[doc = " success. Returns false (0) if this function is called incorrectly or an"]
    #[doc = " exception is thrown. For read-only values this function will return true"]
    #[doc = " (1) even though assignment failed."]
    #[doc = ""]
    pub set_value_bykey: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
            value: *mut _cef_v8value_t,
            attribute: cef_v8_propertyattribute_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Associates a value with the specified identifier and returns true (1) on"]
    #[doc = " success. Returns false (0) if this function is called incorrectly or an"]
    #[doc = " exception is thrown. For read-only values this function will return true"]
    #[doc = " (1) even though assignment failed."]
    #[doc = ""]
    pub set_value_byindex: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            index: ::std::os::raw::c_int,
            value: *mut _cef_v8value_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Registers an identifier and returns true (1) on success. Access to the"]
    #[doc = " identifier will be forwarded to the cef_v8accessor_t instance passed to"]
    #[doc = " cef_v8value_t::cef_v8value_create_object(). Returns false (0) if this"]
    #[doc = " function is called incorrectly or an exception is thrown. For read-only"]
    #[doc = " values this function will return true (1) even though assignment failed."]
    #[doc = ""]
    pub set_value_byaccessor: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            key: *const cef_string_t,
            settings: cef_v8_accesscontrol_t,
            attribute: cef_v8_propertyattribute_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Read the keys for the object's values into the specified vector. Integer-"]
    #[doc = " based keys will also be returned as strings."]
    #[doc = ""]
    pub get_keys: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            keys: cef_string_list_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Sets the user data for this object and returns true (1) on success."]
    #[doc = " Returns false (0) if this function is called incorrectly. This function"]
    #[doc = " can only be called on user created objects."]
    #[doc = ""]
    pub set_user_data: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            user_data: *mut _cef_base_ref_counted_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the user data, if any, assigned to this object."]
    #[doc = ""]
    pub get_user_data: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> *mut _cef_base_ref_counted_t,
    >,
    #[doc = ""]
    #[doc = " Returns the amount of externally allocated memory registered for the"]
    #[doc = " object."]
    #[doc = ""]
    pub get_externally_allocated_memory: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Adjusts the amount of registered external memory for the object. Used to"]
    #[doc = " give V8 an indication of the amount of externally allocated memory that is"]
    #[doc = " kept alive by JavaScript objects. V8 uses this information to decide when"]
    #[doc = " to perform global garbage collection. Each cef_v8value_t tracks the amount"]
    #[doc = " of external memory associated with it and automatically decreases the"]
    #[doc = " global total by the appropriate amount on its destruction."]
    #[doc = " |change_in_bytes| specifies the number of bytes to adjust by. This"]
    #[doc = " function returns the number of bytes associated with the object after the"]
    #[doc = " adjustment. This function can only be called on user created objects."]
    #[doc = ""]
    pub adjust_externally_allocated_memory: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            change_in_bytes: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the number of elements in the array."]
    #[doc = ""]
    pub get_array_length: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the ReleaseCallback object associated with the ArrayBuffer or NULL"]
    #[doc = " if the ArrayBuffer was not created with CreateArrayBuffer."]
    #[doc = ""]
    pub get_array_buffer_release_callback: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
        ) -> *mut _cef_v8array_buffer_release_callback_t,
    >,
    #[doc = ""]
    #[doc = " Prevent the ArrayBuffer from using it's memory block by setting the length"]
    #[doc = " to zero. This operation cannot be undone. If the ArrayBuffer was created"]
    #[doc = " with CreateArrayBuffer then"]
    #[doc = " cef_v8array_buffer_release_callback_t::ReleaseBuffer will be called to"]
    #[doc = " release the underlying buffer."]
    #[doc = ""]
    pub neuter_array_buffer: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the function name."]
    #[doc = ""]
    pub get_function_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the function handler or NULL if not a CEF-created function."]
    #[doc = ""]
    pub get_function_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8value_t) -> *mut _cef_v8handler_t,
    >,
    #[doc = ""]
    #[doc = " Execute the function using the current V8 context. This function should"]
    #[doc = " only be called from within the scope of a cef_v8handler_t or"]
    #[doc = " cef_v8accessor_t callback, or in combination with calling enter() and"]
    #[doc = " exit() on a stored cef_v8context_t reference. |object| is the receiver"]
    #[doc = " ('this' object) of the function. If |object| is NULL the current context's"]
    #[doc = " global object will be used. |arguments| is the list of arguments that will"]
    #[doc = " be passed to the function. Returns the function return value on success."]
    #[doc = " Returns NULL if this function is called incorrectly or an exception is"]
    #[doc = " thrown."]
    #[doc = ""]
    pub execute_function: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            object: *mut _cef_v8value_t,
            argumentsCount: size_t,
            arguments: *const *mut _cef_v8value_t,
        ) -> *mut _cef_v8value_t,
    >,
    #[doc = ""]
    #[doc = " Execute the function using the specified V8 context. |object| is the"]
    #[doc = " receiver ('this' object) of the function. If |object| is NULL the"]
    #[doc = " specified context's global object will be used. |arguments| is the list of"]
    #[doc = " arguments that will be passed to the function. Returns the function return"]
    #[doc = " value on success. Returns NULL if this function is called incorrectly or"]
    #[doc = " an exception is thrown."]
    #[doc = ""]
    pub execute_function_with_context: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8value_t,
            context: *mut _cef_v8context_t,
            object: *mut _cef_v8value_t,
            argumentsCount: size_t,
            arguments: *const *mut _cef_v8value_t,
        ) -> *mut _cef_v8value_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8value_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_v8value_t>(),
        416usize,
        concat!("Size of: ", stringify!(_cef_v8value_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_v8value_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8value_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_is_undefined() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_undefined) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_undefined)
            )
        );
    }
    test_field_is_undefined();
    fn test_field_is_null() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_null) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_null)
            )
        );
    }
    test_field_is_null();
    fn test_field_is_bool() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_bool) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_bool)
            )
        );
    }
    test_field_is_bool();
    fn test_field_is_int() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_int) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_int)
            )
        );
    }
    test_field_is_int();
    fn test_field_is_uint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_uint) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_uint)
            )
        );
    }
    test_field_is_uint();
    fn test_field_is_double() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_double) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_double)
            )
        );
    }
    test_field_is_double();
    fn test_field_is_date() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_date) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_date)
            )
        );
    }
    test_field_is_date();
    fn test_field_is_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_string) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_string)
            )
        );
    }
    test_field_is_string();
    fn test_field_is_object() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_object) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_object)
            )
        );
    }
    test_field_is_object();
    fn test_field_is_array() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_array) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_array)
            )
        );
    }
    test_field_is_array();
    fn test_field_is_array_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_array_buffer) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_array_buffer)
            )
        );
    }
    test_field_is_array_buffer();
    fn test_field_is_function() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_function) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_function)
            )
        );
    }
    test_field_is_function();
    fn test_field_is_same() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_same) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_same)
            )
        );
    }
    test_field_is_same();
    fn test_field_get_bool_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_bool_value) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_bool_value)
            )
        );
    }
    test_field_get_bool_value();
    fn test_field_get_int_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_int_value) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_int_value)
            )
        );
    }
    test_field_get_int_value();
    fn test_field_get_uint_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_uint_value) as usize - ptr as usize
            },
            168usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_uint_value)
            )
        );
    }
    test_field_get_uint_value();
    fn test_field_get_double_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_double_value) as usize - ptr as usize
            },
            176usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_double_value)
            )
        );
    }
    test_field_get_double_value();
    fn test_field_get_date_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_date_value) as usize - ptr as usize
            },
            184usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_date_value)
            )
        );
    }
    test_field_get_date_value();
    fn test_field_get_string_value() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_string_value) as usize - ptr as usize
            },
            192usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_string_value)
            )
        );
    }
    test_field_get_string_value();
    fn test_field_is_user_created() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_user_created) as usize - ptr as usize
            },
            200usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(is_user_created)
            )
        );
    }
    test_field_is_user_created();
    fn test_field_has_exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_exception) as usize - ptr as usize
            },
            208usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(has_exception)
            )
        );
    }
    test_field_has_exception();
    fn test_field_get_exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_exception) as usize - ptr as usize
            },
            216usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_exception)
            )
        );
    }
    test_field_get_exception();
    fn test_field_clear_exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).clear_exception) as usize - ptr as usize
            },
            224usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(clear_exception)
            )
        );
    }
    test_field_clear_exception();
    fn test_field_will_rethrow_exceptions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).will_rethrow_exceptions) as usize - ptr as usize
            },
            232usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(will_rethrow_exceptions)
            )
        );
    }
    test_field_will_rethrow_exceptions();
    fn test_field_set_rethrow_exceptions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_rethrow_exceptions) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(set_rethrow_exceptions)
            )
        );
    }
    test_field_set_rethrow_exceptions();
    fn test_field_has_value_bykey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_value_bykey) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(has_value_bykey)
            )
        );
    }
    test_field_has_value_bykey();
    fn test_field_has_value_byindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).has_value_byindex) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(has_value_byindex)
            )
        );
    }
    test_field_has_value_byindex();
    fn test_field_delete_value_bykey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).delete_value_bykey) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(delete_value_bykey)
            )
        );
    }
    test_field_delete_value_bykey();
    fn test_field_delete_value_byindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).delete_value_byindex) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(delete_value_byindex)
            )
        );
    }
    test_field_delete_value_byindex();
    fn test_field_get_value_bykey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_value_bykey) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_value_bykey)
            )
        );
    }
    test_field_get_value_bykey();
    fn test_field_get_value_byindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_value_byindex) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_value_byindex)
            )
        );
    }
    test_field_get_value_byindex();
    fn test_field_set_value_bykey() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_value_bykey) as usize - ptr as usize
            },
            296usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(set_value_bykey)
            )
        );
    }
    test_field_set_value_bykey();
    fn test_field_set_value_byindex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_value_byindex) as usize - ptr as usize
            },
            304usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(set_value_byindex)
            )
        );
    }
    test_field_set_value_byindex();
    fn test_field_set_value_byaccessor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_value_byaccessor) as usize - ptr as usize
            },
            312usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(set_value_byaccessor)
            )
        );
    }
    test_field_set_value_byaccessor();
    fn test_field_get_keys() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_keys) as usize - ptr as usize
            },
            320usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_keys)
            )
        );
    }
    test_field_get_keys();
    fn test_field_set_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).set_user_data) as usize - ptr as usize
            },
            328usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(set_user_data)
            )
        );
    }
    test_field_set_user_data();
    fn test_field_get_user_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_user_data) as usize - ptr as usize
            },
            336usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_user_data)
            )
        );
    }
    test_field_get_user_data();
    fn test_field_get_externally_allocated_memory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_externally_allocated_memory) as usize - ptr as usize
            },
            344usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_externally_allocated_memory)
            )
        );
    }
    test_field_get_externally_allocated_memory();
    fn test_field_adjust_externally_allocated_memory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).adjust_externally_allocated_memory) as usize
                    - ptr as usize
            },
            352usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(adjust_externally_allocated_memory)
            )
        );
    }
    test_field_adjust_externally_allocated_memory();
    fn test_field_get_array_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_array_length) as usize - ptr as usize
            },
            360usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_array_length)
            )
        );
    }
    test_field_get_array_length();
    fn test_field_get_array_buffer_release_callback() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_array_buffer_release_callback) as usize
                    - ptr as usize
            },
            368usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_array_buffer_release_callback)
            )
        );
    }
    test_field_get_array_buffer_release_callback();
    fn test_field_neuter_array_buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).neuter_array_buffer) as usize - ptr as usize
            },
            376usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(neuter_array_buffer)
            )
        );
    }
    test_field_neuter_array_buffer();
    fn test_field_get_function_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_function_name) as usize - ptr as usize
            },
            384usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_function_name)
            )
        );
    }
    test_field_get_function_name();
    fn test_field_get_function_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_function_handler) as usize - ptr as usize
            },
            392usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(get_function_handler)
            )
        );
    }
    test_field_get_function_handler();
    fn test_field_execute_function() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).execute_function) as usize - ptr as usize
            },
            400usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(execute_function)
            )
        );
    }
    test_field_execute_function();
    fn test_field_execute_function_with_context() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8value_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).execute_function_with_context) as usize - ptr as usize
            },
            408usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8value_t),
                "::",
                stringify!(execute_function_with_context)
            )
        );
    }
    test_field_execute_function_with_context();
}
#[doc = ""]
#[doc = " Structure representing a V8 value handle. V8 handles can only be accessed"]
#[doc = " from the thread on which they are created. Valid threads for creating a V8"]
#[doc = " handle include the render process main thread (TID_RENDERER) and WebWorker"]
#[doc = " threads. A task runner for posting tasks on the associated thread can be"]
#[doc = " retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
pub type cef_v8value_t = _cef_v8value_t;
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type undefined."]
    #[doc = ""]
    pub fn cef_v8value_create_undefined() -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type null."]
    #[doc = ""]
    pub fn cef_v8value_create_null() -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type bool."]
    #[doc = ""]
    pub fn cef_v8value_create_bool(value: ::std::os::raw::c_int) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type int."]
    #[doc = ""]
    pub fn cef_v8value_create_int(value: int32) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type unsigned int."]
    #[doc = ""]
    pub fn cef_v8value_create_uint(value: uint32) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type double."]
    #[doc = ""]
    pub fn cef_v8value_create_double(value: f64) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type Date. This function should only be"]
    #[doc = " called from within the scope of a cef_render_process_handler_t,"]
    #[doc = " cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling"]
    #[doc = " enter() and exit() on a stored cef_v8context_t reference."]
    #[doc = ""]
    pub fn cef_v8value_create_date(date: cef_basetime_t) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type string."]
    #[doc = ""]
    pub fn cef_v8value_create_string(value: *const cef_string_t) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type object with optional accessor"]
    #[doc = " and/or interceptor. This function should only be called from within the"]
    #[doc = " scope of a cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t"]
    #[doc = " callback, or in combination with calling enter() and exit() on a stored"]
    #[doc = " cef_v8context_t reference."]
    #[doc = ""]
    pub fn cef_v8value_create_object(
        accessor: *mut cef_v8accessor_t,
        interceptor: *mut cef_v8interceptor_t,
    ) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type array with the specified |length|."]
    #[doc = " If |length| is negative the returned array will have length 0. This function"]
    #[doc = " should only be called from within the scope of a"]
    #[doc = " cef_render_process_handler_t, cef_v8handler_t or cef_v8accessor_t callback,"]
    #[doc = " or in combination with calling enter() and exit() on a stored"]
    #[doc = " cef_v8context_t reference."]
    #[doc = ""]
    pub fn cef_v8value_create_array(length: ::std::os::raw::c_int) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type ArrayBuffer which wraps the"]
    #[doc = " provided |buffer| of size |length| bytes. The ArrayBuffer is externalized,"]
    #[doc = " meaning that it does not own |buffer|. The caller is responsible for freeing"]
    #[doc = " |buffer| when requested via a call to"]
    #[doc = " cef_v8array_buffer_release_callback_t::ReleaseBuffer. This function should"]
    #[doc = " only be called from within the scope of a cef_render_process_handler_t,"]
    #[doc = " cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling"]
    #[doc = " enter() and exit() on a stored cef_v8context_t reference."]
    #[doc = ""]
    pub fn cef_v8value_create_array_buffer(
        buffer: *mut ::std::os::raw::c_void,
        length: size_t,
        release_callback: *mut cef_v8array_buffer_release_callback_t,
    ) -> *mut cef_v8value_t;
}
extern "C" {
    #[doc = ""]
    #[doc = " Create a new cef_v8value_t object of type function. This function should"]
    #[doc = " only be called from within the scope of a cef_render_process_handler_t,"]
    #[doc = " cef_v8handler_t or cef_v8accessor_t callback, or in combination with calling"]
    #[doc = " enter() and exit() on a stored cef_v8context_t reference."]
    #[doc = ""]
    pub fn cef_v8value_create_function(
        name: *const cef_string_t,
        handler: *mut cef_v8handler_t,
    ) -> *mut cef_v8value_t;
}
#[doc = ""]
#[doc = " Structure representing a V8 stack trace handle. V8 handles can only be"]
#[doc = " accessed from the thread on which they are created. Valid threads for"]
#[doc = " creating a V8 handle include the render process main thread (TID_RENDERER)"]
#[doc = " and WebWorker threads. A task runner for posting tasks on the associated"]
#[doc = " thread can be retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8stack_trace_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying handle is valid and it can be accessed"]
    #[doc = " on the current thread. Do not call any other functions if this function"]
    #[doc = " returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_trace_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the number of stack frames."]
    #[doc = ""]
    pub get_frame_count: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_trace_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the stack frame at the specified 0-based index."]
    #[doc = ""]
    pub get_frame: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_v8stack_trace_t,
            index: ::std::os::raw::c_int,
        ) -> *mut _cef_v8stack_frame_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8stack_trace_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_v8stack_trace_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_v8stack_trace_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_v8stack_trace_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8stack_trace_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_trace_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_trace_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_trace_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_trace_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_get_frame_count() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_trace_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_frame_count) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_trace_t),
                "::",
                stringify!(get_frame_count)
            )
        );
    }
    test_field_get_frame_count();
    fn test_field_get_frame() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_trace_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_frame) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_trace_t),
                "::",
                stringify!(get_frame)
            )
        );
    }
    test_field_get_frame();
}
#[doc = ""]
#[doc = " Structure representing a V8 stack trace handle. V8 handles can only be"]
#[doc = " accessed from the thread on which they are created. Valid threads for"]
#[doc = " creating a V8 handle include the render process main thread (TID_RENDERER)"]
#[doc = " and WebWorker threads. A task runner for posting tasks on the associated"]
#[doc = " thread can be retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
pub type cef_v8stack_trace_t = _cef_v8stack_trace_t;
extern "C" {
    #[doc = ""]
    #[doc = " Returns the stack trace for the currently active context. |frame_limit| is"]
    #[doc = " the maximum number of frames that will be captured."]
    #[doc = ""]
    pub fn cef_v8stack_trace_get_current(
        frame_limit: ::std::os::raw::c_int,
    ) -> *mut cef_v8stack_trace_t;
}
#[doc = ""]
#[doc = " Structure representing a V8 stack frame handle. V8 handles can only be"]
#[doc = " accessed from the thread on which they are created. Valid threads for"]
#[doc = " creating a V8 handle include the render process main thread (TID_RENDERER)"]
#[doc = " and WebWorker threads. A task runner for posting tasks on the associated"]
#[doc = " thread can be retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_v8stack_frame_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Returns true (1) if the underlying handle is valid and it can be accessed"]
    #[doc = " on the current thread. Do not call any other functions if this function"]
    #[doc = " returns false (0)."]
    #[doc = ""]
    pub is_valid: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the name of the resource script that contains the function."]
    #[doc = ""]
    pub get_script_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the name of the resource script that contains the function or the"]
    #[doc = " sourceURL value if the script name is undefined and its source ends with a"]
    #[doc = " \"//@ sourceURL=...\" string."]
    #[doc = ""]
    pub get_script_name_or_source_url: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the name of the function."]
    #[doc = ""]
    pub get_function_name: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> cef_string_userfree_t,
    >,
    #[doc = ""]
    #[doc = " Returns the 1-based line number for the function call or 0 if unknown."]
    #[doc = ""]
    pub get_line_number: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns the 1-based column offset on the line for the function call or 0"]
    #[doc = " if unknown."]
    #[doc = ""]
    pub get_column: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the function was compiled using eval()."]
    #[doc = ""]
    pub is_eval: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Returns true (1) if the function was called as a constructor via \"new\"."]
    #[doc = ""]
    pub is_constructor: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_v8stack_frame_t) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_v8stack_frame_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_v8stack_frame_t>(),
        104usize,
        concat!("Size of: ", stringify!(_cef_v8stack_frame_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_v8stack_frame_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_v8stack_frame_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_frame_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_is_valid() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_valid) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_frame_t),
                "::",
                stringify!(is_valid)
            )
        );
    }
    test_field_is_valid();
    fn test_field_get_script_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_script_name) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_frame_t),
                "::",
                stringify!(get_script_name)
            )
        );
    }
    test_field_get_script_name();
    fn test_field_get_script_name_or_source_url() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_script_name_or_source_url) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_frame_t),
                "::",
                stringify!(get_script_name_or_source_url)
            )
        );
    }
    test_field_get_script_name_or_source_url();
    fn test_field_get_function_name() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_function_name) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_frame_t),
                "::",
                stringify!(get_function_name)
            )
        );
    }
    test_field_get_function_name();
    fn test_field_get_line_number() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_line_number) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_frame_t),
                "::",
                stringify!(get_line_number)
            )
        );
    }
    test_field_get_line_number();
    fn test_field_get_column() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_column) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_frame_t),
                "::",
                stringify!(get_column)
            )
        );
    }
    test_field_get_column();
    fn test_field_is_eval() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_eval) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_frame_t),
                "::",
                stringify!(is_eval)
            )
        );
    }
    test_field_is_eval();
    fn test_field_is_constructor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_v8stack_frame_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).is_constructor) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_v8stack_frame_t),
                "::",
                stringify!(is_constructor)
            )
        );
    }
    test_field_is_constructor();
}
#[doc = ""]
#[doc = " Structure representing a V8 stack frame handle. V8 handles can only be"]
#[doc = " accessed from the thread on which they are created. Valid threads for"]
#[doc = " creating a V8 handle include the render process main thread (TID_RENDERER)"]
#[doc = " and WebWorker threads. A task runner for posting tasks on the associated"]
#[doc = " thread can be retrieved via the cef_v8context_t::get_task_runner() function."]
#[doc = ""]
pub type cef_v8stack_frame_t = _cef_v8stack_frame_t;
extern "C" {
    #[doc = ""]
    #[doc = " Register a new V8 extension with the specified JavaScript extension code and"]
    #[doc = " handler. Functions implemented by the handler are prototyped using the"]
    #[doc = " keyword 'native'. The calling of a native function is restricted to the"]
    #[doc = " scope in which the prototype of the native function is defined. This"]
    #[doc = " function may only be called on the render process main thread."]
    #[doc = ""]
    #[doc = " Example JavaScript extension code: <pre>"]
    #[doc = "   // create the 'example' global object if it doesn't already exist."]
    #[doc = "   if (!example)"]
    #[doc = "     example = {};"]
    #[doc = "   // create the 'example.test' global object if it doesn't already exist."]
    #[doc = "   if (!example.test)"]
    #[doc = "     example.test = {};"]
    #[doc = "   (function() {"]
    #[doc = "     // Define the function 'example.test.myfunction'."]
    #[doc = "     example.test.myfunction = function() {"]
    #[doc = "       // Call CefV8Handler::Execute() with the function name 'MyFunction'"]
    #[doc = "       // and no arguments."]
    #[doc = "       native function MyFunction();"]
    #[doc = "       return MyFunction();"]
    #[doc = "     };"]
    #[doc = "     // Define the getter function for parameter 'example.test.myparam'."]
    #[doc = "     example.test.__defineGetter__('myparam', function() {"]
    #[doc = "       // Call CefV8Handler::Execute() with the function name 'GetMyParam'"]
    #[doc = "       // and no arguments."]
    #[doc = "       native function GetMyParam();"]
    #[doc = "       return GetMyParam();"]
    #[doc = "     });"]
    #[doc = "     // Define the setter function for parameter 'example.test.myparam'."]
    #[doc = "     example.test.__defineSetter__('myparam', function(b) {"]
    #[doc = "       // Call CefV8Handler::Execute() with the function name 'SetMyParam'"]
    #[doc = "       // and a single argument."]
    #[doc = "       native function SetMyParam();"]
    #[doc = "       if(b) SetMyParam(b);"]
    #[doc = "     });"]
    #[doc = ""]
    #[doc = "     // Extension definitions can also contain normal JavaScript variables"]
    #[doc = "     // and functions."]
    #[doc = "     var myint = 0;"]
    #[doc = "     example.test.increment = function() {"]
    #[doc = "       myint += 1;"]
    #[doc = "       return myint;"]
    #[doc = "     };"]
    #[doc = "   })();"]
    #[doc = " </pre>"]
    #[doc = ""]
    #[doc = " Example usage in the page: <pre>"]
    #[doc = "   // Call the function."]
    #[doc = "   example.test.myfunction();"]
    #[doc = "   // Set the parameter."]
    #[doc = "   example.test.myparam = value;"]
    #[doc = "   // Get the parameter."]
    #[doc = "   value = example.test.myparam;"]
    #[doc = "   // Call another function."]
    #[doc = "   example.test.increment();"]
    #[doc = " </pre>"]
    #[doc = ""]
    pub fn cef_register_extension(
        extension_name: *const cef_string_t,
        javascript_code: *const cef_string_t,
        handler: *mut cef_v8handler_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " Structure used to implement render process callbacks. The functions of this"]
#[doc = " structure will be called on the render process main thread (TID_RENDERER)"]
#[doc = " unless otherwise indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_render_process_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called after WebKit has been initialized."]
    #[doc = ""]
    pub on_web_kit_initialized:
        ::std::option::Option<unsafe extern "C" fn(self_: *mut _cef_render_process_handler_t)>,
    #[doc = ""]
    #[doc = " Called after a browser has been created. When browsing cross-origin a new"]
    #[doc = " browser will be created before the old browser with the same identifier is"]
    #[doc = " destroyed. |extra_info| is an optional read-only value originating from"]
    #[doc = " cef_browser_host_t::cef_browser_host_create_browser(),"]
    #[doc = " cef_browser_host_t::cef_browser_host_create_browser_sync(),"]
    #[doc = " cef_life_span_handler_t::on_before_popup() or"]
    #[doc = " cef_browser_view_t::cef_browser_view_create()."]
    #[doc = ""]
    pub on_browser_created: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            extra_info: *mut _cef_dictionary_value_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called before a browser is destroyed."]
    #[doc = ""]
    pub on_browser_destroyed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Return the handler for browser load status events."]
    #[doc = ""]
    pub get_load_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_render_process_handler_t) -> *mut _cef_load_handler_t,
    >,
    #[doc = ""]
    #[doc = " Called immediately after the V8 context for a frame has been created. To"]
    #[doc = " retrieve the JavaScript 'window' object use the"]
    #[doc = " cef_v8context_t::get_global() function. V8 handles can only be accessed"]
    #[doc = " from the thread on which they are created. A task runner for posting tasks"]
    #[doc = " on the associated thread can be retrieved via the"]
    #[doc = " cef_v8context_t::get_task_runner() function."]
    #[doc = ""]
    pub on_context_created: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            context: *mut _cef_v8context_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called immediately before the V8 context for a frame is released. No"]
    #[doc = " references to the context should be kept after this function is called."]
    #[doc = ""]
    pub on_context_released: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            context: *mut _cef_v8context_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called for global uncaught exceptions in a frame. Execution of this"]
    #[doc = " callback is disabled by default. To enable set"]
    #[doc = " cef_settings_t.uncaught_exception_stack_size > 0."]
    #[doc = ""]
    pub on_uncaught_exception: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            context: *mut _cef_v8context_t,
            exception: *mut _cef_v8exception_t,
            stackTrace: *mut _cef_v8stack_trace_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when a new node in the the browser gets focus. The |node| value may"]
    #[doc = " be NULL if no specific node has gained focus. The node object passed to"]
    #[doc = " this function represents a snapshot of the DOM at the time this function"]
    #[doc = " is executed. DOM objects are only valid for the scope of this function. Do"]
    #[doc = " not keep references to or attempt to access any DOM objects outside the"]
    #[doc = " scope of this function."]
    #[doc = ""]
    pub on_focused_node_changed: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            node: *mut _cef_domnode_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Called when a new message is received from a different process. Return"]
    #[doc = " true (1) if the message was handled or false (0) otherwise. It is safe to"]
    #[doc = " keep a reference to |message| outside of this callback."]
    #[doc = ""]
    pub on_process_message_received: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_render_process_handler_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            source_process: cef_process_id_t,
            message: *mut _cef_process_message_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_render_process_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_render_process_handler_t>(),
        112usize,
        concat!("Size of: ", stringify!(_cef_render_process_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_render_process_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_render_process_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_process_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_web_kit_initialized() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_web_kit_initialized) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_process_handler_t),
                "::",
                stringify!(on_web_kit_initialized)
            )
        );
    }
    test_field_on_web_kit_initialized();
    fn test_field_on_browser_created() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_browser_created) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_process_handler_t),
                "::",
                stringify!(on_browser_created)
            )
        );
    }
    test_field_on_browser_created();
    fn test_field_on_browser_destroyed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_browser_destroyed) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_process_handler_t),
                "::",
                stringify!(on_browser_destroyed)
            )
        );
    }
    test_field_on_browser_destroyed();
    fn test_field_get_load_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_load_handler) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_process_handler_t),
                "::",
                stringify!(get_load_handler)
            )
        );
    }
    test_field_get_load_handler();
    fn test_field_on_context_created() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_context_created) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_process_handler_t),
                "::",
                stringify!(on_context_created)
            )
        );
    }
    test_field_on_context_created();
    fn test_field_on_context_released() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_context_released) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_process_handler_t),
                "::",
                stringify!(on_context_released)
            )
        );
    }
    test_field_on_context_released();
    fn test_field_on_uncaught_exception() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_uncaught_exception) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_process_handler_t),
                "::",
                stringify!(on_uncaught_exception)
            )
        );
    }
    test_field_on_uncaught_exception();
    fn test_field_on_focused_node_changed() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_focused_node_changed) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_process_handler_t),
                "::",
                stringify!(on_focused_node_changed)
            )
        );
    }
    test_field_on_focused_node_changed();
    fn test_field_on_process_message_received() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_render_process_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_process_message_received) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_render_process_handler_t),
                "::",
                stringify!(on_process_message_received)
            )
        );
    }
    test_field_on_process_message_received();
}
#[doc = ""]
#[doc = " Structure used to implement render process callbacks. The functions of this"]
#[doc = " structure will be called on the render process main thread (TID_RENDERER)"]
#[doc = " unless otherwise indicated."]
#[doc = ""]
pub type cef_render_process_handler_t = _cef_render_process_handler_t;
#[doc = ""]
#[doc = " Structure used to implement a custom resource bundle structure. See"]
#[doc = " CefSettings for additional options related to resource bundle loading. The"]
#[doc = " functions of this structure may be called on multiple threads."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_resource_bundle_handler_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Called to retrieve a localized translation for the specified |string_id|."]
    #[doc = " To provide the translation set |string| to the translation string and"]
    #[doc = " return true (1). To use the default translation return false (0). Include"]
    #[doc = " cef_pack_strings.h for a listing of valid string ID values."]
    #[doc = ""]
    pub get_localized_string: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_handler_t,
            string_id: ::std::os::raw::c_int,
            string: *mut cef_string_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to retrieve data for the specified scale independent |resource_id|."]
    #[doc = " To provide the resource data set |data| and |data_size| to the data"]
    #[doc = " pointer and size respectively and return true (1). To use the default"]
    #[doc = " resource data return false (0). The resource data will not be copied and"]
    #[doc = " must remain resident in memory. Include cef_pack_resources.h for a listing"]
    #[doc = " of valid resource ID values."]
    #[doc = ""]
    pub get_data_resource: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_handler_t,
            resource_id: ::std::os::raw::c_int,
            data: *mut *mut ::std::os::raw::c_void,
            data_size: *mut size_t,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = ""]
    #[doc = " Called to retrieve data for the specified |resource_id| nearest the scale"]
    #[doc = " factor |scale_factor|. To provide the resource data set |data| and"]
    #[doc = " |data_size| to the data pointer and size respectively and return true (1)."]
    #[doc = " To use the default resource data return false (0). The resource data will"]
    #[doc = " not be copied and must remain resident in memory. Include"]
    #[doc = " cef_pack_resources.h for a listing of valid resource ID values."]
    #[doc = ""]
    pub get_data_resource_for_scale: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_resource_bundle_handler_t,
            resource_id: ::std::os::raw::c_int,
            scale_factor: cef_scale_factor_t,
            data: *mut *mut ::std::os::raw::c_void,
            data_size: *mut size_t,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_resource_bundle_handler_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_resource_bundle_handler_t>(),
        64usize,
        concat!("Size of: ", stringify!(_cef_resource_bundle_handler_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_resource_bundle_handler_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_resource_bundle_handler_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_bundle_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_bundle_handler_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_get_localized_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_bundle_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_localized_string) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_bundle_handler_t),
                "::",
                stringify!(get_localized_string)
            )
        );
    }
    test_field_get_localized_string();
    fn test_field_get_data_resource() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_bundle_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_data_resource) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_bundle_handler_t),
                "::",
                stringify!(get_data_resource)
            )
        );
    }
    test_field_get_data_resource();
    fn test_field_get_data_resource_for_scale() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_resource_bundle_handler_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_data_resource_for_scale) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_resource_bundle_handler_t),
                "::",
                stringify!(get_data_resource_for_scale)
            )
        );
    }
    test_field_get_data_resource_for_scale();
}
#[doc = ""]
#[doc = " Structure used to implement a custom resource bundle structure. See"]
#[doc = " CefSettings for additional options related to resource bundle loading. The"]
#[doc = " functions of this structure may be called on multiple threads."]
#[doc = ""]
pub type cef_resource_bundle_handler_t = _cef_resource_bundle_handler_t;
#[doc = ""]
#[doc = " Structure that manages custom scheme registrations."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_scheme_registrar_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_scoped_t,
    #[doc = ""]
    #[doc = " Register a custom scheme. This function should not be called for the"]
    #[doc = " built-in HTTP, HTTPS, FILE, FTP, ABOUT and DATA schemes."]
    #[doc = ""]
    #[doc = " See cef_scheme_options_t for possible values for |options|."]
    #[doc = ""]
    #[doc = " This function may be called on any thread. It should only be called once"]
    #[doc = " per unique |scheme_name| value. If |scheme_name| is already registered or"]
    #[doc = " if an error occurs this function will return false (0)."]
    #[doc = ""]
    pub add_custom_scheme: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_scheme_registrar_t,
            scheme_name: *const cef_string_t,
            options: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[test]
fn bindgen_test_layout__cef_scheme_registrar_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_scheme_registrar_t>(),
        24usize,
        concat!("Size of: ", stringify!(_cef_scheme_registrar_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_scheme_registrar_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_scheme_registrar_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_scheme_registrar_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_scheme_registrar_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_add_custom_scheme() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_scheme_registrar_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).add_custom_scheme) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_scheme_registrar_t),
                "::",
                stringify!(add_custom_scheme)
            )
        );
    }
    test_field_add_custom_scheme();
}
#[doc = ""]
#[doc = " Structure that manages custom scheme registrations."]
#[doc = ""]
pub type cef_scheme_registrar_t = _cef_scheme_registrar_t;
#[doc = ""]
#[doc = " Structure that creates cef_resource_handler_t instances for handling scheme"]
#[doc = " requests. The functions of this structure will always be called on the IO"]
#[doc = " thread."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_scheme_handler_factory_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Return a new resource handler instance to handle the request or an NULL"]
    #[doc = " reference to allow default handling of the request. |browser| and |frame|"]
    #[doc = " will be the browser window and frame respectively that originated the"]
    #[doc = " request or NULL if the request did not originate from a browser window"]
    #[doc = " (for example, if the request came from cef_urlrequest_t). The |request|"]
    #[doc = " object passed to this function cannot be modified."]
    #[doc = ""]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_scheme_handler_factory_t,
            browser: *mut _cef_browser_t,
            frame: *mut _cef_frame_t,
            scheme_name: *const cef_string_t,
            request: *mut _cef_request_t,
        ) -> *mut _cef_resource_handler_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_scheme_handler_factory_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_scheme_handler_factory_t>(),
        48usize,
        concat!("Size of: ", stringify!(_cef_scheme_handler_factory_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_scheme_handler_factory_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_scheme_handler_factory_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_scheme_handler_factory_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_scheme_handler_factory_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_create() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_scheme_handler_factory_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).create) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_scheme_handler_factory_t),
                "::",
                stringify!(create)
            )
        );
    }
    test_field_create();
}
#[doc = ""]
#[doc = " Structure that creates cef_resource_handler_t instances for handling scheme"]
#[doc = " requests. The functions of this structure will always be called on the IO"]
#[doc = " thread."]
#[doc = ""]
pub type cef_scheme_handler_factory_t = _cef_scheme_handler_factory_t;
extern "C" {
    #[doc = ""]
    #[doc = " Register a scheme handler factory with the global request context. An NULL"]
    #[doc = " |domain_name| value for a standard scheme will cause the factory to match"]
    #[doc = " all domain names. The |domain_name| value will be ignored for non-standard"]
    #[doc = " schemes. If |scheme_name| is a built-in scheme and no handler is returned by"]
    #[doc = " |factory| then the built-in scheme handler factory will be called. If"]
    #[doc = " |scheme_name| is a custom scheme then you must also implement the"]
    #[doc = " cef_app_t::on_register_custom_schemes() function in all processes. This"]
    #[doc = " function may be called multiple times to change or remove the factory that"]
    #[doc = " matches the specified |scheme_name| and optional |domain_name|. Returns"]
    #[doc = " false (0) if an error occurs. This function may be called on any thread in"]
    #[doc = " the browser process. Using this function is equivalent to calling cef_reques"]
    #[doc = " t_context_t::cef_request_context_get_global_context()->register_scheme_handl"]
    #[doc = " er_factory()."]
    #[doc = ""]
    pub fn cef_register_scheme_handler_factory(
        scheme_name: *const cef_string_t,
        domain_name: *const cef_string_t,
        factory: *mut cef_scheme_handler_factory_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " Clear all scheme handler factories registered with the global request"]
    #[doc = " context. Returns false (0) on error. This function may be called on any"]
    #[doc = " thread in the browser process. Using this function is equivalent to calling"]
    #[doc = " cef_request_context_t::cef_request_context_get_global_context()->clear_schem"]
    #[doc = " e_handler_factories()."]
    #[doc = ""]
    pub fn cef_clear_scheme_handler_factories() -> ::std::os::raw::c_int;
}
#[doc = ""]
#[doc = " Implement this structure to provide handler implementations. Methods will be"]
#[doc = " called by the process and/or thread indicated."]
#[doc = ""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cef_app_t {
    #[doc = ""]
    #[doc = " Base structure."]
    #[doc = ""]
    pub base: cef_base_ref_counted_t,
    #[doc = ""]
    #[doc = " Provides an opportunity to view and/or modify command-line arguments"]
    #[doc = " before processing by CEF and Chromium. The |process_type| value will be"]
    #[doc = " NULL for the browser process. Do not keep a reference to the"]
    #[doc = " cef_command_line_t object passed to this function. The"]
    #[doc = " cef_settings_t.command_line_args_disabled value can be used to start with"]
    #[doc = " an NULL command-line object. Any values specified in CefSettings that"]
    #[doc = " equate to command-line arguments will be set before this function is"]
    #[doc = " called. Be cautious when using this function to modify command-line"]
    #[doc = " arguments for non-browser processes as this may result in undefined"]
    #[doc = " behavior including crashes."]
    #[doc = ""]
    pub on_before_command_line_processing: ::std::option::Option<
        unsafe extern "C" fn(
            self_: *mut _cef_app_t,
            process_type: *const cef_string_t,
            command_line: *mut _cef_command_line_t,
        ),
    >,
    #[doc = ""]
    #[doc = " Provides an opportunity to register custom schemes. Do not keep a"]
    #[doc = " reference to the |registrar| object. This function is called on the main"]
    #[doc = " thread for each process and the registered schemes should be the same"]
    #[doc = " across all processes."]
    #[doc = ""]
    pub on_register_custom_schemes: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t, registrar: *mut _cef_scheme_registrar_t),
    >,
    #[doc = ""]
    #[doc = " Return the handler for resource bundle events. If"]
    #[doc = " cef_settings_t.pack_loading_disabled is true (1) a handler must be"]
    #[doc = " returned. If no handler is returned resources will be loaded from pack"]
    #[doc = " files. This function is called by the browser and render processes on"]
    #[doc = " multiple threads."]
    #[doc = ""]
    pub get_resource_bundle_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t) -> *mut _cef_resource_bundle_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for functionality specific to the browser process. This"]
    #[doc = " function is called on multiple threads in the browser process."]
    #[doc = ""]
    pub get_browser_process_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t) -> *mut _cef_browser_process_handler_t,
    >,
    #[doc = ""]
    #[doc = " Return the handler for functionality specific to the render process. This"]
    #[doc = " function is called on the render process main thread."]
    #[doc = ""]
    pub get_render_process_handler: ::std::option::Option<
        unsafe extern "C" fn(self_: *mut _cef_app_t) -> *mut _cef_render_process_handler_t,
    >,
}
#[test]
fn bindgen_test_layout__cef_app_t() {
    assert_eq!(
        ::std::mem::size_of::<_cef_app_t>(),
        80usize,
        concat!("Size of: ", stringify!(_cef_app_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_cef_app_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_cef_app_t))
    );
    fn test_field_base() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_app_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).base) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_app_t),
                "::",
                stringify!(base)
            )
        );
    }
    test_field_base();
    fn test_field_on_before_command_line_processing() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_app_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_before_command_line_processing) as usize
                    - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_app_t),
                "::",
                stringify!(on_before_command_line_processing)
            )
        );
    }
    test_field_on_before_command_line_processing();
    fn test_field_on_register_custom_schemes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_app_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).on_register_custom_schemes) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_app_t),
                "::",
                stringify!(on_register_custom_schemes)
            )
        );
    }
    test_field_on_register_custom_schemes();
    fn test_field_get_resource_bundle_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_app_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_resource_bundle_handler) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_app_t),
                "::",
                stringify!(get_resource_bundle_handler)
            )
        );
    }
    test_field_get_resource_bundle_handler();
    fn test_field_get_browser_process_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_app_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_browser_process_handler) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_app_t),
                "::",
                stringify!(get_browser_process_handler)
            )
        );
    }
    test_field_get_browser_process_handler();
    fn test_field_get_render_process_handler() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_cef_app_t>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).get_render_process_handler) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(_cef_app_t),
                "::",
                stringify!(get_render_process_handler)
            )
        );
    }
    test_field_get_render_process_handler();
}
#[doc = ""]
#[doc = " Implement this structure to provide handler implementations. Methods will be"]
#[doc = " called by the process and/or thread indicated."]
#[doc = ""]
pub type cef_app_t = _cef_app_t;
extern "C" {
    #[doc = ""]
    #[doc = " This function should be called from the application entry point function to"]
    #[doc = " execute a secondary process. It can be used to run secondary processes from"]
    #[doc = " the browser client executable (default behavior) or from a separate"]
    #[doc = " executable specified by the cef_settings_t.browser_subprocess_path value. If"]
    #[doc = " called for the browser process (identified by no \"type\" command-line value)"]
    #[doc = " it will return immediately with a value of -1. If called for a recognized"]
    #[doc = " secondary process it will block until the process should exit and then"]
    #[doc = " return the process exit code. The |application| parameter may be NULL. The"]
    #[doc = " |windows_sandbox_info| parameter is only used on Windows and may be NULL"]
    #[doc = " (see cef_sandbox_win.h for details)."]
    #[doc = ""]
    pub fn cef_execute_process(
        args: *const cef_main_args_t,
        application: *mut cef_app_t,
        windows_sandbox_info: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " This function should be called on the main application thread to initialize"]
    #[doc = " the CEF browser process. The |application| parameter may be NULL. A return"]
    #[doc = " value of true (1) indicates that it succeeded and false (0) indicates that"]
    #[doc = " it failed. The |windows_sandbox_info| parameter is only used on Windows and"]
    #[doc = " may be NULL (see cef_sandbox_win.h for details)."]
    #[doc = ""]
    pub fn cef_initialize(
        args: *const cef_main_args_t,
        settings: *const _cef_settings_t,
        application: *mut cef_app_t,
        windows_sandbox_info: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = ""]
    #[doc = " This function should be called on the main application thread to shut down"]
    #[doc = " the CEF browser process before the application exits."]
    #[doc = ""]
    pub fn cef_shutdown();
}
extern "C" {
    #[doc = ""]
    #[doc = " Perform a single iteration of CEF message loop processing. This function is"]
    #[doc = " provided for cases where the CEF message loop must be integrated into an"]
    #[doc = " existing application message loop. Use of this function is not recommended"]
    #[doc = " for most users; use either the cef_run_message_loop() function or"]
    #[doc = " cef_settings_t.multi_threaded_message_loop if possible. When using this"]
    #[doc = " function care must be taken to balance performance against excessive CPU"]
    #[doc = " usage. It is recommended to enable the cef_settings_t.external_message_pump"]
    #[doc = " option when using this function so that"]
    #[doc = " cef_browser_process_handler_t::on_schedule_message_pump_work() callbacks can"]
    #[doc = " facilitate the scheduling process. This function should only be called on"]
    #[doc = " the main application thread and only if cef_initialize() is called with a"]
    #[doc = " cef_settings_t.multi_threaded_message_loop value of false (0). This function"]
    #[doc = " will not block."]
    #[doc = ""]
    pub fn cef_do_message_loop_work();
}
extern "C" {
    #[doc = ""]
    #[doc = " Run the CEF message loop. Use this function instead of an application-"]
    #[doc = " provided message loop to get the best balance between performance and CPU"]
    #[doc = " usage. This function should only be called on the main application thread"]
    #[doc = " and only if cef_initialize() is called with a"]
    #[doc = " cef_settings_t.multi_threaded_message_loop value of false (0). This function"]
    #[doc = " will block until a quit message is received by the system."]
    #[doc = ""]
    pub fn cef_run_message_loop();
}
extern "C" {
    #[doc = ""]
    #[doc = " Quit the CEF message loop that was started by calling"]
    #[doc = " cef_run_message_loop(). This function should only be called on the main"]
    #[doc = " application thread and only if cef_run_message_loop() was used."]
    #[doc = ""]
    pub fn cef_quit_message_loop();
}
extern "C" {
    #[doc = ""]
    #[doc = " Set to true (1) before calling Windows APIs like TrackPopupMenu that enter a"]
    #[doc = " modal message loop. Set to false (0) after exiting the modal message loop."]
    #[doc = ""]
    pub fn cef_set_osmodal_loop(osModalLoop: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = ""]
    #[doc = " Call during process startup to enable High-DPI support on Windows 7 or"]
    #[doc = " newer. Older versions of Windows should be left DPI-unaware because they do"]
    #[doc = " not support DirectWrite and GDI fonts are kerned very badly."]
    #[doc = ""]
    pub fn cef_enable_highdpi_support();
}
